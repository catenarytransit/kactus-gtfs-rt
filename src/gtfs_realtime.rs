// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702


// Generated file from `gtfs-realtime.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  The contents of a feed message.
///  A feed is a continuous stream of feed messages. Each message in the stream is
///  obtained as a response to an appropriate HTTP GET request.
///  A realtime feed is always defined with relation to an existing GTFS feed.
///  All the entity ids are resolved with respect to the GTFS feed.
///  Note that "required" and "optional" as stated in this file refer to Protocol
///  Buffer cardinality, not semantic cardinality.  See reference.md at
///  https://github.com/google/transit/tree/master/gtfs-realtime for field
///  semantic cardinality.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.FeedMessage)
pub struct FeedMessage {
    // message fields
    ///  Metadata about this feed and feed message.
    // @@protoc_insertion_point(field:transit_realtime.FeedMessage.header)
    pub header: ::protobuf::MessageField<FeedHeader>,
    ///  Contents of the feed.
    // @@protoc_insertion_point(field:transit_realtime.FeedMessage.entity)
    pub entity: ::std::vec::Vec<FeedEntity>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.FeedMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeedMessage {
    fn default() -> &'a FeedMessage {
        <FeedMessage as ::protobuf::Message>::default_instance()
    }
}

impl FeedMessage {
    pub fn new() -> FeedMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeedHeader>(
            "header",
            |m: &FeedMessage| { &m.header },
            |m: &mut FeedMessage| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entity",
            |m: &FeedMessage| { &m.entity },
            |m: &mut FeedMessage| { &mut m.entity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeedMessage>(
            "FeedMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeedMessage {
    const NAME: &'static str = "FeedMessage";

    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.entity.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.entity {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.entity {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeedMessage {
        FeedMessage::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.entity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeedMessage {
        static instance: FeedMessage = FeedMessage {
            header: ::protobuf::MessageField::none(),
            entity: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeedMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeedMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Metadata about a feed, included in feed messages.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.FeedHeader)
pub struct FeedHeader {
    // message fields
    ///  Version of the feed specification.
    ///  The current version is 2.0.  Valid versions are "2.0", "1.0".
    // @@protoc_insertion_point(field:transit_realtime.FeedHeader.gtfs_realtime_version)
    pub gtfs_realtime_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.FeedHeader.incrementality)
    pub incrementality: ::std::option::Option<::protobuf::EnumOrUnknown<feed_header::Incrementality>>,
    ///  This timestamp identifies the moment when the content of this feed has been
    ///  created (in server time). In POSIX time (i.e., number of seconds since
    ///  January 1st 1970 00:00:00 UTC).
    // @@protoc_insertion_point(field:transit_realtime.FeedHeader.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.FeedHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeedHeader {
    fn default() -> &'a FeedHeader {
        <FeedHeader as ::protobuf::Message>::default_instance()
    }
}

impl FeedHeader {
    pub fn new() -> FeedHeader {
        ::std::default::Default::default()
    }

    // required string gtfs_realtime_version = 1;

    pub fn gtfs_realtime_version(&self) -> &str {
        match self.gtfs_realtime_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gtfs_realtime_version(&mut self) {
        self.gtfs_realtime_version = ::std::option::Option::None;
    }

    pub fn has_gtfs_realtime_version(&self) -> bool {
        self.gtfs_realtime_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gtfs_realtime_version(&mut self, v: ::std::string::String) {
        self.gtfs_realtime_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gtfs_realtime_version(&mut self) -> &mut ::std::string::String {
        if self.gtfs_realtime_version.is_none() {
            self.gtfs_realtime_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gtfs_realtime_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_gtfs_realtime_version(&mut self) -> ::std::string::String {
        self.gtfs_realtime_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2;

    pub fn incrementality(&self) -> feed_header::Incrementality {
        match self.incrementality {
            Some(e) => e.enum_value_or(feed_header::Incrementality::FULL_DATASET),
            None => feed_header::Incrementality::FULL_DATASET,
        }
    }

    pub fn clear_incrementality(&mut self) {
        self.incrementality = ::std::option::Option::None;
    }

    pub fn has_incrementality(&self) -> bool {
        self.incrementality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incrementality(&mut self, v: feed_header::Incrementality) {
        self.incrementality = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 timestamp = 3;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gtfs_realtime_version",
            |m: &FeedHeader| { &m.gtfs_realtime_version },
            |m: &mut FeedHeader| { &mut m.gtfs_realtime_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "incrementality",
            |m: &FeedHeader| { &m.incrementality },
            |m: &mut FeedHeader| { &mut m.incrementality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &FeedHeader| { &m.timestamp },
            |m: &mut FeedHeader| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeedHeader>(
            "FeedHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeedHeader {
    const NAME: &'static str = "FeedHeader";

    fn is_initialized(&self) -> bool {
        if self.gtfs_realtime_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gtfs_realtime_version = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.incrementality = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gtfs_realtime_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.incrementality {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gtfs_realtime_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.incrementality {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeedHeader {
        FeedHeader::new()
    }

    fn clear(&mut self) {
        self.gtfs_realtime_version = ::std::option::Option::None;
        self.incrementality = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeedHeader {
        static instance: FeedHeader = FeedHeader {
            gtfs_realtime_version: ::std::option::Option::None,
            incrementality: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeedHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeedHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeedHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FeedHeader`
pub mod feed_header {
    ///  Determines whether the current fetch is incremental.  Currently,
    ///  DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
    ///  that use this mode.  There are discussions on the GTFS Realtime mailing
    ///  list around fully specifying the behavior of DIFFERENTIAL mode and the
    ///  documentation will be updated when those discussions are finalized.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.FeedHeader.Incrementality)
    pub enum Incrementality {
        // @@protoc_insertion_point(enum_value:transit_realtime.FeedHeader.Incrementality.FULL_DATASET)
        FULL_DATASET = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.FeedHeader.Incrementality.DIFFERENTIAL)
        DIFFERENTIAL = 1,
    }

    impl ::protobuf::Enum for Incrementality {
        const NAME: &'static str = "Incrementality";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Incrementality> {
            match value {
                0 => ::std::option::Option::Some(Incrementality::FULL_DATASET),
                1 => ::std::option::Option::Some(Incrementality::DIFFERENTIAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Incrementality] = &[
            Incrementality::FULL_DATASET,
            Incrementality::DIFFERENTIAL,
        ];
    }

    impl ::protobuf::EnumFull for Incrementality {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FeedHeader.Incrementality").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Incrementality {
        fn default() -> Self {
            Incrementality::FULL_DATASET
        }
    }

    impl Incrementality {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Incrementality>("FeedHeader.Incrementality")
        }
    }
}

///  A definition (or update) of an entity in the transit feed.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.FeedEntity)
pub struct FeedEntity {
    // message fields
    ///  The ids are used only to provide incrementality support. The id should be
    ///  unique within a FeedMessage. Consequent FeedMessages may contain
    ///  FeedEntities with the same id. In case of a DIFFERENTIAL update the new
    ///  FeedEntity with some id will replace the old FeedEntity with the same id
    ///  (or delete it - see is_deleted below).
    ///  The actual GTFS entities (e.g. stations, routes, trips) referenced by the
    ///  feed must be specified by explicit selectors (see EntitySelector below for
    ///  more info).
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.id)
    pub id: ::std::option::Option<::std::string::String>,
    ///  Whether this entity is to be deleted. Relevant only for incremental
    ///  fetches.
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.is_deleted)
    pub is_deleted: ::std::option::Option<bool>,
    ///  Data about the entity itself. Exactly one of the following fields must be
    ///  present (unless the entity is being deleted).
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.trip_update)
    pub trip_update: ::protobuf::MessageField<TripUpdate>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.vehicle)
    pub vehicle: ::protobuf::MessageField<VehiclePosition>,
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.alert)
    pub alert: ::protobuf::MessageField<Alert>,
    ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.FeedEntity.shape)
    pub shape: ::protobuf::MessageField<Shape>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.FeedEntity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeedEntity {
    fn default() -> &'a FeedEntity {
        <FeedEntity as ::protobuf::Message>::default_instance()
    }
}

impl FeedEntity {
    pub fn new() -> FeedEntity {
        ::std::default::Default::default()
    }

    // required string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_deleted = 2;

    pub fn is_deleted(&self) -> bool {
        self.is_deleted.unwrap_or(false)
    }

    pub fn clear_is_deleted(&mut self) {
        self.is_deleted = ::std::option::Option::None;
    }

    pub fn has_is_deleted(&self) -> bool {
        self.is_deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_deleted(&mut self, v: bool) {
        self.is_deleted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &FeedEntity| { &m.id },
            |m: &mut FeedEntity| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_deleted",
            |m: &FeedEntity| { &m.is_deleted },
            |m: &mut FeedEntity| { &mut m.is_deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripUpdate>(
            "trip_update",
            |m: &FeedEntity| { &m.trip_update },
            |m: &mut FeedEntity| { &mut m.trip_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VehiclePosition>(
            "vehicle",
            |m: &FeedEntity| { &m.vehicle },
            |m: &mut FeedEntity| { &mut m.vehicle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Alert>(
            "alert",
            |m: &FeedEntity| { &m.alert },
            |m: &mut FeedEntity| { &mut m.alert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Shape>(
            "shape",
            |m: &FeedEntity| { &m.shape },
            |m: &mut FeedEntity| { &mut m.shape },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeedEntity>(
            "FeedEntity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeedEntity {
    const NAME: &'static str = "FeedEntity";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.trip_update {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alert {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.is_deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip_update)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vehicle)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.alert)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shape)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.is_deleted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trip_update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vehicle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.is_deleted {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.trip_update.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.vehicle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.alert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.shape.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeedEntity {
        FeedEntity::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.is_deleted = ::std::option::Option::None;
        self.trip_update.clear();
        self.vehicle.clear();
        self.alert.clear();
        self.shape.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeedEntity {
        static instance: FeedEntity = FeedEntity {
            id: ::std::option::Option::None,
            is_deleted: ::std::option::Option::None,
            trip_update: ::protobuf::MessageField::none(),
            vehicle: ::protobuf::MessageField::none(),
            alert: ::protobuf::MessageField::none(),
            shape: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeedEntity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeedEntity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeedEntity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedEntity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Realtime update of the progress of a vehicle along a trip.
///  Depending on the value of ScheduleRelationship, a TripUpdate can specify:
///  - A trip that proceeds along the schedule.
///  - A trip that proceeds along a route but has no fixed schedule.
///  - A trip that have been added or removed with regard to schedule.
///
///  The updates can be for future, predicted arrival/departure events, or for
///  past events that already occurred.
///  Normally, updates should get more precise and more certain (see
///  uncertainty below) as the events gets closer to current time.
///  Even if that is not possible, the information for past events should be
///  precise and certain. In particular, if an update points to time in the past
///  but its update's uncertainty is not 0, the client should conclude that the
///  update is a (wrong) prediction and that the trip has not completed yet.
///
///  Note that the update can describe a trip that is already completed.
///  To this end, it is enough to provide an update for the last stop of the trip.
///  If the time of that is in the past, the client will conclude from that that
///  the whole trip is in the past (it is possible, although inconsequential, to
///  also provide updates for preceding stops).
///  This option is most relevant for a trip that has completed ahead of schedule,
///  but according to the schedule, the trip is still proceeding at the current
///  time. Removing the updates for this trip could make the client assume
///  that the trip is still proceeding.
///  Note that the feed provider is allowed, but not required, to purge past
///  updates - this is one case where this would be practically useful.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.TripUpdate)
pub struct TripUpdate {
    // message fields
    ///  The Trip that this message applies to. There can be at most one
    ///  TripUpdate entity for each actual trip instance.
    ///  If there is none, that means there is no prediction information available.
    ///  It does *not* mean that the trip is progressing according to schedule.
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.trip)
    pub trip: ::protobuf::MessageField<TripDescriptor>,
    ///  Additional information on the vehicle that is serving this trip.
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.vehicle)
    pub vehicle: ::protobuf::MessageField<VehicleDescriptor>,
    ///  Updates to StopTimes for the trip (both future, i.e., predictions, and in
    ///  some cases, past ones, i.e., those that already happened).
    ///  The updates must be sorted by stop_sequence, and apply for all the
    ///  following stops of the trip up to the next specified one.
    ///
    ///  Example 1:
    ///  For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
    ///  delay of 0 for stop_sequence of the current stop means that the trip is
    ///  exactly on time.
    ///
    ///  Example 2:
    ///  For the same trip instance, 3 StopTimeUpdates are provided:
    ///  - delay of 5 min for stop_sequence 3
    ///  - delay of 1 min for stop_sequence 8
    ///  - delay of unspecified duration for stop_sequence 10
    ///  This will be interpreted as:
    ///  - stop_sequences 3,4,5,6,7 have delay of 5 min.
    ///  - stop_sequences 8,9 have delay of 1 min.
    ///  - stop_sequences 10,... have unknown delay.
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.stop_time_update)
    pub stop_time_update: ::std::vec::Vec<trip_update::StopTimeUpdate>,
    ///  The most recent moment at which the vehicle's real-time progress was measured
    ///  to estimate StopTimes in the future. When StopTimes in the past are provided,
    ///  arrival/departure times may be earlier than this value. In POSIX
    ///  time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    ///  The current schedule deviation for the trip.  Delay should only be
    ///  specified when the prediction is given relative to some existing schedule
    ///  in GTFS.
    ///
    ///  Delay (in seconds) can be positive (meaning that the vehicle is late) or
    ///  negative (meaning that the vehicle is ahead of schedule). Delay of 0
    ///  means that the vehicle is exactly on time.
    ///
    ///  Delay information in StopTimeUpdates take precedent of trip-level delay
    ///  information, such that trip-level delay is only propagated until the next
    ///  stop along the trip with a StopTimeUpdate delay value specified.
    ///
    ///  Feed providers are strongly encouraged to provide a TripUpdate.timestamp
    ///  value indicating when the delay value was last updated, in order to
    ///  evaluate the freshness of the data.
    ///
    ///  NOTE: This field is still experimental, and subject to change. It may be
    ///  formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.delay)
    pub delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:transit_realtime.TripUpdate.trip_properties)
    pub trip_properties: ::protobuf::MessageField<trip_update::TripProperties>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TripUpdate {
    fn default() -> &'a TripUpdate {
        <TripUpdate as ::protobuf::Message>::default_instance()
    }
}

impl TripUpdate {
    pub fn new() -> TripUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 4;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 delay = 5;

    pub fn delay(&self) -> i32 {
        self.delay.unwrap_or(0)
    }

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: i32) {
        self.delay = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripDescriptor>(
            "trip",
            |m: &TripUpdate| { &m.trip },
            |m: &mut TripUpdate| { &mut m.trip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VehicleDescriptor>(
            "vehicle",
            |m: &TripUpdate| { &m.vehicle },
            |m: &mut TripUpdate| { &mut m.vehicle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stop_time_update",
            |m: &TripUpdate| { &m.stop_time_update },
            |m: &mut TripUpdate| { &mut m.stop_time_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &TripUpdate| { &m.timestamp },
            |m: &mut TripUpdate| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay",
            |m: &TripUpdate| { &m.delay },
            |m: &mut TripUpdate| { &mut m.delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, trip_update::TripProperties>(
            "trip_properties",
            |m: &TripUpdate| { &m.trip_properties },
            |m: &mut TripUpdate| { &mut m.trip_properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TripUpdate>(
            "TripUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TripUpdate {
    const NAME: &'static str = "TripUpdate";

    fn is_initialized(&self) -> bool {
        if self.trip.is_none() {
            return false;
        }
        for v in &self.trip {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stop_time_update {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trip_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vehicle)?;
                },
                18 => {
                    self.stop_time_update.push(is.read_message()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.delay = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip_properties)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vehicle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stop_time_update {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.delay {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.trip_properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vehicle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.stop_time_update {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.timestamp {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.delay {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.trip_properties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TripUpdate {
        TripUpdate::new()
    }

    fn clear(&mut self) {
        self.trip.clear();
        self.vehicle.clear();
        self.stop_time_update.clear();
        self.timestamp = ::std::option::Option::None;
        self.delay = ::std::option::Option::None;
        self.trip_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TripUpdate {
        static instance: TripUpdate = TripUpdate {
            trip: ::protobuf::MessageField::none(),
            vehicle: ::protobuf::MessageField::none(),
            stop_time_update: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            delay: ::std::option::Option::None,
            trip_properties: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TripUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TripUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TripUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TripUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TripUpdate`
pub mod trip_update {
    ///  Timing information for a single predicted event (either arrival or
    ///  departure).
    ///  Timing consists of delay and/or estimated time, and uncertainty.
    ///  - delay should be used when the prediction is given relative to some
    ///    existing schedule in GTFS.
    ///  - time should be given whether there is a predicted schedule or not. If
    ///    both time and delay are specified, time will take precedence
    ///    (although normally, time, if given for a scheduled trip, should be
    ///    equal to scheduled time in GTFS + delay).
    ///
    ///  Uncertainty applies equally to both time and delay.
    ///  The uncertainty roughly specifies the expected error in true delay (but
    ///  note, we don't yet define its precise statistical meaning). It's possible
    ///  for the uncertainty to be 0, for example for trains that are driven under
    ///  computer timing control.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:transit_realtime.TripUpdate.StopTimeEvent)
    pub struct StopTimeEvent {
        // message fields
        ///  Delay (in seconds) can be positive (meaning that the vehicle is late) or
        ///  negative (meaning that the vehicle is ahead of schedule). Delay of 0
        ///  means that the vehicle is exactly on time.
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeEvent.delay)
        pub delay: ::std::option::Option<i32>,
        ///  Event as absolute time.
        ///  In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
        ///  UTC).
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeEvent.time)
        pub time: ::std::option::Option<i64>,
        ///  If uncertainty is omitted, it is interpreted as unknown.
        ///  If the prediction is unknown or too uncertain, the delay (or time) field
        ///  should be empty. In such case, the uncertainty field is ignored.
        ///  To specify a completely certain prediction, set its uncertainty to 0.
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
        pub uncertainty: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.StopTimeEvent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StopTimeEvent {
        fn default() -> &'a StopTimeEvent {
            <StopTimeEvent as ::protobuf::Message>::default_instance()
        }
    }

    impl StopTimeEvent {
        pub fn new() -> StopTimeEvent {
            ::std::default::Default::default()
        }

        // optional int32 delay = 1;

        pub fn delay(&self) -> i32 {
            self.delay.unwrap_or(0)
        }

        pub fn clear_delay(&mut self) {
            self.delay = ::std::option::Option::None;
        }

        pub fn has_delay(&self) -> bool {
            self.delay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delay(&mut self, v: i32) {
            self.delay = ::std::option::Option::Some(v);
        }

        // optional int64 time = 2;

        pub fn time(&self) -> i64 {
            self.time.unwrap_or(0)
        }

        pub fn clear_time(&mut self) {
            self.time = ::std::option::Option::None;
        }

        pub fn has_time(&self) -> bool {
            self.time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time(&mut self, v: i64) {
            self.time = ::std::option::Option::Some(v);
        }

        // optional int32 uncertainty = 3;

        pub fn uncertainty(&self) -> i32 {
            self.uncertainty.unwrap_or(0)
        }

        pub fn clear_uncertainty(&mut self) {
            self.uncertainty = ::std::option::Option::None;
        }

        pub fn has_uncertainty(&self) -> bool {
            self.uncertainty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_uncertainty(&mut self, v: i32) {
            self.uncertainty = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delay",
                |m: &StopTimeEvent| { &m.delay },
                |m: &mut StopTimeEvent| { &mut m.delay },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time",
                |m: &StopTimeEvent| { &m.time },
                |m: &mut StopTimeEvent| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "uncertainty",
                |m: &StopTimeEvent| { &m.uncertainty },
                |m: &mut StopTimeEvent| { &mut m.uncertainty },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopTimeEvent>(
                "TripUpdate.StopTimeEvent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StopTimeEvent {
        const NAME: &'static str = "StopTimeEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.delay = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.time = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.uncertainty = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.delay {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.time {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.uncertainty {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.delay {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.time {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.uncertainty {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StopTimeEvent {
            StopTimeEvent::new()
        }

        fn clear(&mut self) {
            self.delay = ::std::option::Option::None;
            self.time = ::std::option::Option::None;
            self.uncertainty = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StopTimeEvent {
            static instance: StopTimeEvent = StopTimeEvent {
                delay: ::std::option::Option::None,
                time: ::std::option::Option::None,
                uncertainty: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StopTimeEvent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripUpdate.StopTimeEvent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StopTimeEvent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StopTimeEvent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Realtime update for arrival and/or departure events for a given stop on a
    ///  trip. Updates can be supplied for both past and future events.
    ///  The producer is allowed, although not required, to drop past events.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:transit_realtime.TripUpdate.StopTimeUpdate)
    pub struct StopTimeUpdate {
        // message fields
        ///  Must be the same as in stop_times.txt in the corresponding GTFS feed.
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
        pub stop_sequence: ::std::option::Option<u32>,
        ///  Must be the same as in stops.txt in the corresponding GTFS feed.
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
        pub stop_id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
        pub arrival: ::protobuf::MessageField<StopTimeEvent>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.departure)
        pub departure: ::protobuf::MessageField<StopTimeEvent>,
        ///  Expected occupancy after departure from the given stop.
        ///  Should be provided only for future stops.
        ///  In order to provide departure_occupancy_status without either arrival or
        ///  departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.departure_occupancy_status)
        pub departure_occupancy_status: ::std::option::Option<::protobuf::EnumOrUnknown<super::vehicle_position::OccupancyStatus>>,
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
        pub schedule_relationship: ::std::option::Option<::protobuf::EnumOrUnknown<stop_time_update::ScheduleRelationship>>,
        ///  Realtime updates for certain properties defined within GTFS stop_times.txt
        ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
        pub stop_time_properties: ::protobuf::MessageField<stop_time_update::StopTimeProperties>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.StopTimeUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StopTimeUpdate {
        fn default() -> &'a StopTimeUpdate {
            <StopTimeUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl StopTimeUpdate {
        pub fn new() -> StopTimeUpdate {
            ::std::default::Default::default()
        }

        // optional uint32 stop_sequence = 1;

        pub fn stop_sequence(&self) -> u32 {
            self.stop_sequence.unwrap_or(0)
        }

        pub fn clear_stop_sequence(&mut self) {
            self.stop_sequence = ::std::option::Option::None;
        }

        pub fn has_stop_sequence(&self) -> bool {
            self.stop_sequence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stop_sequence(&mut self, v: u32) {
            self.stop_sequence = ::std::option::Option::Some(v);
        }

        // optional string stop_id = 4;

        pub fn stop_id(&self) -> &str {
            match self.stop_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_stop_id(&mut self) {
            self.stop_id = ::std::option::Option::None;
        }

        pub fn has_stop_id(&self) -> bool {
            self.stop_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stop_id(&mut self, v: ::std::string::String) {
            self.stop_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
            if self.stop_id.is_none() {
                self.stop_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.stop_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_stop_id(&mut self) -> ::std::string::String {
            self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;

        pub fn departure_occupancy_status(&self) -> super::vehicle_position::OccupancyStatus {
            match self.departure_occupancy_status {
                Some(e) => e.enum_value_or(super::vehicle_position::OccupancyStatus::EMPTY),
                None => super::vehicle_position::OccupancyStatus::EMPTY,
            }
        }

        pub fn clear_departure_occupancy_status(&mut self) {
            self.departure_occupancy_status = ::std::option::Option::None;
        }

        pub fn has_departure_occupancy_status(&self) -> bool {
            self.departure_occupancy_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_departure_occupancy_status(&mut self, v: super::vehicle_position::OccupancyStatus) {
            self.departure_occupancy_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5;

        pub fn schedule_relationship(&self) -> stop_time_update::ScheduleRelationship {
            match self.schedule_relationship {
                Some(e) => e.enum_value_or(stop_time_update::ScheduleRelationship::SCHEDULED),
                None => stop_time_update::ScheduleRelationship::SCHEDULED,
            }
        }

        pub fn clear_schedule_relationship(&mut self) {
            self.schedule_relationship = ::std::option::Option::None;
        }

        pub fn has_schedule_relationship(&self) -> bool {
            self.schedule_relationship.is_some()
        }

        // Param is passed by value, moved
        pub fn set_schedule_relationship(&mut self, v: stop_time_update::ScheduleRelationship) {
            self.schedule_relationship = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stop_sequence",
                |m: &StopTimeUpdate| { &m.stop_sequence },
                |m: &mut StopTimeUpdate| { &mut m.stop_sequence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "stop_id",
                |m: &StopTimeUpdate| { &m.stop_id },
                |m: &mut StopTimeUpdate| { &mut m.stop_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StopTimeEvent>(
                "arrival",
                |m: &StopTimeUpdate| { &m.arrival },
                |m: &mut StopTimeUpdate| { &mut m.arrival },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StopTimeEvent>(
                "departure",
                |m: &StopTimeUpdate| { &m.departure },
                |m: &mut StopTimeUpdate| { &mut m.departure },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "departure_occupancy_status",
                |m: &StopTimeUpdate| { &m.departure_occupancy_status },
                |m: &mut StopTimeUpdate| { &mut m.departure_occupancy_status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "schedule_relationship",
                |m: &StopTimeUpdate| { &m.schedule_relationship },
                |m: &mut StopTimeUpdate| { &mut m.schedule_relationship },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, stop_time_update::StopTimeProperties>(
                "stop_time_properties",
                |m: &StopTimeUpdate| { &m.stop_time_properties },
                |m: &mut StopTimeUpdate| { &mut m.stop_time_properties },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopTimeUpdate>(
                "TripUpdate.StopTimeUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StopTimeUpdate {
        const NAME: &'static str = "StopTimeUpdate";

        fn is_initialized(&self) -> bool {
            for v in &self.arrival {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.departure {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.stop_time_properties {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stop_sequence = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.stop_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.arrival)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.departure)?;
                    },
                    56 => {
                        self.departure_occupancy_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    40 => {
                        self.schedule_relationship = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stop_time_properties)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stop_sequence {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stop_id.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.arrival.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.departure.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.departure_occupancy_status {
                my_size += ::protobuf::rt::int32_size(7, v.value());
            }
            if let Some(v) = self.schedule_relationship {
                my_size += ::protobuf::rt::int32_size(5, v.value());
            }
            if let Some(v) = self.stop_time_properties.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.stop_sequence {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stop_id.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.arrival.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.departure.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.departure_occupancy_status {
                os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.schedule_relationship {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.stop_time_properties.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StopTimeUpdate {
            StopTimeUpdate::new()
        }

        fn clear(&mut self) {
            self.stop_sequence = ::std::option::Option::None;
            self.stop_id = ::std::option::Option::None;
            self.arrival.clear();
            self.departure.clear();
            self.departure_occupancy_status = ::std::option::Option::None;
            self.schedule_relationship = ::std::option::Option::None;
            self.stop_time_properties.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StopTimeUpdate {
            static instance: StopTimeUpdate = StopTimeUpdate {
                stop_sequence: ::std::option::Option::None,
                stop_id: ::std::option::Option::None,
                arrival: ::protobuf::MessageField::none(),
                departure: ::protobuf::MessageField::none(),
                departure_occupancy_status: ::std::option::Option::None,
                schedule_relationship: ::std::option::Option::None,
                stop_time_properties: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StopTimeUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripUpdate.StopTimeUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StopTimeUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StopTimeUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `StopTimeUpdate`
    pub mod stop_time_update {
        ///  Provides the updated values for the stop time.
        ///  NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
        pub struct StopTimeProperties {
            // message fields
            ///  Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
            ///  The new assigned_stop_id should not result in a significantly different trip experience for the end user than
            ///  the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
            ///  "unusual change" if the new stop was presented within an app without any additional context.
            ///  For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
            ///  same station as the stop originally defined in GTFS stop_times.txt.
            ///  To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
            ///  StopTimeUpdate.schedule_relationship = NO_DATA.
            ///  If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
            ///  `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
            ///  Platform assignments should be reflected in other GTFS-realtime fields as well
            ///  (e.g., `VehiclePosition.stop_id`).
            ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
            // @@protoc_insertion_point(field:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
            pub assigned_stop_id: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a StopTimeProperties {
            fn default() -> &'a StopTimeProperties {
                <StopTimeProperties as ::protobuf::Message>::default_instance()
            }
        }

        impl StopTimeProperties {
            pub fn new() -> StopTimeProperties {
                ::std::default::Default::default()
            }

            // optional string assigned_stop_id = 1;

            pub fn assigned_stop_id(&self) -> &str {
                match self.assigned_stop_id.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_assigned_stop_id(&mut self) {
                self.assigned_stop_id = ::std::option::Option::None;
            }

            pub fn has_assigned_stop_id(&self) -> bool {
                self.assigned_stop_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_assigned_stop_id(&mut self, v: ::std::string::String) {
                self.assigned_stop_id = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_assigned_stop_id(&mut self) -> &mut ::std::string::String {
                if self.assigned_stop_id.is_none() {
                    self.assigned_stop_id = ::std::option::Option::Some(::std::string::String::new());
                }
                self.assigned_stop_id.as_mut().unwrap()
            }

            // Take field
            pub fn take_assigned_stop_id(&mut self) -> ::std::string::String {
                self.assigned_stop_id.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "assigned_stop_id",
                    |m: &StopTimeProperties| { &m.assigned_stop_id },
                    |m: &mut StopTimeProperties| { &mut m.assigned_stop_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StopTimeProperties>(
                    "TripUpdate.StopTimeUpdate.StopTimeProperties",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for StopTimeProperties {
            const NAME: &'static str = "StopTimeProperties";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.assigned_stop_id = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.assigned_stop_id.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.assigned_stop_id.as_ref() {
                    os.write_string(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> StopTimeProperties {
                StopTimeProperties::new()
            }

            fn clear(&mut self) {
                self.assigned_stop_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static StopTimeProperties {
                static instance: StopTimeProperties = StopTimeProperties {
                    assigned_stop_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for StopTimeProperties {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("TripUpdate.StopTimeUpdate.StopTimeProperties").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for StopTimeProperties {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for StopTimeProperties {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        ///  The relation between the StopTimeEvents and the static schedule.
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship)
        pub enum ScheduleRelationship {
            // @@protoc_insertion_point(enum_value:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED)
            SCHEDULED = 0,
            // @@protoc_insertion_point(enum_value:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED)
            SKIPPED = 1,
            // @@protoc_insertion_point(enum_value:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.NO_DATA)
            NO_DATA = 2,
            // @@protoc_insertion_point(enum_value:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.UNSCHEDULED)
            UNSCHEDULED = 3,
        }

        impl ::protobuf::Enum for ScheduleRelationship {
            const NAME: &'static str = "ScheduleRelationship";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ScheduleRelationship> {
                match value {
                    0 => ::std::option::Option::Some(ScheduleRelationship::SCHEDULED),
                    1 => ::std::option::Option::Some(ScheduleRelationship::SKIPPED),
                    2 => ::std::option::Option::Some(ScheduleRelationship::NO_DATA),
                    3 => ::std::option::Option::Some(ScheduleRelationship::UNSCHEDULED),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ScheduleRelationship] = &[
                ScheduleRelationship::SCHEDULED,
                ScheduleRelationship::SKIPPED,
                ScheduleRelationship::NO_DATA,
                ScheduleRelationship::UNSCHEDULED,
            ];
        }

        impl ::protobuf::EnumFull for ScheduleRelationship {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("TripUpdate.StopTimeUpdate.ScheduleRelationship").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for ScheduleRelationship {
            fn default() -> Self {
                ScheduleRelationship::SCHEDULED
            }
        }

        impl ScheduleRelationship {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ScheduleRelationship>("TripUpdate.StopTimeUpdate.ScheduleRelationship")
            }
        }
    }

    ///  Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
    ///  trip_id, start_date, and start_time of a DUPLICATED trip. 
    ///  NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:transit_realtime.TripUpdate.TripProperties)
    pub struct TripProperties {
        // message fields
        ///  Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
        ///  but will start at a different service date and/or time (defined using the TripProperties.start_date and
        ///  TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
        ///  than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
        ///  be populated and will be ignored by consumers.
        ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.TripProperties.trip_id)
        pub trip_id: ::std::option::Option<::std::string::String>,
        ///  Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
        ///  schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
        ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.TripProperties.start_date)
        pub start_date: ::std::option::Option<::std::string::String>,
        ///  Defines the departure start time of the trip when its duplicated. See definition of stop_times.departure_time
        ///  in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
        ///  between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
        ///  departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
        ///  of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
        ///  delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
        ///  departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
        ///  prediction time values do not have any offset applied to them and indicate the predicted time as provided.
        ///  For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
        ///  is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
        ///  populated and will be ignored by consumers.
        ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.TripProperties.start_time)
        pub start_time: ::std::option::Option<::std::string::String>,
        ///  Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
        ///  (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
        ///  paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
        ///  nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
        ///  or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
        ///  (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
        ///  be marked as schedule_relationship=SKIPPED.
        ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
        // @@protoc_insertion_point(field:transit_realtime.TripUpdate.TripProperties.shape_id)
        pub shape_id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TripUpdate.TripProperties.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TripProperties {
        fn default() -> &'a TripProperties {
            <TripProperties as ::protobuf::Message>::default_instance()
        }
    }

    impl TripProperties {
        pub fn new() -> TripProperties {
            ::std::default::Default::default()
        }

        // optional string trip_id = 1;

        pub fn trip_id(&self) -> &str {
            match self.trip_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_trip_id(&mut self) {
            self.trip_id = ::std::option::Option::None;
        }

        pub fn has_trip_id(&self) -> bool {
            self.trip_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trip_id(&mut self, v: ::std::string::String) {
            self.trip_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_trip_id(&mut self) -> &mut ::std::string::String {
            if self.trip_id.is_none() {
                self.trip_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.trip_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_trip_id(&mut self) -> ::std::string::String {
            self.trip_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string start_date = 2;

        pub fn start_date(&self) -> &str {
            match self.start_date.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_start_date(&mut self) {
            self.start_date = ::std::option::Option::None;
        }

        pub fn has_start_date(&self) -> bool {
            self.start_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_date(&mut self, v: ::std::string::String) {
            self.start_date = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_start_date(&mut self) -> &mut ::std::string::String {
            if self.start_date.is_none() {
                self.start_date = ::std::option::Option::Some(::std::string::String::new());
            }
            self.start_date.as_mut().unwrap()
        }

        // Take field
        pub fn take_start_date(&mut self) -> ::std::string::String {
            self.start_date.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string start_time = 3;

        pub fn start_time(&self) -> &str {
            match self.start_time.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: ::std::string::String) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_start_time(&mut self) -> &mut ::std::string::String {
            if self.start_time.is_none() {
                self.start_time = ::std::option::Option::Some(::std::string::String::new());
            }
            self.start_time.as_mut().unwrap()
        }

        // Take field
        pub fn take_start_time(&mut self) -> ::std::string::String {
            self.start_time.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string shape_id = 4;

        pub fn shape_id(&self) -> &str {
            match self.shape_id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_shape_id(&mut self) {
            self.shape_id = ::std::option::Option::None;
        }

        pub fn has_shape_id(&self) -> bool {
            self.shape_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shape_id(&mut self, v: ::std::string::String) {
            self.shape_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_shape_id(&mut self) -> &mut ::std::string::String {
            if self.shape_id.is_none() {
                self.shape_id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.shape_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_shape_id(&mut self) -> ::std::string::String {
            self.shape_id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "trip_id",
                |m: &TripProperties| { &m.trip_id },
                |m: &mut TripProperties| { &mut m.trip_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_date",
                |m: &TripProperties| { &m.start_date },
                |m: &mut TripProperties| { &mut m.start_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_time",
                |m: &TripProperties| { &m.start_time },
                |m: &mut TripProperties| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "shape_id",
                |m: &TripProperties| { &m.shape_id },
                |m: &mut TripProperties| { &mut m.shape_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TripProperties>(
                "TripUpdate.TripProperties",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TripProperties {
        const NAME: &'static str = "TripProperties";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.trip_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.start_date = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.start_time = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.shape_id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.trip_id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.start_date.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.start_time.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.shape_id.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.trip_id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.start_date.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.start_time.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.shape_id.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TripProperties {
            TripProperties::new()
        }

        fn clear(&mut self) {
            self.trip_id = ::std::option::Option::None;
            self.start_date = ::std::option::Option::None;
            self.start_time = ::std::option::Option::None;
            self.shape_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TripProperties {
            static instance: TripProperties = TripProperties {
                trip_id: ::std::option::Option::None,
                start_date: ::std::option::Option::None,
                start_time: ::std::option::Option::None,
                shape_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TripProperties {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TripUpdate.TripProperties").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TripProperties {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TripProperties {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Realtime positioning information for a given vehicle.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.VehiclePosition)
pub struct VehiclePosition {
    // message fields
    ///  The Trip that this vehicle is serving.
    ///  Can be empty or partial if the vehicle can not be identified with a given
    ///  trip instance.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.trip)
    pub trip: ::protobuf::MessageField<TripDescriptor>,
    ///  Additional information on the vehicle that is serving this trip.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.vehicle)
    pub vehicle: ::protobuf::MessageField<VehicleDescriptor>,
    ///  Current position of this vehicle.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.position)
    pub position: ::protobuf::MessageField<Position>,
    ///  The stop sequence index of the current stop. The meaning of
    ///  current_stop_sequence (i.e., the stop that it refers to) is determined by
    ///  current_status.
    ///  If current_status is missing IN_TRANSIT_TO is assumed.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.current_stop_sequence)
    pub current_stop_sequence: ::std::option::Option<u32>,
    ///  Identifies the current stop. The value must be the same as in stops.txt in
    ///  the corresponding GTFS feed.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.stop_id)
    pub stop_id: ::std::option::Option<::std::string::String>,
    ///  The exact status of the vehicle with respect to the current stop.
    ///  Ignored if current_stop_sequence is missing.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.current_status)
    pub current_status: ::std::option::Option<::protobuf::EnumOrUnknown<vehicle_position::VehicleStopStatus>>,
    ///  Moment at which the vehicle's position was measured. In POSIX time
    ///  (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.congestion_level)
    pub congestion_level: ::std::option::Option<::protobuf::EnumOrUnknown<vehicle_position::CongestionLevel>>,
    ///  If multi_carriage_status is populated with per-carriage OccupancyStatus,
    ///  then this field should describe the entire vehicle with all carriages accepting passengers considered.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.occupancy_status)
    pub occupancy_status: ::std::option::Option<::protobuf::EnumOrUnknown<vehicle_position::OccupancyStatus>>,
    ///  A percentage value indicating the degree of passenger occupancy in the vehicle.
    ///  The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
    ///  The value 100 should represent the total maximum occupancy the vehicle was designed for,
    ///  including both seated and standing capacity, and current operating regulations allow.
    ///  The value may exceed 100 if there are more passengers than the maximum designed capacity.
    ///  The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
    ///  If multi_carriage_status is populated with per-carriage occupancy_percentage, 
    ///  then this field should describe the entire vehicle with all carriages accepting passengers considered.
    ///  This field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.occupancy_percentage)
    pub occupancy_percentage: ::std::option::Option<u32>,
    ///  Details of the multiple carriages of this given vehicle.
    ///  The first occurrence represents the first carriage of the vehicle, 
    ///  given the current direction of travel. 
    ///  The number of occurrences of the multi_carriage_details 
    ///  field represents the number of carriages of the vehicle.
    ///  It also includes non boardable carriages, 
    ///  like engines, maintenance carriages, etc as they provide valuable 
    ///  information to passengers about where to stand on a platform.
    ///  This message/field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.multi_carriage_details)
    pub multi_carriage_details: ::std::vec::Vec<vehicle_position::CarriageDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.VehiclePosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VehiclePosition {
    fn default() -> &'a VehiclePosition {
        <VehiclePosition as ::protobuf::Message>::default_instance()
    }
}

impl VehiclePosition {
    pub fn new() -> VehiclePosition {
        ::std::default::Default::default()
    }

    // optional uint32 current_stop_sequence = 3;

    pub fn current_stop_sequence(&self) -> u32 {
        self.current_stop_sequence.unwrap_or(0)
    }

    pub fn clear_current_stop_sequence(&mut self) {
        self.current_stop_sequence = ::std::option::Option::None;
    }

    pub fn has_current_stop_sequence(&self) -> bool {
        self.current_stop_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_stop_sequence(&mut self, v: u32) {
        self.current_stop_sequence = ::std::option::Option::Some(v);
    }

    // optional string stop_id = 7;

    pub fn stop_id(&self) -> &str {
        match self.stop_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stop_id(&mut self) {
        self.stop_id = ::std::option::Option::None;
    }

    pub fn has_stop_id(&self) -> bool {
        self.stop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_id(&mut self, v: ::std::string::String) {
        self.stop_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
        if self.stop_id.is_none() {
            self.stop_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stop_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stop_id(&mut self) -> ::std::string::String {
        self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4;

    pub fn current_status(&self) -> vehicle_position::VehicleStopStatus {
        match self.current_status {
            Some(e) => e.enum_value_or(vehicle_position::VehicleStopStatus::IN_TRANSIT_TO),
            None => vehicle_position::VehicleStopStatus::IN_TRANSIT_TO,
        }
    }

    pub fn clear_current_status(&mut self) {
        self.current_status = ::std::option::Option::None;
    }

    pub fn has_current_status(&self) -> bool {
        self.current_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_status(&mut self, v: vehicle_position::VehicleStopStatus) {
        self.current_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 timestamp = 5;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;

    pub fn congestion_level(&self) -> vehicle_position::CongestionLevel {
        match self.congestion_level {
            Some(e) => e.enum_value_or(vehicle_position::CongestionLevel::UNKNOWN_CONGESTION_LEVEL),
            None => vehicle_position::CongestionLevel::UNKNOWN_CONGESTION_LEVEL,
        }
    }

    pub fn clear_congestion_level(&mut self) {
        self.congestion_level = ::std::option::Option::None;
    }

    pub fn has_congestion_level(&self) -> bool {
        self.congestion_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_congestion_level(&mut self, v: vehicle_position::CongestionLevel) {
        self.congestion_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;

    pub fn occupancy_status(&self) -> vehicle_position::OccupancyStatus {
        match self.occupancy_status {
            Some(e) => e.enum_value_or(vehicle_position::OccupancyStatus::EMPTY),
            None => vehicle_position::OccupancyStatus::EMPTY,
        }
    }

    pub fn clear_occupancy_status(&mut self) {
        self.occupancy_status = ::std::option::Option::None;
    }

    pub fn has_occupancy_status(&self) -> bool {
        self.occupancy_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occupancy_status(&mut self, v: vehicle_position::OccupancyStatus) {
        self.occupancy_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 occupancy_percentage = 10;

    pub fn occupancy_percentage(&self) -> u32 {
        self.occupancy_percentage.unwrap_or(0)
    }

    pub fn clear_occupancy_percentage(&mut self) {
        self.occupancy_percentage = ::std::option::Option::None;
    }

    pub fn has_occupancy_percentage(&self) -> bool {
        self.occupancy_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_occupancy_percentage(&mut self, v: u32) {
        self.occupancy_percentage = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripDescriptor>(
            "trip",
            |m: &VehiclePosition| { &m.trip },
            |m: &mut VehiclePosition| { &mut m.trip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VehicleDescriptor>(
            "vehicle",
            |m: &VehiclePosition| { &m.vehicle },
            |m: &mut VehiclePosition| { &mut m.vehicle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "position",
            |m: &VehiclePosition| { &m.position },
            |m: &mut VehiclePosition| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_stop_sequence",
            |m: &VehiclePosition| { &m.current_stop_sequence },
            |m: &mut VehiclePosition| { &mut m.current_stop_sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_id",
            |m: &VehiclePosition| { &m.stop_id },
            |m: &mut VehiclePosition| { &mut m.stop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_status",
            |m: &VehiclePosition| { &m.current_status },
            |m: &mut VehiclePosition| { &mut m.current_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &VehiclePosition| { &m.timestamp },
            |m: &mut VehiclePosition| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "congestion_level",
            |m: &VehiclePosition| { &m.congestion_level },
            |m: &mut VehiclePosition| { &mut m.congestion_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "occupancy_status",
            |m: &VehiclePosition| { &m.occupancy_status },
            |m: &mut VehiclePosition| { &mut m.occupancy_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "occupancy_percentage",
            |m: &VehiclePosition| { &m.occupancy_percentage },
            |m: &mut VehiclePosition| { &mut m.occupancy_percentage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "multi_carriage_details",
            |m: &VehiclePosition| { &m.multi_carriage_details },
            |m: &mut VehiclePosition| { &mut m.multi_carriage_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VehiclePosition>(
            "VehiclePosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VehiclePosition {
    const NAME: &'static str = "VehiclePosition";

    fn is_initialized(&self) -> bool {
        for v in &self.trip {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vehicle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multi_carriage_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vehicle)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                24 => {
                    self.current_stop_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.stop_id = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.current_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.congestion_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.occupancy_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.occupancy_percentage = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.multi_carriage_details.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vehicle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.current_stop_sequence {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.stop_id.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.current_status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.congestion_level {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.occupancy_status {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.occupancy_percentage {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        for value in &self.multi_carriage_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vehicle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.current_stop_sequence {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.stop_id.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.current_status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.congestion_level {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.occupancy_status {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.occupancy_percentage {
            os.write_uint32(10, v)?;
        }
        for v in &self.multi_carriage_details {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VehiclePosition {
        VehiclePosition::new()
    }

    fn clear(&mut self) {
        self.trip.clear();
        self.vehicle.clear();
        self.position.clear();
        self.current_stop_sequence = ::std::option::Option::None;
        self.stop_id = ::std::option::Option::None;
        self.current_status = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.congestion_level = ::std::option::Option::None;
        self.occupancy_status = ::std::option::Option::None;
        self.occupancy_percentage = ::std::option::Option::None;
        self.multi_carriage_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VehiclePosition {
        static instance: VehiclePosition = VehiclePosition {
            trip: ::protobuf::MessageField::none(),
            vehicle: ::protobuf::MessageField::none(),
            position: ::protobuf::MessageField::none(),
            current_stop_sequence: ::std::option::Option::None,
            stop_id: ::std::option::Option::None,
            current_status: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            congestion_level: ::std::option::Option::None,
            occupancy_status: ::std::option::Option::None,
            occupancy_percentage: ::std::option::Option::None,
            multi_carriage_details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VehiclePosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VehiclePosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VehiclePosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VehiclePosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VehiclePosition`
pub mod vehicle_position {
    ///  Carriage specific details, used for vehicles composed of several carriages
    ///  This message/field is still experimental, and subject to change. It may be formally adopted in the future.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:transit_realtime.VehiclePosition.CarriageDetails)
    pub struct CarriageDetails {
        // message fields
        ///  Identification of the carriage. Should be unique per vehicle.
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.id)
        pub id: ::std::option::Option<::std::string::String>,
        ///  User visible label that may be shown to the passenger to help identify
        ///  the carriage. Example: "7712", "Car ABC-32", etc...
        ///  This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.label)
        pub label: ::std::option::Option<::std::string::String>,
        ///  Occupancy status for this given carriage, in this vehicle
        ///  This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.occupancy_status)
        pub occupancy_status: ::std::option::Option<::protobuf::EnumOrUnknown<OccupancyStatus>>,
        ///  Occupancy percentage for this given carriage, in this vehicle.
        ///  Follows the same rules as "VehiclePosition.occupancy_percentage"
        ///  -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
        ///  This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.occupancy_percentage)
        pub occupancy_percentage: ::std::option::Option<i32>,
        ///  Identifies the order of this carriage with respect to the other
        ///  carriages in the vehicle's list of CarriageDetails.
        ///  The first carriage in the direction of travel must have a value of 1.
        ///  The second value corresponds to the second carriage in the direction
        ///  of travel and must have a value of 2, and so forth.
        ///  For example, the first carriage in the direction of travel has a value of 1.
        ///  If the second carriage in the direction of travel has a value of 3,
        ///  consumers will discard data for all carriages (i.e., the multi_carriage_details field).
        ///  Carriages without data must be represented with a valid carriage_sequence number and the fields 
        ///  without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
        ///  This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        // @@protoc_insertion_point(field:transit_realtime.VehiclePosition.CarriageDetails.carriage_sequence)
        pub carriage_sequence: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.VehiclePosition.CarriageDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CarriageDetails {
        fn default() -> &'a CarriageDetails {
            <CarriageDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl CarriageDetails {
        pub fn new() -> CarriageDetails {
            ::std::default::Default::default()
        }

        // optional string id = 1;

        pub fn id(&self) -> &str {
            match self.id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: ::std::string::String) {
            self.id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_id(&mut self) -> &mut ::std::string::String {
            if self.id.is_none() {
                self.id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.id.as_mut().unwrap()
        }

        // Take field
        pub fn take_id(&mut self) -> ::std::string::String {
            self.id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string label = 2;

        pub fn label(&self) -> &str {
            match self.label.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }

        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }

        // Param is passed by value, moved
        pub fn set_label(&mut self, v: ::std::string::String) {
            self.label = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_label(&mut self) -> &mut ::std::string::String {
            if self.label.is_none() {
                self.label = ::std::option::Option::Some(::std::string::String::new());
            }
            self.label.as_mut().unwrap()
        }

        // Take field
        pub fn take_label(&mut self) -> ::std::string::String {
            self.label.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3;

        pub fn occupancy_status(&self) -> OccupancyStatus {
            match self.occupancy_status {
                Some(e) => e.enum_value_or(OccupancyStatus::NO_DATA_AVAILABLE),
                None => OccupancyStatus::NO_DATA_AVAILABLE,
            }
        }

        pub fn clear_occupancy_status(&mut self) {
            self.occupancy_status = ::std::option::Option::None;
        }

        pub fn has_occupancy_status(&self) -> bool {
            self.occupancy_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_occupancy_status(&mut self, v: OccupancyStatus) {
            self.occupancy_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional int32 occupancy_percentage = 4;

        pub fn occupancy_percentage(&self) -> i32 {
            self.occupancy_percentage.unwrap_or(-1i32)
        }

        pub fn clear_occupancy_percentage(&mut self) {
            self.occupancy_percentage = ::std::option::Option::None;
        }

        pub fn has_occupancy_percentage(&self) -> bool {
            self.occupancy_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_occupancy_percentage(&mut self, v: i32) {
            self.occupancy_percentage = ::std::option::Option::Some(v);
        }

        // optional uint32 carriage_sequence = 5;

        pub fn carriage_sequence(&self) -> u32 {
            self.carriage_sequence.unwrap_or(0)
        }

        pub fn clear_carriage_sequence(&mut self) {
            self.carriage_sequence = ::std::option::Option::None;
        }

        pub fn has_carriage_sequence(&self) -> bool {
            self.carriage_sequence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_carriage_sequence(&mut self, v: u32) {
            self.carriage_sequence = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &CarriageDetails| { &m.id },
                |m: &mut CarriageDetails| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "label",
                |m: &CarriageDetails| { &m.label },
                |m: &mut CarriageDetails| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "occupancy_status",
                |m: &CarriageDetails| { &m.occupancy_status },
                |m: &mut CarriageDetails| { &mut m.occupancy_status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "occupancy_percentage",
                |m: &CarriageDetails| { &m.occupancy_percentage },
                |m: &mut CarriageDetails| { &mut m.occupancy_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "carriage_sequence",
                |m: &CarriageDetails| { &m.carriage_sequence },
                |m: &mut CarriageDetails| { &mut m.carriage_sequence },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CarriageDetails>(
                "VehiclePosition.CarriageDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CarriageDetails {
        const NAME: &'static str = "CarriageDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.label = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.occupancy_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.occupancy_percentage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.carriage_sequence = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.label.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.occupancy_status {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.occupancy_percentage {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.carriage_sequence {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.label.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.occupancy_status {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.occupancy_percentage {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.carriage_sequence {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CarriageDetails {
            CarriageDetails::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.label = ::std::option::Option::None;
            self.occupancy_status = ::std::option::Option::None;
            self.occupancy_percentage = ::std::option::Option::None;
            self.carriage_sequence = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CarriageDetails {
            static instance: CarriageDetails = CarriageDetails {
                id: ::std::option::Option::None,
                label: ::std::option::Option::None,
                occupancy_status: ::std::option::Option::None,
                occupancy_percentage: ::std::option::Option::None,
                carriage_sequence: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CarriageDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("VehiclePosition.CarriageDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CarriageDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CarriageDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.VehiclePosition.VehicleStopStatus)
    pub enum VehicleStopStatus {
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.VehicleStopStatus.INCOMING_AT)
        INCOMING_AT = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.VehicleStopStatus.STOPPED_AT)
        STOPPED_AT = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.VehicleStopStatus.IN_TRANSIT_TO)
        IN_TRANSIT_TO = 2,
    }

    impl ::protobuf::Enum for VehicleStopStatus {
        const NAME: &'static str = "VehicleStopStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<VehicleStopStatus> {
            match value {
                0 => ::std::option::Option::Some(VehicleStopStatus::INCOMING_AT),
                1 => ::std::option::Option::Some(VehicleStopStatus::STOPPED_AT),
                2 => ::std::option::Option::Some(VehicleStopStatus::IN_TRANSIT_TO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [VehicleStopStatus] = &[
            VehicleStopStatus::INCOMING_AT,
            VehicleStopStatus::STOPPED_AT,
            VehicleStopStatus::IN_TRANSIT_TO,
        ];
    }

    impl ::protobuf::EnumFull for VehicleStopStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VehiclePosition.VehicleStopStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for VehicleStopStatus {
        fn default() -> Self {
            VehicleStopStatus::INCOMING_AT
        }
    }

    impl VehicleStopStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VehicleStopStatus>("VehiclePosition.VehicleStopStatus")
        }
    }

    ///  Congestion level that is affecting this vehicle.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.VehiclePosition.CongestionLevel)
    pub enum CongestionLevel {
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.UNKNOWN_CONGESTION_LEVEL)
        UNKNOWN_CONGESTION_LEVEL = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.RUNNING_SMOOTHLY)
        RUNNING_SMOOTHLY = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.STOP_AND_GO)
        STOP_AND_GO = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.CONGESTION)
        CONGESTION = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.CongestionLevel.SEVERE_CONGESTION)
        SEVERE_CONGESTION = 4,
    }

    impl ::protobuf::Enum for CongestionLevel {
        const NAME: &'static str = "CongestionLevel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CongestionLevel> {
            match value {
                0 => ::std::option::Option::Some(CongestionLevel::UNKNOWN_CONGESTION_LEVEL),
                1 => ::std::option::Option::Some(CongestionLevel::RUNNING_SMOOTHLY),
                2 => ::std::option::Option::Some(CongestionLevel::STOP_AND_GO),
                3 => ::std::option::Option::Some(CongestionLevel::CONGESTION),
                4 => ::std::option::Option::Some(CongestionLevel::SEVERE_CONGESTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CongestionLevel] = &[
            CongestionLevel::UNKNOWN_CONGESTION_LEVEL,
            CongestionLevel::RUNNING_SMOOTHLY,
            CongestionLevel::STOP_AND_GO,
            CongestionLevel::CONGESTION,
            CongestionLevel::SEVERE_CONGESTION,
        ];
    }

    impl ::protobuf::EnumFull for CongestionLevel {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VehiclePosition.CongestionLevel").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CongestionLevel {
        fn default() -> Self {
            CongestionLevel::UNKNOWN_CONGESTION_LEVEL
        }
    }

    impl CongestionLevel {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CongestionLevel>("VehiclePosition.CongestionLevel")
        }
    }

    ///  The state of passenger occupancy for the vehicle or carriage.
    ///  Individual producers may not publish all OccupancyStatus values. Therefore, consumers
    ///  must not assume that the OccupancyStatus values follow a linear scale.
    ///  Consumers should represent OccupancyStatus values as the state indicated 
    ///  and intended by the producer. Likewise, producers must use OccupancyStatus values that
    ///  correspond to actual vehicle occupancy states.
    ///  For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
    ///  This field is still experimental, and subject to change. It may be formally adopted in the future.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.VehiclePosition.OccupancyStatus)
    pub enum OccupancyStatus {
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.EMPTY)
        EMPTY = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.MANY_SEATS_AVAILABLE)
        MANY_SEATS_AVAILABLE = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.FEW_SEATS_AVAILABLE)
        FEW_SEATS_AVAILABLE = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.STANDING_ROOM_ONLY)
        STANDING_ROOM_ONLY = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.CRUSHED_STANDING_ROOM_ONLY)
        CRUSHED_STANDING_ROOM_ONLY = 4,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.FULL)
        FULL = 5,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.NOT_ACCEPTING_PASSENGERS)
        NOT_ACCEPTING_PASSENGERS = 6,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.NO_DATA_AVAILABLE)
        NO_DATA_AVAILABLE = 7,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehiclePosition.OccupancyStatus.NOT_BOARDABLE)
        NOT_BOARDABLE = 8,
    }

    impl ::protobuf::Enum for OccupancyStatus {
        const NAME: &'static str = "OccupancyStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OccupancyStatus> {
            match value {
                0 => ::std::option::Option::Some(OccupancyStatus::EMPTY),
                1 => ::std::option::Option::Some(OccupancyStatus::MANY_SEATS_AVAILABLE),
                2 => ::std::option::Option::Some(OccupancyStatus::FEW_SEATS_AVAILABLE),
                3 => ::std::option::Option::Some(OccupancyStatus::STANDING_ROOM_ONLY),
                4 => ::std::option::Option::Some(OccupancyStatus::CRUSHED_STANDING_ROOM_ONLY),
                5 => ::std::option::Option::Some(OccupancyStatus::FULL),
                6 => ::std::option::Option::Some(OccupancyStatus::NOT_ACCEPTING_PASSENGERS),
                7 => ::std::option::Option::Some(OccupancyStatus::NO_DATA_AVAILABLE),
                8 => ::std::option::Option::Some(OccupancyStatus::NOT_BOARDABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OccupancyStatus] = &[
            OccupancyStatus::EMPTY,
            OccupancyStatus::MANY_SEATS_AVAILABLE,
            OccupancyStatus::FEW_SEATS_AVAILABLE,
            OccupancyStatus::STANDING_ROOM_ONLY,
            OccupancyStatus::CRUSHED_STANDING_ROOM_ONLY,
            OccupancyStatus::FULL,
            OccupancyStatus::NOT_ACCEPTING_PASSENGERS,
            OccupancyStatus::NO_DATA_AVAILABLE,
            OccupancyStatus::NOT_BOARDABLE,
        ];
    }

    impl ::protobuf::EnumFull for OccupancyStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VehiclePosition.OccupancyStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for OccupancyStatus {
        fn default() -> Self {
            OccupancyStatus::EMPTY
        }
    }

    impl OccupancyStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OccupancyStatus>("VehiclePosition.OccupancyStatus")
        }
    }
}

///  An alert, indicating some sort of incident in the public transit network.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.Alert)
pub struct Alert {
    // message fields
    ///  Time when the alert should be shown to the user. If missing, the
    ///  alert will be shown as long as it appears in the feed.
    ///  If multiple ranges are given, the alert will be shown during all of them.
    // @@protoc_insertion_point(field:transit_realtime.Alert.active_period)
    pub active_period: ::std::vec::Vec<TimeRange>,
    ///  Entities whose users we should notify of this alert.
    // @@protoc_insertion_point(field:transit_realtime.Alert.informed_entity)
    pub informed_entity: ::std::vec::Vec<EntitySelector>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.cause)
    pub cause: ::std::option::Option<::protobuf::EnumOrUnknown<alert::Cause>>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.effect)
    pub effect: ::std::option::Option<::protobuf::EnumOrUnknown<alert::Effect>>,
    ///  The URL which provides additional information about the alert.
    // @@protoc_insertion_point(field:transit_realtime.Alert.url)
    pub url: ::protobuf::MessageField<TranslatedString>,
    ///  Alert header. Contains a short summary of the alert text as plain-text.
    // @@protoc_insertion_point(field:transit_realtime.Alert.header_text)
    pub header_text: ::protobuf::MessageField<TranslatedString>,
    ///  Full description for the alert as plain-text. The information in the
    ///  description should add to the information of the header.
    // @@protoc_insertion_point(field:transit_realtime.Alert.description_text)
    pub description_text: ::protobuf::MessageField<TranslatedString>,
    ///  Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
    // @@protoc_insertion_point(field:transit_realtime.Alert.tts_header_text)
    pub tts_header_text: ::protobuf::MessageField<TranslatedString>,
    ///  Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
    // @@protoc_insertion_point(field:transit_realtime.Alert.tts_description_text)
    pub tts_description_text: ::protobuf::MessageField<TranslatedString>,
    // @@protoc_insertion_point(field:transit_realtime.Alert.severity_level)
    pub severity_level: ::std::option::Option<::protobuf::EnumOrUnknown<alert::SeverityLevel>>,
    ///  TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
    ///  The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
    ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.Alert.image)
    pub image: ::protobuf::MessageField<TranslatedImage>,
    ///  Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
    ///  or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
    ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.Alert.image_alternative_text)
    pub image_alternative_text: ::protobuf::MessageField<TranslatedString>,
    ///  Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
    ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.Alert.cause_detail)
    pub cause_detail: ::protobuf::MessageField<TranslatedString>,
    ///  Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
    ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.Alert.effect_detail)
    pub effect_detail: ::protobuf::MessageField<TranslatedString>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.Alert.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Alert {
    fn default() -> &'a Alert {
        <Alert as ::protobuf::Message>::default_instance()
    }
}

impl Alert {
    pub fn new() -> Alert {
        ::std::default::Default::default()
    }

    // optional .transit_realtime.Alert.Cause cause = 6;

    pub fn cause(&self) -> alert::Cause {
        match self.cause {
            Some(e) => e.enum_value_or(alert::Cause::UNKNOWN_CAUSE),
            None => alert::Cause::UNKNOWN_CAUSE,
        }
    }

    pub fn clear_cause(&mut self) {
        self.cause = ::std::option::Option::None;
    }

    pub fn has_cause(&self) -> bool {
        self.cause.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cause(&mut self, v: alert::Cause) {
        self.cause = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .transit_realtime.Alert.Effect effect = 7;

    pub fn effect(&self) -> alert::Effect {
        match self.effect {
            Some(e) => e.enum_value_or(alert::Effect::UNKNOWN_EFFECT),
            None => alert::Effect::UNKNOWN_EFFECT,
        }
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: alert::Effect) {
        self.effect = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .transit_realtime.Alert.SeverityLevel severity_level = 14;

    pub fn severity_level(&self) -> alert::SeverityLevel {
        match self.severity_level {
            Some(e) => e.enum_value_or(alert::SeverityLevel::UNKNOWN_SEVERITY),
            None => alert::SeverityLevel::UNKNOWN_SEVERITY,
        }
    }

    pub fn clear_severity_level(&mut self) {
        self.severity_level = ::std::option::Option::None;
    }

    pub fn has_severity_level(&self) -> bool {
        self.severity_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity_level(&mut self, v: alert::SeverityLevel) {
        self.severity_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "active_period",
            |m: &Alert| { &m.active_period },
            |m: &mut Alert| { &mut m.active_period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "informed_entity",
            |m: &Alert| { &m.informed_entity },
            |m: &mut Alert| { &mut m.informed_entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cause",
            |m: &Alert| { &m.cause },
            |m: &mut Alert| { &mut m.cause },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &Alert| { &m.effect },
            |m: &mut Alert| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "url",
            |m: &Alert| { &m.url },
            |m: &mut Alert| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "header_text",
            |m: &Alert| { &m.header_text },
            |m: &mut Alert| { &mut m.header_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "description_text",
            |m: &Alert| { &m.description_text },
            |m: &mut Alert| { &mut m.description_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "tts_header_text",
            |m: &Alert| { &m.tts_header_text },
            |m: &mut Alert| { &mut m.tts_header_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "tts_description_text",
            |m: &Alert| { &m.tts_description_text },
            |m: &mut Alert| { &mut m.tts_description_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "severity_level",
            |m: &Alert| { &m.severity_level },
            |m: &mut Alert| { &mut m.severity_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedImage>(
            "image",
            |m: &Alert| { &m.image },
            |m: &mut Alert| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "image_alternative_text",
            |m: &Alert| { &m.image_alternative_text },
            |m: &mut Alert| { &mut m.image_alternative_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "cause_detail",
            |m: &Alert| { &m.cause_detail },
            |m: &mut Alert| { &mut m.cause_detail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TranslatedString>(
            "effect_detail",
            |m: &Alert| { &m.effect_detail },
            |m: &mut Alert| { &mut m.effect_detail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Alert>(
            "Alert",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Alert {
    const NAME: &'static str = "Alert";

    fn is_initialized(&self) -> bool {
        for v in &self.active_period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.informed_entity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.header_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.description_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tts_header_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tts_description_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_alternative_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cause_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.effect_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.active_period.push(is.read_message()?);
                },
                42 => {
                    self.informed_entity.push(is.read_message()?);
                },
                48 => {
                    self.cause = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.effect = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.url)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header_text)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.description_text)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tts_header_text)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tts_description_text)?;
                },
                112 => {
                    self.severity_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image_alternative_text)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cause_detail)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.effect_detail)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.active_period {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.informed_entity {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cause {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.header_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.description_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tts_header_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tts_description_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.severity_level {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image_alternative_text.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cause_detail.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.effect_detail.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.active_period {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.informed_entity {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.cause {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.effect {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.url.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.header_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.description_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.tts_header_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.tts_description_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.severity_level {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.image_alternative_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.cause_detail.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.effect_detail.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Alert {
        Alert::new()
    }

    fn clear(&mut self) {
        self.active_period.clear();
        self.informed_entity.clear();
        self.cause = ::std::option::Option::None;
        self.effect = ::std::option::Option::None;
        self.url.clear();
        self.header_text.clear();
        self.description_text.clear();
        self.tts_header_text.clear();
        self.tts_description_text.clear();
        self.severity_level = ::std::option::Option::None;
        self.image.clear();
        self.image_alternative_text.clear();
        self.cause_detail.clear();
        self.effect_detail.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Alert {
        static instance: Alert = Alert {
            active_period: ::std::vec::Vec::new(),
            informed_entity: ::std::vec::Vec::new(),
            cause: ::std::option::Option::None,
            effect: ::std::option::Option::None,
            url: ::protobuf::MessageField::none(),
            header_text: ::protobuf::MessageField::none(),
            description_text: ::protobuf::MessageField::none(),
            tts_header_text: ::protobuf::MessageField::none(),
            tts_description_text: ::protobuf::MessageField::none(),
            severity_level: ::std::option::Option::None,
            image: ::protobuf::MessageField::none(),
            image_alternative_text: ::protobuf::MessageField::none(),
            cause_detail: ::protobuf::MessageField::none(),
            effect_detail: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Alert {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Alert").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Alert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Alert {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Alert`
pub mod alert {
    ///  Cause of this alert. If cause_detail is included, then Cause must also be included.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.Alert.Cause)
    pub enum Cause {
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.UNKNOWN_CAUSE)
        UNKNOWN_CAUSE = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.OTHER_CAUSE)
        OTHER_CAUSE = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.TECHNICAL_PROBLEM)
        TECHNICAL_PROBLEM = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.STRIKE)
        STRIKE = 4,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.DEMONSTRATION)
        DEMONSTRATION = 5,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.ACCIDENT)
        ACCIDENT = 6,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.HOLIDAY)
        HOLIDAY = 7,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.WEATHER)
        WEATHER = 8,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.MAINTENANCE)
        MAINTENANCE = 9,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.CONSTRUCTION)
        CONSTRUCTION = 10,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.POLICE_ACTIVITY)
        POLICE_ACTIVITY = 11,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Cause.MEDICAL_EMERGENCY)
        MEDICAL_EMERGENCY = 12,
    }

    impl ::protobuf::Enum for Cause {
        const NAME: &'static str = "Cause";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Cause> {
            match value {
                1 => ::std::option::Option::Some(Cause::UNKNOWN_CAUSE),
                2 => ::std::option::Option::Some(Cause::OTHER_CAUSE),
                3 => ::std::option::Option::Some(Cause::TECHNICAL_PROBLEM),
                4 => ::std::option::Option::Some(Cause::STRIKE),
                5 => ::std::option::Option::Some(Cause::DEMONSTRATION),
                6 => ::std::option::Option::Some(Cause::ACCIDENT),
                7 => ::std::option::Option::Some(Cause::HOLIDAY),
                8 => ::std::option::Option::Some(Cause::WEATHER),
                9 => ::std::option::Option::Some(Cause::MAINTENANCE),
                10 => ::std::option::Option::Some(Cause::CONSTRUCTION),
                11 => ::std::option::Option::Some(Cause::POLICE_ACTIVITY),
                12 => ::std::option::Option::Some(Cause::MEDICAL_EMERGENCY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Cause] = &[
            Cause::UNKNOWN_CAUSE,
            Cause::OTHER_CAUSE,
            Cause::TECHNICAL_PROBLEM,
            Cause::STRIKE,
            Cause::DEMONSTRATION,
            Cause::ACCIDENT,
            Cause::HOLIDAY,
            Cause::WEATHER,
            Cause::MAINTENANCE,
            Cause::CONSTRUCTION,
            Cause::POLICE_ACTIVITY,
            Cause::MEDICAL_EMERGENCY,
        ];
    }

    impl ::protobuf::EnumFull for Cause {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Alert.Cause").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Cause::UNKNOWN_CAUSE => 0,
                Cause::OTHER_CAUSE => 1,
                Cause::TECHNICAL_PROBLEM => 2,
                Cause::STRIKE => 3,
                Cause::DEMONSTRATION => 4,
                Cause::ACCIDENT => 5,
                Cause::HOLIDAY => 6,
                Cause::WEATHER => 7,
                Cause::MAINTENANCE => 8,
                Cause::CONSTRUCTION => 9,
                Cause::POLICE_ACTIVITY => 10,
                Cause::MEDICAL_EMERGENCY => 11,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Cause {
        fn default() -> Self {
            Cause::UNKNOWN_CAUSE
        }
    }

    impl Cause {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Cause>("Alert.Cause")
        }
    }

    ///  What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.Alert.Effect)
    pub enum Effect {
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.NO_SERVICE)
        NO_SERVICE = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.REDUCED_SERVICE)
        REDUCED_SERVICE = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.SIGNIFICANT_DELAYS)
        SIGNIFICANT_DELAYS = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.DETOUR)
        DETOUR = 4,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.ADDITIONAL_SERVICE)
        ADDITIONAL_SERVICE = 5,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.MODIFIED_SERVICE)
        MODIFIED_SERVICE = 6,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.OTHER_EFFECT)
        OTHER_EFFECT = 7,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.UNKNOWN_EFFECT)
        UNKNOWN_EFFECT = 8,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.STOP_MOVED)
        STOP_MOVED = 9,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.NO_EFFECT)
        NO_EFFECT = 10,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.Effect.ACCESSIBILITY_ISSUE)
        ACCESSIBILITY_ISSUE = 11,
    }

    impl ::protobuf::Enum for Effect {
        const NAME: &'static str = "Effect";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Effect> {
            match value {
                1 => ::std::option::Option::Some(Effect::NO_SERVICE),
                2 => ::std::option::Option::Some(Effect::REDUCED_SERVICE),
                3 => ::std::option::Option::Some(Effect::SIGNIFICANT_DELAYS),
                4 => ::std::option::Option::Some(Effect::DETOUR),
                5 => ::std::option::Option::Some(Effect::ADDITIONAL_SERVICE),
                6 => ::std::option::Option::Some(Effect::MODIFIED_SERVICE),
                7 => ::std::option::Option::Some(Effect::OTHER_EFFECT),
                8 => ::std::option::Option::Some(Effect::UNKNOWN_EFFECT),
                9 => ::std::option::Option::Some(Effect::STOP_MOVED),
                10 => ::std::option::Option::Some(Effect::NO_EFFECT),
                11 => ::std::option::Option::Some(Effect::ACCESSIBILITY_ISSUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Effect] = &[
            Effect::NO_SERVICE,
            Effect::REDUCED_SERVICE,
            Effect::SIGNIFICANT_DELAYS,
            Effect::DETOUR,
            Effect::ADDITIONAL_SERVICE,
            Effect::MODIFIED_SERVICE,
            Effect::OTHER_EFFECT,
            Effect::UNKNOWN_EFFECT,
            Effect::STOP_MOVED,
            Effect::NO_EFFECT,
            Effect::ACCESSIBILITY_ISSUE,
        ];
    }

    impl ::protobuf::EnumFull for Effect {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Alert.Effect").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Effect::NO_SERVICE => 0,
                Effect::REDUCED_SERVICE => 1,
                Effect::SIGNIFICANT_DELAYS => 2,
                Effect::DETOUR => 3,
                Effect::ADDITIONAL_SERVICE => 4,
                Effect::MODIFIED_SERVICE => 5,
                Effect::OTHER_EFFECT => 6,
                Effect::UNKNOWN_EFFECT => 7,
                Effect::STOP_MOVED => 8,
                Effect::NO_EFFECT => 9,
                Effect::ACCESSIBILITY_ISSUE => 10,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Effect {
        fn default() -> Self {
            Effect::NO_SERVICE
        }
    }

    impl Effect {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Effect>("Alert.Effect")
        }
    }

    ///  Severity of this alert.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.Alert.SeverityLevel)
    pub enum SeverityLevel {
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.SeverityLevel.UNKNOWN_SEVERITY)
        UNKNOWN_SEVERITY = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.SeverityLevel.INFO)
        INFO = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.SeverityLevel.WARNING)
        WARNING = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.Alert.SeverityLevel.SEVERE)
        SEVERE = 4,
    }

    impl ::protobuf::Enum for SeverityLevel {
        const NAME: &'static str = "SeverityLevel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SeverityLevel> {
            match value {
                1 => ::std::option::Option::Some(SeverityLevel::UNKNOWN_SEVERITY),
                2 => ::std::option::Option::Some(SeverityLevel::INFO),
                3 => ::std::option::Option::Some(SeverityLevel::WARNING),
                4 => ::std::option::Option::Some(SeverityLevel::SEVERE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SeverityLevel] = &[
            SeverityLevel::UNKNOWN_SEVERITY,
            SeverityLevel::INFO,
            SeverityLevel::WARNING,
            SeverityLevel::SEVERE,
        ];
    }

    impl ::protobuf::EnumFull for SeverityLevel {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Alert.SeverityLevel").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                SeverityLevel::UNKNOWN_SEVERITY => 0,
                SeverityLevel::INFO => 1,
                SeverityLevel::WARNING => 2,
                SeverityLevel::SEVERE => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for SeverityLevel {
        fn default() -> Self {
            SeverityLevel::UNKNOWN_SEVERITY
        }
    }

    impl SeverityLevel {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SeverityLevel>("Alert.SeverityLevel")
        }
    }
}

///  A time interval. The interval is considered active at time 't' if 't' is
///  greater than or equal to the start time and less than the end time.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.TimeRange)
pub struct TimeRange {
    // message fields
    ///  Start time, in POSIX time (i.e., number of seconds since January 1st 1970
    ///  00:00:00 UTC).
    ///  If missing, the interval starts at minus infinity.
    // @@protoc_insertion_point(field:transit_realtime.TimeRange.start)
    pub start: ::std::option::Option<u64>,
    ///  End time, in POSIX time (i.e., number of seconds since January 1st 1970
    ///  00:00:00 UTC).
    ///  If missing, the interval ends at plus infinity.
    // @@protoc_insertion_point(field:transit_realtime.TimeRange.end)
    pub end: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TimeRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeRange {
    fn default() -> &'a TimeRange {
        <TimeRange as ::protobuf::Message>::default_instance()
    }
}

impl TimeRange {
    pub fn new() -> TimeRange {
        ::std::default::Default::default()
    }

    // optional uint64 start = 1;

    pub fn start(&self) -> u64 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional uint64 end = 2;

    pub fn end(&self) -> u64 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u64) {
        self.end = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &TimeRange| { &m.start },
            |m: &mut TimeRange| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end",
            |m: &TimeRange| { &m.end },
            |m: &mut TimeRange| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeRange>(
            "TimeRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeRange {
    const NAME: &'static str = "TimeRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.end = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.end {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeRange {
        TimeRange::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeRange {
        static instance: TimeRange = TimeRange {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A position.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.Position)
pub struct Position {
    // message fields
    ///  Degrees North, in the WGS-84 coordinate system.
    // @@protoc_insertion_point(field:transit_realtime.Position.latitude)
    pub latitude: ::std::option::Option<f32>,
    ///  Degrees East, in the WGS-84 coordinate system.
    // @@protoc_insertion_point(field:transit_realtime.Position.longitude)
    pub longitude: ::std::option::Option<f32>,
    ///  Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
    ///  This can be the compass bearing, or the direction towards the next stop
    ///  or intermediate location.
    ///  This should not be direction deduced from the sequence of previous
    ///  positions, which can be computed from previous data.
    // @@protoc_insertion_point(field:transit_realtime.Position.bearing)
    pub bearing: ::std::option::Option<f32>,
    ///  Odometer value, in meters.
    // @@protoc_insertion_point(field:transit_realtime.Position.odometer)
    pub odometer: ::std::option::Option<f64>,
    ///  Momentary speed measured by the vehicle, in meters per second.
    // @@protoc_insertion_point(field:transit_realtime.Position.speed)
    pub speed: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // required float latitude = 1;

    pub fn latitude(&self) -> f32 {
        self.latitude.unwrap_or(0.)
    }

    pub fn clear_latitude(&mut self) {
        self.latitude = ::std::option::Option::None;
    }

    pub fn has_latitude(&self) -> bool {
        self.latitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latitude(&mut self, v: f32) {
        self.latitude = ::std::option::Option::Some(v);
    }

    // required float longitude = 2;

    pub fn longitude(&self) -> f32 {
        self.longitude.unwrap_or(0.)
    }

    pub fn clear_longitude(&mut self) {
        self.longitude = ::std::option::Option::None;
    }

    pub fn has_longitude(&self) -> bool {
        self.longitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_longitude(&mut self, v: f32) {
        self.longitude = ::std::option::Option::Some(v);
    }

    // optional float bearing = 3;

    pub fn bearing(&self) -> f32 {
        self.bearing.unwrap_or(0.)
    }

    pub fn clear_bearing(&mut self) {
        self.bearing = ::std::option::Option::None;
    }

    pub fn has_bearing(&self) -> bool {
        self.bearing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bearing(&mut self, v: f32) {
        self.bearing = ::std::option::Option::Some(v);
    }

    // optional double odometer = 4;

    pub fn odometer(&self) -> f64 {
        self.odometer.unwrap_or(0.)
    }

    pub fn clear_odometer(&mut self) {
        self.odometer = ::std::option::Option::None;
    }

    pub fn has_odometer(&self) -> bool {
        self.odometer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_odometer(&mut self, v: f64) {
        self.odometer = ::std::option::Option::Some(v);
    }

    // optional float speed = 5;

    pub fn speed(&self) -> f32 {
        self.speed.unwrap_or(0.)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "latitude",
            |m: &Position| { &m.latitude },
            |m: &mut Position| { &mut m.latitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "longitude",
            |m: &Position| { &m.longitude },
            |m: &mut Position| { &mut m.longitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bearing",
            |m: &Position| { &m.bearing },
            |m: &mut Position| { &mut m.bearing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "odometer",
            |m: &Position| { &m.odometer },
            |m: &mut Position| { &mut m.odometer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speed",
            |m: &Position| { &m.speed },
            |m: &mut Position| { &mut m.speed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Position {
    const NAME: &'static str = "Position";

    fn is_initialized(&self) -> bool {
        if self.latitude.is_none() {
            return false;
        }
        if self.longitude.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.latitude = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.longitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.bearing = ::std::option::Option::Some(is.read_float()?);
                },
                33 => {
                    self.odometer = ::std::option::Option::Some(is.read_double()?);
                },
                45 => {
                    self.speed = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.latitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.longitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bearing {
            my_size += 1 + 4;
        }
        if let Some(v) = self.odometer {
            my_size += 1 + 8;
        }
        if let Some(v) = self.speed {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.latitude {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.longitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.bearing {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.odometer {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.speed {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn clear(&mut self) {
        self.latitude = ::std::option::Option::None;
        self.longitude = ::std::option::Option::None;
        self.bearing = ::std::option::Option::None;
        self.odometer = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            latitude: ::std::option::Option::None,
            longitude: ::std::option::Option::None,
            bearing: ::std::option::Option::None,
            odometer: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A descriptor that identifies an instance of a GTFS trip, or all instances of
///  a trip along a route.
///  - To specify a single trip instance, the trip_id (and if necessary,
///    start_time) is set. If route_id is also set, then it should be same as one
///    that the given trip corresponds to.
///  - To specify all the trips along a given route, only the route_id should be
///    set. Note that if the trip_id is not known, then stop sequence ids in
///    TripUpdate are not sufficient, and stop_ids must be provided as well. In
///    addition, absolute arrival/departure times must be provided.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.TripDescriptor)
pub struct TripDescriptor {
    // message fields
    ///  The trip_id from the GTFS feed that this selector refers to.
    ///  For non frequency-based trips, this field is enough to uniquely identify
    ///  the trip. For frequency-based trip, start_time and start_date might also be
    ///  necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
    ///  static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
    ///  identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.trip_id)
    pub trip_id: ::std::option::Option<::std::string::String>,
    ///  The route_id from the GTFS that this selector refers to.
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.route_id)
    pub route_id: ::std::option::Option<::std::string::String>,
    ///  The direction_id from the GTFS feed trips.txt file, indicating the
    ///  direction of travel for trips this selector refers to.
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.direction_id)
    pub direction_id: ::std::option::Option<u32>,
    ///  The initially scheduled start time of this trip instance.
    ///  When the trip_id corresponds to a non-frequency-based trip, this field
    ///  should either be omitted or be equal to the value in the GTFS feed. When
    ///  the trip_id correponds to a frequency-based trip, the start_time must be
    ///  specified for trip updates and vehicle positions. If the trip corresponds
    ///  to exact_times=1 GTFS record, then start_time must be some multiple
    ///  (including zero) of headway_secs later than frequencies.txt start_time for
    ///  the corresponding time period. If the trip corresponds to exact_times=0,
    ///  then its start_time may be arbitrary, and is initially expected to be the
    ///  first departure of the trip. Once established, the start_time of this
    ///  frequency-based trip should be considered immutable, even if the first
    ///  departure time changes -- that time change may instead be reflected in a
    ///  StopTimeUpdate.
    ///  Format and semantics of the field is same as that of
    ///  GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.start_time)
    pub start_time: ::std::option::Option<::std::string::String>,
    ///  The scheduled start date of this trip instance.
    ///  Must be provided to disambiguate trips that are so late as to collide with
    ///  a scheduled trip on a next day. For example, for a train that departs 8:00
    ///  and 20:00 every day, and is 12 hours late, there would be two distinct
    ///  trips on the same time.
    ///  This field can be provided but is not mandatory for schedules in which such
    ///  collisions are impossible - for example, a service running on hourly
    ///  schedule where a vehicle that is one hour late is not considered to be
    ///  related to schedule anymore.
    ///  In YYYYMMDD format.
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.start_date)
    pub start_date: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.TripDescriptor.schedule_relationship)
    pub schedule_relationship: ::std::option::Option<::protobuf::EnumOrUnknown<trip_descriptor::ScheduleRelationship>>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TripDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TripDescriptor {
    fn default() -> &'a TripDescriptor {
        <TripDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl TripDescriptor {
    pub fn new() -> TripDescriptor {
        ::std::default::Default::default()
    }

    // optional string trip_id = 1;

    pub fn trip_id(&self) -> &str {
        match self.trip_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_trip_id(&mut self) {
        self.trip_id = ::std::option::Option::None;
    }

    pub fn has_trip_id(&self) -> bool {
        self.trip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trip_id(&mut self, v: ::std::string::String) {
        self.trip_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trip_id(&mut self) -> &mut ::std::string::String {
        if self.trip_id.is_none() {
            self.trip_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.trip_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_trip_id(&mut self) -> ::std::string::String {
        self.trip_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string route_id = 5;

    pub fn route_id(&self) -> &str {
        match self.route_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_route_id(&mut self) {
        self.route_id = ::std::option::Option::None;
    }

    pub fn has_route_id(&self) -> bool {
        self.route_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_id(&mut self, v: ::std::string::String) {
        self.route_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_id(&mut self) -> &mut ::std::string::String {
        if self.route_id.is_none() {
            self.route_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.route_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_id(&mut self) -> ::std::string::String {
        self.route_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 direction_id = 6;

    pub fn direction_id(&self) -> u32 {
        self.direction_id.unwrap_or(0)
    }

    pub fn clear_direction_id(&mut self) {
        self.direction_id = ::std::option::Option::None;
    }

    pub fn has_direction_id(&self) -> bool {
        self.direction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction_id(&mut self, v: u32) {
        self.direction_id = ::std::option::Option::Some(v);
    }

    // optional string start_time = 2;

    pub fn start_time(&self) -> &str {
        match self.start_time.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::std::string::String) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::std::string::String {
        if self.start_time.is_none() {
            self.start_time = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::std::string::String {
        self.start_time.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string start_date = 3;

    pub fn start_date(&self) -> &str {
        match self.start_date.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_start_date(&mut self) {
        self.start_date = ::std::option::Option::None;
    }

    pub fn has_start_date(&self) -> bool {
        self.start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_date(&mut self, v: ::std::string::String) {
        self.start_date = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_date(&mut self) -> &mut ::std::string::String {
        if self.start_date.is_none() {
            self.start_date = ::std::option::Option::Some(::std::string::String::new());
        }
        self.start_date.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_date(&mut self) -> ::std::string::String {
        self.start_date.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;

    pub fn schedule_relationship(&self) -> trip_descriptor::ScheduleRelationship {
        match self.schedule_relationship {
            Some(e) => e.enum_value_or(trip_descriptor::ScheduleRelationship::SCHEDULED),
            None => trip_descriptor::ScheduleRelationship::SCHEDULED,
        }
    }

    pub fn clear_schedule_relationship(&mut self) {
        self.schedule_relationship = ::std::option::Option::None;
    }

    pub fn has_schedule_relationship(&self) -> bool {
        self.schedule_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule_relationship(&mut self, v: trip_descriptor::ScheduleRelationship) {
        self.schedule_relationship = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trip_id",
            |m: &TripDescriptor| { &m.trip_id },
            |m: &mut TripDescriptor| { &mut m.trip_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "route_id",
            |m: &TripDescriptor| { &m.route_id },
            |m: &mut TripDescriptor| { &mut m.route_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direction_id",
            |m: &TripDescriptor| { &m.direction_id },
            |m: &mut TripDescriptor| { &mut m.direction_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &TripDescriptor| { &m.start_time },
            |m: &mut TripDescriptor| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_date",
            |m: &TripDescriptor| { &m.start_date },
            |m: &mut TripDescriptor| { &mut m.start_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "schedule_relationship",
            |m: &TripDescriptor| { &m.schedule_relationship },
            |m: &mut TripDescriptor| { &mut m.schedule_relationship },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TripDescriptor>(
            "TripDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TripDescriptor {
    const NAME: &'static str = "TripDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trip_id = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.route_id = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.direction_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.start_time = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.start_date = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.schedule_relationship = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trip_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.route_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.direction_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.start_time.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.start_date.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.schedule_relationship {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trip_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.route_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.direction_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.start_date.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.schedule_relationship {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TripDescriptor {
        TripDescriptor::new()
    }

    fn clear(&mut self) {
        self.trip_id = ::std::option::Option::None;
        self.route_id = ::std::option::Option::None;
        self.direction_id = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.start_date = ::std::option::Option::None;
        self.schedule_relationship = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TripDescriptor {
        static instance: TripDescriptor = TripDescriptor {
            trip_id: ::std::option::Option::None,
            route_id: ::std::option::Option::None,
            direction_id: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            start_date: ::std::option::Option::None,
            schedule_relationship: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TripDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TripDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TripDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TripDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TripDescriptor`
pub mod trip_descriptor {
    ///  The relation between this trip and the static schedule. If a trip is done
    ///  in accordance with temporary schedule, not reflected in GTFS, then it
    ///  shouldn't be marked as SCHEDULED, but likely as ADDED.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.TripDescriptor.ScheduleRelationship)
    pub enum ScheduleRelationship {
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.SCHEDULED)
        SCHEDULED = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.ADDED)
        ADDED = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.UNSCHEDULED)
        UNSCHEDULED = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.CANCELED)
        CANCELED = 3,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.REPLACEMENT)
        REPLACEMENT = 5,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.DUPLICATED)
        DUPLICATED = 6,
        // @@protoc_insertion_point(enum_value:transit_realtime.TripDescriptor.ScheduleRelationship.DELETED)
        DELETED = 7,
    }

    impl ::protobuf::Enum for ScheduleRelationship {
        const NAME: &'static str = "ScheduleRelationship";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ScheduleRelationship> {
            match value {
                0 => ::std::option::Option::Some(ScheduleRelationship::SCHEDULED),
                1 => ::std::option::Option::Some(ScheduleRelationship::ADDED),
                2 => ::std::option::Option::Some(ScheduleRelationship::UNSCHEDULED),
                3 => ::std::option::Option::Some(ScheduleRelationship::CANCELED),
                5 => ::std::option::Option::Some(ScheduleRelationship::REPLACEMENT),
                6 => ::std::option::Option::Some(ScheduleRelationship::DUPLICATED),
                7 => ::std::option::Option::Some(ScheduleRelationship::DELETED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ScheduleRelationship] = &[
            ScheduleRelationship::SCHEDULED,
            ScheduleRelationship::ADDED,
            ScheduleRelationship::UNSCHEDULED,
            ScheduleRelationship::CANCELED,
            ScheduleRelationship::REPLACEMENT,
            ScheduleRelationship::DUPLICATED,
            ScheduleRelationship::DELETED,
        ];
    }

    impl ::protobuf::EnumFull for ScheduleRelationship {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TripDescriptor.ScheduleRelationship").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ScheduleRelationship::SCHEDULED => 0,
                ScheduleRelationship::ADDED => 1,
                ScheduleRelationship::UNSCHEDULED => 2,
                ScheduleRelationship::CANCELED => 3,
                ScheduleRelationship::REPLACEMENT => 4,
                ScheduleRelationship::DUPLICATED => 5,
                ScheduleRelationship::DELETED => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ScheduleRelationship {
        fn default() -> Self {
            ScheduleRelationship::SCHEDULED
        }
    }

    impl ScheduleRelationship {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ScheduleRelationship>("TripDescriptor.ScheduleRelationship")
        }
    }
}

///  Identification information for the vehicle performing the trip.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.VehicleDescriptor)
pub struct VehicleDescriptor {
    // message fields
    ///  Internal system identification of the vehicle. Should be unique per
    ///  vehicle, and can be used for tracking the vehicle as it proceeds through
    ///  the system.
    // @@protoc_insertion_point(field:transit_realtime.VehicleDescriptor.id)
    pub id: ::std::option::Option<::std::string::String>,
    ///  User visible label, i.e., something that must be shown to the passenger to
    ///  help identify the correct vehicle.
    // @@protoc_insertion_point(field:transit_realtime.VehicleDescriptor.label)
    pub label: ::std::option::Option<::std::string::String>,
    ///  The license plate of the vehicle.
    // @@protoc_insertion_point(field:transit_realtime.VehicleDescriptor.license_plate)
    pub license_plate: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.VehicleDescriptor.wheelchair_accessible)
    pub wheelchair_accessible: ::std::option::Option<::protobuf::EnumOrUnknown<vehicle_descriptor::WheelchairAccessible>>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.VehicleDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VehicleDescriptor {
    fn default() -> &'a VehicleDescriptor {
        <VehicleDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl VehicleDescriptor {
    pub fn new() -> VehicleDescriptor {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 2;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string license_plate = 3;

    pub fn license_plate(&self) -> &str {
        match self.license_plate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_license_plate(&mut self) {
        self.license_plate = ::std::option::Option::None;
    }

    pub fn has_license_plate(&self) -> bool {
        self.license_plate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_plate(&mut self, v: ::std::string::String) {
        self.license_plate = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license_plate(&mut self) -> &mut ::std::string::String {
        if self.license_plate.is_none() {
            self.license_plate = ::std::option::Option::Some(::std::string::String::new());
        }
        self.license_plate.as_mut().unwrap()
    }

    // Take field
    pub fn take_license_plate(&mut self) -> ::std::string::String {
        self.license_plate.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4;

    pub fn wheelchair_accessible(&self) -> vehicle_descriptor::WheelchairAccessible {
        match self.wheelchair_accessible {
            Some(e) => e.enum_value_or(vehicle_descriptor::WheelchairAccessible::NO_VALUE),
            None => vehicle_descriptor::WheelchairAccessible::NO_VALUE,
        }
    }

    pub fn clear_wheelchair_accessible(&mut self) {
        self.wheelchair_accessible = ::std::option::Option::None;
    }

    pub fn has_wheelchair_accessible(&self) -> bool {
        self.wheelchair_accessible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wheelchair_accessible(&mut self, v: vehicle_descriptor::WheelchairAccessible) {
        self.wheelchair_accessible = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &VehicleDescriptor| { &m.id },
            |m: &mut VehicleDescriptor| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &VehicleDescriptor| { &m.label },
            |m: &mut VehicleDescriptor| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "license_plate",
            |m: &VehicleDescriptor| { &m.license_plate },
            |m: &mut VehicleDescriptor| { &mut m.license_plate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wheelchair_accessible",
            |m: &VehicleDescriptor| { &m.wheelchair_accessible },
            |m: &mut VehicleDescriptor| { &mut m.wheelchair_accessible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VehicleDescriptor>(
            "VehicleDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VehicleDescriptor {
    const NAME: &'static str = "VehicleDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.license_plate = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.wheelchair_accessible = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.license_plate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.wheelchair_accessible {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.license_plate.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.wheelchair_accessible {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VehicleDescriptor {
        VehicleDescriptor::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.license_plate = ::std::option::Option::None;
        self.wheelchair_accessible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VehicleDescriptor {
        static instance: VehicleDescriptor = VehicleDescriptor {
            id: ::std::option::Option::None,
            label: ::std::option::Option::None,
            license_plate: ::std::option::Option::None,
            wheelchair_accessible: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VehicleDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VehicleDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VehicleDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VehicleDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VehicleDescriptor`
pub mod vehicle_descriptor {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:transit_realtime.VehicleDescriptor.WheelchairAccessible)
    pub enum WheelchairAccessible {
        // @@protoc_insertion_point(enum_value:transit_realtime.VehicleDescriptor.WheelchairAccessible.NO_VALUE)
        NO_VALUE = 0,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehicleDescriptor.WheelchairAccessible.UNKNOWN)
        UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehicleDescriptor.WheelchairAccessible.WHEELCHAIR_ACCESSIBLE)
        WHEELCHAIR_ACCESSIBLE = 2,
        // @@protoc_insertion_point(enum_value:transit_realtime.VehicleDescriptor.WheelchairAccessible.WHEELCHAIR_INACCESSIBLE)
        WHEELCHAIR_INACCESSIBLE = 3,
    }

    impl ::protobuf::Enum for WheelchairAccessible {
        const NAME: &'static str = "WheelchairAccessible";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WheelchairAccessible> {
            match value {
                0 => ::std::option::Option::Some(WheelchairAccessible::NO_VALUE),
                1 => ::std::option::Option::Some(WheelchairAccessible::UNKNOWN),
                2 => ::std::option::Option::Some(WheelchairAccessible::WHEELCHAIR_ACCESSIBLE),
                3 => ::std::option::Option::Some(WheelchairAccessible::WHEELCHAIR_INACCESSIBLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WheelchairAccessible] = &[
            WheelchairAccessible::NO_VALUE,
            WheelchairAccessible::UNKNOWN,
            WheelchairAccessible::WHEELCHAIR_ACCESSIBLE,
            WheelchairAccessible::WHEELCHAIR_INACCESSIBLE,
        ];
    }

    impl ::protobuf::EnumFull for WheelchairAccessible {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VehicleDescriptor.WheelchairAccessible").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WheelchairAccessible {
        fn default() -> Self {
            WheelchairAccessible::NO_VALUE
        }
    }

    impl WheelchairAccessible {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WheelchairAccessible>("VehicleDescriptor.WheelchairAccessible")
        }
    }
}

///  A selector for an entity in a GTFS feed.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.EntitySelector)
pub struct EntitySelector {
    // message fields
    ///  The values of the fields should correspond to the appropriate fields in the
    ///  GTFS feed.
    ///  At least one specifier must be given. If several are given, then the
    ///  matching has to apply to all the given specifiers.
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.agency_id)
    pub agency_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.route_id)
    pub route_id: ::std::option::Option<::std::string::String>,
    ///  corresponds to route_type in GTFS.
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.route_type)
    pub route_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.trip)
    pub trip: ::protobuf::MessageField<TripDescriptor>,
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.stop_id)
    pub stop_id: ::std::option::Option<::std::string::String>,
    ///  Corresponds to trip direction_id in GTFS trips.txt. If provided the
    ///  route_id must also be provided.
    // @@protoc_insertion_point(field:transit_realtime.EntitySelector.direction_id)
    pub direction_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.EntitySelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntitySelector {
    fn default() -> &'a EntitySelector {
        <EntitySelector as ::protobuf::Message>::default_instance()
    }
}

impl EntitySelector {
    pub fn new() -> EntitySelector {
        ::std::default::Default::default()
    }

    // optional string agency_id = 1;

    pub fn agency_id(&self) -> &str {
        match self.agency_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_agency_id(&mut self) {
        self.agency_id = ::std::option::Option::None;
    }

    pub fn has_agency_id(&self) -> bool {
        self.agency_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agency_id(&mut self, v: ::std::string::String) {
        self.agency_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agency_id(&mut self) -> &mut ::std::string::String {
        if self.agency_id.is_none() {
            self.agency_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.agency_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agency_id(&mut self) -> ::std::string::String {
        self.agency_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string route_id = 2;

    pub fn route_id(&self) -> &str {
        match self.route_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_route_id(&mut self) {
        self.route_id = ::std::option::Option::None;
    }

    pub fn has_route_id(&self) -> bool {
        self.route_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_id(&mut self, v: ::std::string::String) {
        self.route_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_id(&mut self) -> &mut ::std::string::String {
        if self.route_id.is_none() {
            self.route_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.route_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_id(&mut self) -> ::std::string::String {
        self.route_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 route_type = 3;

    pub fn route_type(&self) -> i32 {
        self.route_type.unwrap_or(0)
    }

    pub fn clear_route_type(&mut self) {
        self.route_type = ::std::option::Option::None;
    }

    pub fn has_route_type(&self) -> bool {
        self.route_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_type(&mut self, v: i32) {
        self.route_type = ::std::option::Option::Some(v);
    }

    // optional string stop_id = 5;

    pub fn stop_id(&self) -> &str {
        match self.stop_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stop_id(&mut self) {
        self.stop_id = ::std::option::Option::None;
    }

    pub fn has_stop_id(&self) -> bool {
        self.stop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop_id(&mut self, v: ::std::string::String) {
        self.stop_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stop_id(&mut self) -> &mut ::std::string::String {
        if self.stop_id.is_none() {
            self.stop_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stop_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stop_id(&mut self) -> ::std::string::String {
        self.stop_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 direction_id = 6;

    pub fn direction_id(&self) -> u32 {
        self.direction_id.unwrap_or(0)
    }

    pub fn clear_direction_id(&mut self) {
        self.direction_id = ::std::option::Option::None;
    }

    pub fn has_direction_id(&self) -> bool {
        self.direction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction_id(&mut self, v: u32) {
        self.direction_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "agency_id",
            |m: &EntitySelector| { &m.agency_id },
            |m: &mut EntitySelector| { &mut m.agency_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "route_id",
            |m: &EntitySelector| { &m.route_id },
            |m: &mut EntitySelector| { &mut m.route_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "route_type",
            |m: &EntitySelector| { &m.route_type },
            |m: &mut EntitySelector| { &mut m.route_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TripDescriptor>(
            "trip",
            |m: &EntitySelector| { &m.trip },
            |m: &mut EntitySelector| { &mut m.trip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop_id",
            |m: &EntitySelector| { &m.stop_id },
            |m: &mut EntitySelector| { &mut m.stop_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direction_id",
            |m: &EntitySelector| { &m.direction_id },
            |m: &mut EntitySelector| { &mut m.direction_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntitySelector>(
            "EntitySelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntitySelector {
    const NAME: &'static str = "EntitySelector";

    fn is_initialized(&self) -> bool {
        for v in &self.trip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.agency_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.route_id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.route_type = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trip)?;
                },
                42 => {
                    self.stop_id = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.direction_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.agency_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.route_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.route_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.trip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stop_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.direction_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.agency_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.route_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.route_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.trip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.stop_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.direction_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntitySelector {
        EntitySelector::new()
    }

    fn clear(&mut self) {
        self.agency_id = ::std::option::Option::None;
        self.route_id = ::std::option::Option::None;
        self.route_type = ::std::option::Option::None;
        self.trip.clear();
        self.stop_id = ::std::option::Option::None;
        self.direction_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntitySelector {
        static instance: EntitySelector = EntitySelector {
            agency_id: ::std::option::Option::None,
            route_id: ::std::option::Option::None,
            route_type: ::std::option::Option::None,
            trip: ::protobuf::MessageField::none(),
            stop_id: ::std::option::Option::None,
            direction_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EntitySelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntitySelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntitySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntitySelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.TranslatedString)
pub struct TranslatedString {
    // message fields
    ///  At least one translation must be provided.
    // @@protoc_insertion_point(field:transit_realtime.TranslatedString.translation)
    pub translation: ::std::vec::Vec<translated_string::Translation>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TranslatedString.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TranslatedString {
    fn default() -> &'a TranslatedString {
        <TranslatedString as ::protobuf::Message>::default_instance()
    }
}

impl TranslatedString {
    pub fn new() -> TranslatedString {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "translation",
            |m: &TranslatedString| { &m.translation },
            |m: &mut TranslatedString| { &mut m.translation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TranslatedString>(
            "TranslatedString",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TranslatedString {
    const NAME: &'static str = "TranslatedString";

    fn is_initialized(&self) -> bool {
        for v in &self.translation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.translation.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.translation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.translation {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TranslatedString {
        TranslatedString::new()
    }

    fn clear(&mut self) {
        self.translation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TranslatedString {
        static instance: TranslatedString = TranslatedString {
            translation: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TranslatedString {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TranslatedString").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TranslatedString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslatedString {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TranslatedString`
pub mod translated_string {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:transit_realtime.TranslatedString.Translation)
    pub struct Translation {
        // message fields
        ///  A UTF-8 string containing the message.
        // @@protoc_insertion_point(field:transit_realtime.TranslatedString.Translation.text)
        pub text: ::std::option::Option<::std::string::String>,
        ///  BCP-47 language code. Can be omitted if the language is unknown or if
        ///  no i18n is done at all for the feed. At most one translation is
        ///  allowed to have an unspecified language tag.
        // @@protoc_insertion_point(field:transit_realtime.TranslatedString.Translation.language)
        pub language: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TranslatedString.Translation.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Translation {
        fn default() -> &'a Translation {
            <Translation as ::protobuf::Message>::default_instance()
        }
    }

    impl Translation {
        pub fn new() -> Translation {
            ::std::default::Default::default()
        }

        // required string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string language = 2;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "text",
                |m: &Translation| { &m.text },
                |m: &mut Translation| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &Translation| { &m.language },
                |m: &mut Translation| { &mut m.language },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Translation>(
                "TranslatedString.Translation",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Translation {
        const NAME: &'static str = "Translation";

        fn is_initialized(&self) -> bool {
            if self.text.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.language.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.language.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Translation {
            Translation::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.language = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Translation {
            static instance: Translation = Translation {
                text: ::std::option::Option::None,
                language: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Translation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TranslatedString.Translation").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Translation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Translation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.TranslatedImage)
pub struct TranslatedImage {
    // message fields
    ///  At least one localized image must be provided.
    // @@protoc_insertion_point(field:transit_realtime.TranslatedImage.localized_image)
    pub localized_image: ::std::vec::Vec<translated_image::LocalizedImage>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.TranslatedImage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TranslatedImage {
    fn default() -> &'a TranslatedImage {
        <TranslatedImage as ::protobuf::Message>::default_instance()
    }
}

impl TranslatedImage {
    pub fn new() -> TranslatedImage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "localized_image",
            |m: &TranslatedImage| { &m.localized_image },
            |m: &mut TranslatedImage| { &mut m.localized_image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TranslatedImage>(
            "TranslatedImage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TranslatedImage {
    const NAME: &'static str = "TranslatedImage";

    fn is_initialized(&self) -> bool {
        for v in &self.localized_image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.localized_image.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.localized_image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.localized_image {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TranslatedImage {
        TranslatedImage::new()
    }

    fn clear(&mut self) {
        self.localized_image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TranslatedImage {
        static instance: TranslatedImage = TranslatedImage {
            localized_image: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TranslatedImage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TranslatedImage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TranslatedImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslatedImage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TranslatedImage`
pub mod translated_image {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:transit_realtime.TranslatedImage.LocalizedImage)
    pub struct LocalizedImage {
        // message fields
        ///  String containing an URL linking to an image
        ///  The image linked must be less than 2MB. 
        ///  If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
        ///  The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the followinghttp://www.w3.org/Addressing/URL/4_URI_Recommentations.htmlfor a description of how to create fully qualified URL values.
        // @@protoc_insertion_point(field:transit_realtime.TranslatedImage.LocalizedImage.url)
        pub url: ::std::option::Option<::std::string::String>,
        ///  IANA media type as to specify the type of image to be displayed. 
        ///  The type must start with "image/"
        // @@protoc_insertion_point(field:transit_realtime.TranslatedImage.LocalizedImage.media_type)
        pub media_type: ::std::option::Option<::std::string::String>,
        ///  BCP-47 language code. Can be omitted if the language is unknown or if
        ///  no i18n is done at all for the feed. At most one translation is
        ///  allowed to have an unspecified language tag.
        // @@protoc_insertion_point(field:transit_realtime.TranslatedImage.LocalizedImage.language)
        pub language: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:transit_realtime.TranslatedImage.LocalizedImage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LocalizedImage {
        fn default() -> &'a LocalizedImage {
            <LocalizedImage as ::protobuf::Message>::default_instance()
        }
    }

    impl LocalizedImage {
        pub fn new() -> LocalizedImage {
            ::std::default::Default::default()
        }

        // required string url = 1;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string media_type = 2;

        pub fn media_type(&self) -> &str {
            match self.media_type.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_media_type(&mut self) {
            self.media_type = ::std::option::Option::None;
        }

        pub fn has_media_type(&self) -> bool {
            self.media_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_media_type(&mut self, v: ::std::string::String) {
            self.media_type = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_media_type(&mut self) -> &mut ::std::string::String {
            if self.media_type.is_none() {
                self.media_type = ::std::option::Option::Some(::std::string::String::new());
            }
            self.media_type.as_mut().unwrap()
        }

        // Take field
        pub fn take_media_type(&mut self) -> ::std::string::String {
            self.media_type.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string language = 3;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &LocalizedImage| { &m.url },
                |m: &mut LocalizedImage| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "media_type",
                |m: &LocalizedImage| { &m.media_type },
                |m: &mut LocalizedImage| { &mut m.media_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &LocalizedImage| { &m.language },
                |m: &mut LocalizedImage| { &mut m.language },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocalizedImage>(
                "TranslatedImage.LocalizedImage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LocalizedImage {
        const NAME: &'static str = "LocalizedImage";

        fn is_initialized(&self) -> bool {
            if self.url.is_none() {
                return false;
            }
            if self.media_type.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.media_type = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.media_type.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.language.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.url.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.media_type.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.language.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LocalizedImage {
            LocalizedImage::new()
        }

        fn clear(&mut self) {
            self.url = ::std::option::Option::None;
            self.media_type = ::std::option::Option::None;
            self.language = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LocalizedImage {
            static instance: LocalizedImage = LocalizedImage {
                url: ::std::option::Option::None,
                media_type: ::std::option::Option::None,
                language: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LocalizedImage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TranslatedImage.LocalizedImage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LocalizedImage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LocalizedImage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
///  such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
///  Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
///  the location of Stops exactly, but all Stops on a trip should lie within a small distance of
///  the shape for that trip, i.e. close to straight line segments connecting the shape points
///  NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:transit_realtime.Shape)
pub struct Shape {
    // message fields
    ///  Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
    ///  This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
    ///  See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
    ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.Shape.shape_id)
    pub shape_id: ::std::option::Option<::std::string::String>,
    ///  Encoded polyline representation of the shape. This polyline must contain at least two points.
    ///  For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
    ///  This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
    ///  See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
    ///  NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    // @@protoc_insertion_point(field:transit_realtime.Shape.encoded_polyline)
    pub encoded_polyline: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:transit_realtime.Shape.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Shape {
    fn default() -> &'a Shape {
        <Shape as ::protobuf::Message>::default_instance()
    }
}

impl Shape {
    pub fn new() -> Shape {
        ::std::default::Default::default()
    }

    // optional string shape_id = 1;

    pub fn shape_id(&self) -> &str {
        match self.shape_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shape_id(&mut self) {
        self.shape_id = ::std::option::Option::None;
    }

    pub fn has_shape_id(&self) -> bool {
        self.shape_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape_id(&mut self, v: ::std::string::String) {
        self.shape_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape_id(&mut self) -> &mut ::std::string::String {
        if self.shape_id.is_none() {
            self.shape_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shape_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape_id(&mut self) -> ::std::string::String {
        self.shape_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string encoded_polyline = 2;

    pub fn encoded_polyline(&self) -> &str {
        match self.encoded_polyline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encoded_polyline(&mut self) {
        self.encoded_polyline = ::std::option::Option::None;
    }

    pub fn has_encoded_polyline(&self) -> bool {
        self.encoded_polyline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoded_polyline(&mut self, v: ::std::string::String) {
        self.encoded_polyline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_polyline(&mut self) -> &mut ::std::string::String {
        if self.encoded_polyline.is_none() {
            self.encoded_polyline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.encoded_polyline.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoded_polyline(&mut self) -> ::std::string::String {
        self.encoded_polyline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shape_id",
            |m: &Shape| { &m.shape_id },
            |m: &mut Shape| { &mut m.shape_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encoded_polyline",
            |m: &Shape| { &m.encoded_polyline },
            |m: &mut Shape| { &mut m.encoded_polyline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Shape>(
            "Shape",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Shape {
    const NAME: &'static str = "Shape";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shape_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.encoded_polyline = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shape_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.encoded_polyline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shape_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.encoded_polyline.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Shape {
        Shape::new()
    }

    fn clear(&mut self) {
        self.shape_id = ::std::option::Option::None;
        self.encoded_polyline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Shape {
        static instance: Shape = Shape {
            shape_id: ::std::option::Option::None,
            encoded_polyline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Shape {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Shape").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Shape {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Shape {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13gtfs-realtime.proto\x12\x10transit_realtime\"\x89\x01\n\x0bFeedMes\
    sage\x124\n\x06header\x18\x01\x20\x02(\x0b2\x1c.transit_realtime.FeedHea\
    derR\x06header\x124\n\x06entity\x18\x02\x20\x03(\x0b2\x1c.transit_realti\
    me.FeedEntityR\x06entity*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\
    \x90N\"\x87\x02\n\nFeedHeader\x122\n\x15gtfs_realtime_version\x18\x01\
    \x20\x02(\tR\x13gtfsRealtimeVersion\x12a\n\x0eincrementality\x18\x02\x20\
    \x01(\x0e2+.transit_realtime.FeedHeader.Incrementality:\x0cFULL_DATASETR\
    \x0eincrementality\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x04R\ttimestamp\
    \"4\n\x0eIncrementality\x12\x10\n\x0cFULL_DATASET\x10\0\x12\x10\n\x0cDIF\
    FERENTIAL\x10\x01*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\
    \xac\x02\n\nFeedEntity\x12\x0e\n\x02id\x18\x01\x20\x02(\tR\x02id\x12$\n\
    \nis_deleted\x18\x02\x20\x01(\x08:\x05falseR\tisDeleted\x12=\n\x0btrip_u\
    pdate\x18\x03\x20\x01(\x0b2\x1c.transit_realtime.TripUpdateR\ntripUpdate\
    \x12;\n\x07vehicle\x18\x04\x20\x01(\x0b2!.transit_realtime.VehiclePositi\
    onR\x07vehicle\x12-\n\x05alert\x18\x05\x20\x01(\x0b2\x17.transit_realtim\
    e.AlertR\x05alert\x12-\n\x05shape\x18\x06\x20\x01(\x0b2\x17.transit_real\
    time.ShapeR\x05shape*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\
    \"\xed\n\n\nTripUpdate\x124\n\x04trip\x18\x01\x20\x02(\x0b2\x20.transit_\
    realtime.TripDescriptorR\x04trip\x12=\n\x07vehicle\x18\x03\x20\x01(\x0b2\
    #.transit_realtime.VehicleDescriptorR\x07vehicle\x12U\n\x10stop_time_upd\
    ate\x18\x02\x20\x03(\x0b2+.transit_realtime.TripUpdate.StopTimeUpdateR\
    \x0estopTimeUpdate\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\x04R\ttimestamp\
    \x12\x14\n\x05delay\x18\x05\x20\x01(\x05R\x05delay\x12T\n\x0ftrip_proper\
    ties\x18\x06\x20\x01(\x0b2+.transit_realtime.TripUpdate.TripPropertiesR\
    \x0etripProperties\x1ak\n\rStopTimeEvent\x12\x14\n\x05delay\x18\x01\x20\
    \x01(\x05R\x05delay\x12\x12\n\x04time\x18\x02\x20\x01(\x03R\x04time\x12\
    \x20\n\x0buncertainty\x18\x03\x20\x01(\x05R\x0buncertainty*\x06\x08\xe8\
    \x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\x1a\xf6\x05\n\x0eStopTimeUpdate\
    \x12#\n\rstop_sequence\x18\x01\x20\x01(\rR\x0cstopSequence\x12\x17\n\x07\
    stop_id\x18\x04\x20\x01(\tR\x06stopId\x12D\n\x07arrival\x18\x02\x20\x01(\
    \x0b2*.transit_realtime.TripUpdate.StopTimeEventR\x07arrival\x12H\n\tdep\
    arture\x18\x03\x20\x01(\x0b2*.transit_realtime.TripUpdate.StopTimeEventR\
    \tdeparture\x12o\n\x1adeparture_occupancy_status\x18\x07\x20\x01(\x0e21.\
    transit_realtime.VehiclePosition.OccupancyStatusR\x18departureOccupancyS\
    tatus\x12\x80\x01\n\x15schedule_relationship\x18\x05\x20\x01(\x0e2@.tran\
    sit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship:\tSCHEDULEDR\
    \x14scheduleRelationship\x12p\n\x14stop_time_properties\x18\x06\x20\x01(\
    \x0b2>.transit_realtime.TripUpdate.StopTimeUpdate.StopTimePropertiesR\
    \x12stopTimeProperties\x1aN\n\x12StopTimeProperties\x12(\n\x10assigned_s\
    top_id\x18\x01\x20\x01(\tR\x0eassignedStopId*\x06\x08\xe8\x07\x10\xd0\
    \x0f*\x06\x08\xa8F\x10\x90N\"P\n\x14ScheduleRelationship\x12\r\n\tSCHEDU\
    LED\x10\0\x12\x0b\n\x07SKIPPED\x10\x01\x12\x0b\n\x07NO_DATA\x10\x02\x12\
    \x0f\n\x0bUNSCHEDULED\x10\x03*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\
    \x10\x90N\x1a\x92\x01\n\x0eTripProperties\x12\x17\n\x07trip_id\x18\x01\
    \x20\x01(\tR\x06tripId\x12\x1d\n\nstart_date\x18\x02\x20\x01(\tR\tstartD\
    ate\x12\x1d\n\nstart_time\x18\x03\x20\x01(\tR\tstartTime\x12\x19\n\x08sh\
    ape_id\x18\x04\x20\x01(\tR\x07shapeId*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\
    \x08\xa8F\x10\x90N*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\
    \xbf\x0b\n\x0fVehiclePosition\x124\n\x04trip\x18\x01\x20\x01(\x0b2\x20.t\
    ransit_realtime.TripDescriptorR\x04trip\x12=\n\x07vehicle\x18\x08\x20\
    \x01(\x0b2#.transit_realtime.VehicleDescriptorR\x07vehicle\x126\n\x08pos\
    ition\x18\x02\x20\x01(\x0b2\x1a.transit_realtime.PositionR\x08position\
    \x122\n\x15current_stop_sequence\x18\x03\x20\x01(\rR\x13currentStopSeque\
    nce\x12\x17\n\x07stop_id\x18\x07\x20\x01(\tR\x06stopId\x12i\n\x0ecurrent\
    _status\x18\x04\x20\x01(\x0e23.transit_realtime.VehiclePosition.VehicleS\
    topStatus:\rIN_TRANSIT_TOR\rcurrentStatus\x12\x1c\n\ttimestamp\x18\x05\
    \x20\x01(\x04R\ttimestamp\x12\\\n\x10congestion_level\x18\x06\x20\x01(\
    \x0e21.transit_realtime.VehiclePosition.CongestionLevelR\x0fcongestionLe\
    vel\x12\\\n\x10occupancy_status\x18\t\x20\x01(\x0e21.transit_realtime.Ve\
    hiclePosition.OccupancyStatusR\x0foccupancyStatus\x121\n\x14occupancy_pe\
    rcentage\x18\n\x20\x01(\rR\x13occupancyPercentage\x12g\n\x16multi_carria\
    ge_details\x18\x0b\x20\x03(\x0b21.transit_realtime.VehiclePosition.Carri\
    ageDetailsR\x14multiCarriageDetails\x1a\x9c\x02\n\x0fCarriageDetails\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05label\x18\x02\x20\
    \x01(\tR\x05label\x12o\n\x10occupancy_status\x18\x03\x20\x01(\x0e21.tran\
    sit_realtime.VehiclePosition.OccupancyStatus:\x11NO_DATA_AVAILABLER\x0fo\
    ccupancyStatus\x125\n\x14occupancy_percentage\x18\x04\x20\x01(\x05:\x02-\
    1R\x13occupancyPercentage\x12+\n\x11carriage_sequence\x18\x05\x20\x01(\r\
    R\x10carriageSequence*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90\
    N\"G\n\x11VehicleStopStatus\x12\x0f\n\x0bINCOMING_AT\x10\0\x12\x0e\n\nST\
    OPPED_AT\x10\x01\x12\x11\n\rIN_TRANSIT_TO\x10\x02\"}\n\x0fCongestionLeve\
    l\x12\x1c\n\x18UNKNOWN_CONGESTION_LEVEL\x10\0\x12\x14\n\x10RUNNING_SMOOT\
    HLY\x10\x01\x12\x0f\n\x0bSTOP_AND_GO\x10\x02\x12\x0e\n\nCONGESTION\x10\
    \x03\x12\x15\n\x11SEVERE_CONGESTION\x10\x04\"\xd9\x01\n\x0fOccupancyStat\
    us\x12\t\n\x05EMPTY\x10\0\x12\x18\n\x14MANY_SEATS_AVAILABLE\x10\x01\x12\
    \x17\n\x13FEW_SEATS_AVAILABLE\x10\x02\x12\x16\n\x12STANDING_ROOM_ONLY\
    \x10\x03\x12\x1e\n\x1aCRUSHED_STANDING_ROOM_ONLY\x10\x04\x12\x08\n\x04FU\
    LL\x10\x05\x12\x1c\n\x18NOT_ACCEPTING_PASSENGERS\x10\x06\x12\x15\n\x11NO\
    _DATA_AVAILABLE\x10\x07\x12\x11\n\rNOT_BOARDABLE\x10\x08*\x06\x08\xe8\
    \x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xa4\x0c\n\x05Alert\x12@\n\ract\
    ive_period\x18\x01\x20\x03(\x0b2\x1b.transit_realtime.TimeRangeR\x0cacti\
    vePeriod\x12I\n\x0finformed_entity\x18\x05\x20\x03(\x0b2\x20.transit_rea\
    ltime.EntitySelectorR\x0einformedEntity\x12B\n\x05cause\x18\x06\x20\x01(\
    \x0e2\x1d.transit_realtime.Alert.Cause:\rUNKNOWN_CAUSER\x05cause\x12F\n\
    \x06effect\x18\x07\x20\x01(\x0e2\x1e.transit_realtime.Alert.Effect:\x0eU\
    NKNOWN_EFFECTR\x06effect\x124\n\x03url\x18\x08\x20\x01(\x0b2\".transit_r\
    ealtime.TranslatedStringR\x03url\x12C\n\x0bheader_text\x18\n\x20\x01(\
    \x0b2\".transit_realtime.TranslatedStringR\nheaderText\x12M\n\x10descrip\
    tion_text\x18\x0b\x20\x01(\x0b2\".transit_realtime.TranslatedStringR\x0f\
    descriptionText\x12J\n\x0ftts_header_text\x18\x0c\x20\x01(\x0b2\".transi\
    t_realtime.TranslatedStringR\rttsHeaderText\x12T\n\x14tts_description_te\
    xt\x18\r\x20\x01(\x0b2\".transit_realtime.TranslatedStringR\x12ttsDescri\
    ptionText\x12^\n\x0eseverity_level\x18\x0e\x20\x01(\x0e2%.transit_realti\
    me.Alert.SeverityLevel:\x10UNKNOWN_SEVERITYR\rseverityLevel\x127\n\x05im\
    age\x18\x0f\x20\x01(\x0b2!.transit_realtime.TranslatedImageR\x05image\
    \x12X\n\x16image_alternative_text\x18\x10\x20\x01(\x0b2\".transit_realti\
    me.TranslatedStringR\x14imageAlternativeText\x12E\n\x0ccause_detail\x18\
    \x11\x20\x01(\x0b2\".transit_realtime.TranslatedStringR\x0bcauseDetail\
    \x12G\n\reffect_detail\x18\x12\x20\x01(\x0b2\".transit_realtime.Translat\
    edStringR\x0ceffectDetail\"\xd8\x01\n\x05Cause\x12\x11\n\rUNKNOWN_CAUSE\
    \x10\x01\x12\x0f\n\x0bOTHER_CAUSE\x10\x02\x12\x15\n\x11TECHNICAL_PROBLEM\
    \x10\x03\x12\n\n\x06STRIKE\x10\x04\x12\x11\n\rDEMONSTRATION\x10\x05\x12\
    \x0c\n\x08ACCIDENT\x10\x06\x12\x0b\n\x07HOLIDAY\x10\x07\x12\x0b\n\x07WEA\
    THER\x10\x08\x12\x0f\n\x0bMAINTENANCE\x10\t\x12\x10\n\x0cCONSTRUCTION\
    \x10\n\x12\x13\n\x0fPOLICE_ACTIVITY\x10\x0b\x12\x15\n\x11MEDICAL_EMERGEN\
    CY\x10\x0c\"\xdd\x01\n\x06Effect\x12\x0e\n\nNO_SERVICE\x10\x01\x12\x13\n\
    \x0fREDUCED_SERVICE\x10\x02\x12\x16\n\x12SIGNIFICANT_DELAYS\x10\x03\x12\
    \n\n\x06DETOUR\x10\x04\x12\x16\n\x12ADDITIONAL_SERVICE\x10\x05\x12\x14\n\
    \x10MODIFIED_SERVICE\x10\x06\x12\x10\n\x0cOTHER_EFFECT\x10\x07\x12\x12\n\
    \x0eUNKNOWN_EFFECT\x10\x08\x12\x0e\n\nSTOP_MOVED\x10\t\x12\r\n\tNO_EFFEC\
    T\x10\n\x12\x17\n\x13ACCESSIBILITY_ISSUE\x10\x0b\"H\n\rSeverityLevel\x12\
    \x14\n\x10UNKNOWN_SEVERITY\x10\x01\x12\x08\n\x04INFO\x10\x02\x12\x0b\n\
    \x07WARNING\x10\x03\x12\n\n\x06SEVERE\x10\x04*\x06\x08\xe8\x07\x10\xd0\
    \x0f*\x06\x08\xa8F\x10\x90N\"C\n\tTimeRange\x12\x14\n\x05start\x18\x01\
    \x20\x01(\x04R\x05start\x12\x10\n\x03end\x18\x02\x20\x01(\x04R\x03end*\
    \x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xa0\x01\n\x08Posit\
    ion\x12\x1a\n\x08latitude\x18\x01\x20\x02(\x02R\x08latitude\x12\x1c\n\tl\
    ongitude\x18\x02\x20\x02(\x02R\tlongitude\x12\x18\n\x07bearing\x18\x03\
    \x20\x01(\x02R\x07bearing\x12\x1a\n\x08odometer\x18\x04\x20\x01(\x01R\
    \x08odometer\x12\x14\n\x05speed\x18\x05\x20\x01(\x02R\x05speed*\x06\x08\
    \xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xa5\x03\n\x0eTripDescripto\
    r\x12\x17\n\x07trip_id\x18\x01\x20\x01(\tR\x06tripId\x12\x19\n\x08route_\
    id\x18\x05\x20\x01(\tR\x07routeId\x12!\n\x0cdirection_id\x18\x06\x20\x01\
    (\rR\x0bdirectionId\x12\x1d\n\nstart_time\x18\x02\x20\x01(\tR\tstartTime\
    \x12\x1d\n\nstart_date\x18\x03\x20\x01(\tR\tstartDate\x12j\n\x15schedule\
    _relationship\x18\x04\x20\x01(\x0e25.transit_realtime.TripDescriptor.Sch\
    eduleRelationshipR\x14scheduleRelationship\"\x81\x01\n\x14ScheduleRelati\
    onship\x12\r\n\tSCHEDULED\x10\0\x12\t\n\x05ADDED\x10\x01\x12\x0f\n\x0bUN\
    SCHEDULED\x10\x02\x12\x0c\n\x08CANCELED\x10\x03\x12\x13\n\x0bREPLACEMENT\
    \x10\x05\x1a\x02\x08\x01\x12\x0e\n\nDUPLICATED\x10\x06\x12\x0b\n\x07DELE\
    TED\x10\x07*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xd2\
    \x02\n\x11VehicleDescriptor\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12#\n\rlicense_plate\
    \x18\x03\x20\x01(\tR\x0clicensePlate\x12w\n\x15wheelchair_accessible\x18\
    \x04\x20\x01(\x0e28.transit_realtime.VehicleDescriptor.WheelchairAccessi\
    ble:\x08NO_VALUER\x14wheelchairAccessible\"i\n\x14WheelchairAccessible\
    \x12\x0c\n\x08NO_VALUE\x10\0\x12\x0b\n\x07UNKNOWN\x10\x01\x12\x19\n\x15W\
    HEELCHAIR_ACCESSIBLE\x10\x02\x12\x1b\n\x17WHEELCHAIR_INACCESSIBLE\x10\
    \x03*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\xe9\x01\n\x0e\
    EntitySelector\x12\x1b\n\tagency_id\x18\x01\x20\x01(\tR\x08agencyId\x12\
    \x19\n\x08route_id\x18\x02\x20\x01(\tR\x07routeId\x12\x1d\n\nroute_type\
    \x18\x03\x20\x01(\x05R\trouteType\x124\n\x04trip\x18\x04\x20\x01(\x0b2\
    \x20.transit_realtime.TripDescriptorR\x04trip\x12\x17\n\x07stop_id\x18\
    \x05\x20\x01(\tR\x06stopId\x12!\n\x0cdirection_id\x18\x06\x20\x01(\rR\
    \x0bdirectionId*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90N\"\
    \xc3\x01\n\x10TranslatedString\x12P\n\x0btranslation\x18\x01\x20\x03(\
    \x0b2..transit_realtime.TranslatedString.TranslationR\x0btranslation\x1a\
    M\n\x0bTranslation\x12\x12\n\x04text\x18\x01\x20\x02(\tR\x04text\x12\x1a\
    \n\x08language\x18\x02\x20\x01(\tR\x08language*\x06\x08\xe8\x07\x10\xd0\
    \x0f*\x06\x08\xa8F\x10\x90N*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\
    \x10\x90N\"\xeb\x01\n\x0fTranslatedImage\x12Y\n\x0flocalized_image\x18\
    \x01\x20\x03(\x0b20.transit_realtime.TranslatedImage.LocalizedImageR\x0e\
    localizedImage\x1am\n\x0eLocalizedImage\x12\x10\n\x03url\x18\x01\x20\x02\
    (\tR\x03url\x12\x1d\n\nmedia_type\x18\x02\x20\x02(\tR\tmediaType\x12\x1a\
    \n\x08language\x18\x03\x20\x01(\tR\x08language*\x06\x08\xe8\x07\x10\xd0\
    \x0f*\x06\x08\xa8F\x10\x90N*\x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\
    \x10\x90N\"]\n\x05Shape\x12\x19\n\x08shape_id\x18\x01\x20\x01(\tR\x07sha\
    peId\x12)\n\x10encoded_polyline\x18\x02\x20\x01(\tR\x0fencodedPolyline*\
    \x06\x08\xe8\x07\x10\xd0\x0f*\x06\x08\xa8F\x10\x90NB\x1d\n\x1bcom.google\
    .transit.realtimeJ\x95\xbd\x03\n\x07\x12\x05\x18\0\x8a\x08\x01\n\xcd\x07\
    \n\x01\x0c\x12\x03\x18\0\x122\xc7\x04\x20Copyright\x202015\x20The\x20GTF\
    S\x20Specifications\x20Authors.\n\n\x20Licensed\x20under\x20the\x20Apach\
    e\x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\
    \x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20\
    the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20L\
    icense\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICEN\
    SE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agr\
    eed\x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n2\xf8\x02\x20Protocol\x20definition\
    \x20file\x20for\x20GTFS\x20Realtime.\n\n\x20GTFS\x20Realtime\x20lets\x20\
    transit\x20agencies\x20provide\x20consumers\x20with\x20realtime\n\x20inf\
    ormation\x20about\x20disruptions\x20to\x20their\x20service\x20(stations\
    \x20closed,\x20lines\x20not\n\x20operating,\x20important\x20delays\x20et\
    c),\x20location\x20of\x20their\x20vehicles\x20and\x20expected\n\x20arriv\
    al\x20times.\n\n\x20This\x20protocol\x20is\x20published\x20at:\n\x20http\
    s://github.com/google/transit/tree/master/gtfs-realtime\n\n\x08\n\x01\
    \x08\x12\x03\x19\04\n\t\n\x02\x08\x01\x12\x03\x19\04\n\x08\n\x01\x02\x12\
    \x03\x1a\x08\x18\n\xb4\x04\n\x02\x04\0\x12\x04%\03\x01\x1a\xa7\x04\x20Th\
    e\x20contents\x20of\x20a\x20feed\x20message.\n\x20A\x20feed\x20is\x20a\
    \x20continuous\x20stream\x20of\x20feed\x20messages.\x20Each\x20message\
    \x20in\x20the\x20stream\x20is\n\x20obtained\x20as\x20a\x20response\x20to\
    \x20an\x20appropriate\x20HTTP\x20GET\x20request.\n\x20A\x20realtime\x20f\
    eed\x20is\x20always\x20defined\x20with\x20relation\x20to\x20an\x20existi\
    ng\x20GTFS\x20feed.\n\x20All\x20the\x20entity\x20ids\x20are\x20resolved\
    \x20with\x20respect\x20to\x20the\x20GTFS\x20feed.\n\x20Note\x20that\x20\
    \"required\"\x20and\x20\"optional\"\x20as\x20stated\x20in\x20this\x20fil\
    e\x20refer\x20to\x20Protocol\n\x20Buffer\x20cardinality,\x20not\x20seman\
    tic\x20cardinality.\x20\x20See\x20reference.md\x20at\n\x20https://github\
    .com/google/transit/tree/master/gtfs-realtime\x20for\x20field\n\x20seman\
    tic\x20cardinality.\n\n\n\n\x03\x04\0\x01\x12\x03%\x08\x13\n9\n\x04\x04\
    \0\x02\0\x12\x03'\x02!\x1a,\x20Metadata\x20about\x20this\x20feed\x20and\
    \x20feed\x20message.\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03'\x02\n\n\x0c\
    \n\x05\x04\0\x02\0\x06\x12\x03'\x0b\x15\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03'\x16\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03'\x1f\x20\n$\n\x04\x04\
    \0\x02\x01\x12\x03*\x02!\x1a\x17\x20Contents\x20of\x20the\x20feed.\n\n\
    \x0c\n\x05\x04\0\x02\x01\x04\x12\x03*\x02\n\n\x0c\n\x05\x04\0\x02\x01\
    \x06\x12\x03*\x0b\x15\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03*\x16\x1c\n\
    \x0c\n\x05\x04\0\x02\x01\x03\x12\x03*\x1f\x20\n\xb8\x01\n\x03\x04\0\x05\
    \x12\x03/\x02\x1a\x1a\xab\x01\x20The\x20extensions\x20namespace\x20allow\
    s\x203rd-party\x20developers\x20to\x20extend\x20the\n\x20GTFS\x20Realtim\
    e\x20specification\x20in\x20order\x20to\x20add\x20and\x20evaluate\x20new\
    \x20features\x20and\n\x20modifications\x20to\x20the\x20spec.\n\n\x0b\n\
    \x04\x04\0\x05\0\x12\x03/\r\x19\n\x0c\n\x05\x04\0\x05\0\x01\x12\x03/\r\
    \x11\n\x0c\n\x05\x04\0\x05\0\x02\x12\x03/\x15\x19\n[\n\x03\x04\0\x05\x12\
    \x032\x02\x1a\x1aO\x20The\x20following\x20extension\x20IDs\x20are\x20res\
    erved\x20for\x20private\x20use\x20by\x20any\x20organization.\n\n\x0b\n\
    \x04\x04\0\x05\x01\x12\x032\r\x19\n\x0c\n\x05\x04\0\x05\x01\x01\x12\x032\
    \r\x11\n\x0c\n\x05\x04\0\x05\x01\x02\x12\x032\x15\x19\n?\n\x02\x04\x01\
    \x12\x046\0R\x01\x1a3\x20Metadata\x20about\x20a\x20feed,\x20included\x20\
    in\x20feed\x20messages.\n\n\n\n\x03\x04\x01\x01\x12\x036\x08\x12\np\n\
    \x04\x04\x01\x02\0\x12\x039\x02,\x1ac\x20Version\x20of\x20the\x20feed\
    \x20specification.\n\x20The\x20current\x20version\x20is\x202.0.\x20\x20V\
    alid\x20versions\x20are\x20\"2.0\",\x20\"1.0\".\n\n\x0c\n\x05\x04\x01\
    \x02\0\x04\x12\x039\x02\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x039\x0b\x11\
    \n\x0c\n\x05\x04\x01\x02\0\x01\x12\x039\x12'\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x039*+\n\xef\x02\n\x04\x04\x01\x04\0\x12\x04@\x02C\x03\x1a\xe0\
    \x02\x20Determines\x20whether\x20the\x20current\x20fetch\x20is\x20increm\
    ental.\x20\x20Currently,\n\x20DIFFERENTIAL\x20mode\x20is\x20unsupported\
    \x20and\x20behavior\x20is\x20unspecified\x20for\x20feeds\n\x20that\x20us\
    e\x20this\x20mode.\x20\x20There\x20are\x20discussions\x20on\x20the\x20GT\
    FS\x20Realtime\x20mailing\n\x20list\x20around\x20fully\x20specifying\x20\
    the\x20behavior\x20of\x20DIFFERENTIAL\x20mode\x20and\x20the\n\x20documen\
    tation\x20will\x20be\x20updated\x20when\x20those\x20discussions\x20are\
    \x20finalized.\n\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03@\x07\x15\n\r\n\
    \x06\x04\x01\x04\0\x02\0\x12\x03A\x04\x15\n\x0e\n\x07\x04\x01\x04\0\x02\
    \0\x01\x12\x03A\x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03A\x13\
    \x14\n\r\n\x06\x04\x01\x04\0\x02\x01\x12\x03B\x04\x15\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x01\x01\x12\x03B\x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x01\x02\x12\x03B\x13\x14\n\x0b\n\x04\x04\x01\x02\x01\x12\x03D\x02F\n\
    \x0c\n\x05\x04\x01\x02\x01\x04\x12\x03D\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x01\x06\x12\x03D\x0b\x19\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03D\x1a(\
    \n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03D+,\n\x0c\n\x05\x04\x01\x02\x01\
    \x08\x12\x03D-E\n\x0c\n\x05\x04\x01\x02\x01\x07\x12\x03D8D\n\xc4\x01\n\
    \x04\x04\x01\x02\x02\x12\x03I\x02\x20\x1a\xb6\x01\x20This\x20timestamp\
    \x20identifies\x20the\x20moment\x20when\x20the\x20content\x20of\x20this\
    \x20feed\x20has\x20been\n\x20created\x20(in\x20server\x20time).\x20In\
    \x20POSIX\x20time\x20(i.e.,\x20number\x20of\x20seconds\x20since\n\x20Jan\
    uary\x201st\x201970\x2000:00:00\x20UTC).\n\n\x0c\n\x05\x04\x01\x02\x02\
    \x04\x12\x03I\x02\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03I\x0b\x11\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03I\x12\x1b\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03I\x1e\x1f\n\xb8\x01\n\x03\x04\x01\x05\x12\x03N\x02\x1a\
    \x1a\xab\x01\x20The\x20extensions\x20namespace\x20allows\x203rd-party\
    \x20developers\x20to\x20extend\x20the\n\x20GTFS\x20Realtime\x20specifica\
    tion\x20in\x20order\x20to\x20add\x20and\x20evaluate\x20new\x20features\
    \x20and\n\x20modifications\x20to\x20the\x20spec.\n\n\x0b\n\x04\x04\x01\
    \x05\0\x12\x03N\r\x19\n\x0c\n\x05\x04\x01\x05\0\x01\x12\x03N\r\x11\n\x0c\
    \n\x05\x04\x01\x05\0\x02\x12\x03N\x15\x19\n[\n\x03\x04\x01\x05\x12\x03Q\
    \x02\x1a\x1aO\x20The\x20following\x20extension\x20IDs\x20are\x20reserved\
    \x20for\x20private\x20use\x20by\x20any\x20organization.\n\n\x0b\n\x04\
    \x04\x01\x05\x01\x12\x03Q\r\x19\n\x0c\n\x05\x04\x01\x05\x01\x01\x12\x03Q\
    \r\x11\n\x0c\n\x05\x04\x01\x05\x01\x02\x12\x03Q\x15\x19\nH\n\x02\x04\x02\
    \x12\x04U\0t\x01\x1a<\x20A\x20definition\x20(or\x20update)\x20of\x20an\
    \x20entity\x20in\x20the\x20transit\x20feed.\n\n\n\n\x03\x04\x02\x01\x12\
    \x03U\x08\x12\n\xfa\x03\n\x04\x04\x02\x02\0\x12\x03^\x02\x19\x1a\xec\x03\
    \x20The\x20ids\x20are\x20used\x20only\x20to\x20provide\x20incrementality\
    \x20support.\x20The\x20id\x20should\x20be\n\x20unique\x20within\x20a\x20\
    FeedMessage.\x20Consequent\x20FeedMessages\x20may\x20contain\n\x20FeedEn\
    tities\x20with\x20the\x20same\x20id.\x20In\x20case\x20of\x20a\x20DIFFERE\
    NTIAL\x20update\x20the\x20new\n\x20FeedEntity\x20with\x20some\x20id\x20w\
    ill\x20replace\x20the\x20old\x20FeedEntity\x20with\x20the\x20same\x20id\
    \n\x20(or\x20delete\x20it\x20-\x20see\x20is_deleted\x20below).\n\x20The\
    \x20actual\x20GTFS\x20entities\x20(e.g.\x20stations,\x20routes,\x20trips\
    )\x20referenced\x20by\x20the\n\x20feed\x20must\x20be\x20specified\x20by\
    \x20explicit\x20selectors\x20(see\x20EntitySelector\x20below\x20for\n\
    \x20more\x20info).\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03^\x02\n\n\x0c\
    \n\x05\x04\x02\x02\0\x05\x12\x03^\x0b\x11\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03^\x12\x14\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03^\x17\x18\n\\\n\
    \x04\x04\x02\x02\x01\x12\x03b\x021\x1aO\x20Whether\x20this\x20entity\x20\
    is\x20to\x20be\x20deleted.\x20Relevant\x20only\x20for\x20incremental\n\
    \x20fetches.\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03b\x02\n\n\x0c\n\
    \x05\x04\x02\x02\x01\x05\x12\x03b\x0b\x0f\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03b\x10\x1a\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03b\x1d\x1e\n\
    \x0c\n\x05\x04\x02\x02\x01\x08\x12\x03b\x1f0\n\x0c\n\x05\x04\x02\x02\x01\
    \x07\x12\x03b*/\n\x87\x01\n\x04\x04\x02\x02\x02\x12\x03f\x02&\x1az\x20Da\
    ta\x20about\x20the\x20entity\x20itself.\x20Exactly\x20one\x20of\x20the\
    \x20following\x20fields\x20must\x20be\n\x20present\x20(unless\x20the\x20\
    entity\x20is\x20being\x20deleted).\n\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\
    \x03f\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03f\x0b\x15\n\x0c\n\x05\
    \x04\x02\x02\x02\x01\x12\x03f\x16!\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\
    \x03f$%\n\x0b\n\x04\x04\x02\x02\x03\x12\x03g\x02'\n\x0c\n\x05\x04\x02\
    \x02\x03\x04\x12\x03g\x02\n\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03g\x0b\
    \x1a\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03g\x1b\"\n\x0c\n\x05\x04\x02\
    \x02\x03\x03\x12\x03g%&\n\x0b\n\x04\x04\x02\x02\x04\x12\x03h\x02\x1b\n\
    \x0c\n\x05\x04\x02\x02\x04\x04\x12\x03h\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x04\x06\x12\x03h\x0b\x10\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03h\x11\
    \x16\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03h\x19\x1a\nw\n\x04\x04\x02\
    \x02\x05\x12\x03k\x02\x1b\x1aj\x20NOTE:\x20This\x20field\x20is\x20still\
    \x20experimental,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\
    \x20formally\x20adopted\x20in\x20the\x20future.\n\n\x0c\n\x05\x04\x02\
    \x02\x05\x04\x12\x03k\x02\n\n\x0c\n\x05\x04\x02\x02\x05\x06\x12\x03k\x0b\
    \x10\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03k\x11\x16\n\x0c\n\x05\x04\
    \x02\x02\x05\x03\x12\x03k\x19\x1a\n\xb8\x01\n\x03\x04\x02\x05\x12\x03p\
    \x02\x1a\x1a\xab\x01\x20The\x20extensions\x20namespace\x20allows\x203rd-\
    party\x20developers\x20to\x20extend\x20the\n\x20GTFS\x20Realtime\x20Spec\
    ification\x20in\x20order\x20to\x20add\x20and\x20evaluate\x20new\x20featu\
    res\x20and\n\x20modifications\x20to\x20the\x20spec.\n\n\x0b\n\x04\x04\
    \x02\x05\0\x12\x03p\r\x19\n\x0c\n\x05\x04\x02\x05\0\x01\x12\x03p\r\x11\n\
    \x0c\n\x05\x04\x02\x05\0\x02\x12\x03p\x15\x19\n[\n\x03\x04\x02\x05\x12\
    \x03s\x02\x1a\x1aO\x20The\x20following\x20extension\x20IDs\x20are\x20res\
    erved\x20for\x20private\x20use\x20by\x20any\x20organization.\n\n\x0b\n\
    \x04\x04\x02\x05\x01\x12\x03s\r\x19\n\x0c\n\x05\x04\x02\x05\x01\x01\x12\
    \x03s\r\x11\n\x0c\n\x05\x04\x02\x05\x01\x02\x12\x03s\x15\x19\n\xef\x0c\n\
    \x02\x04\x03\x12\x06\x94\x01\0\x8c\x03\x01\x1a\xc0\x0c\x20Realtime\x20up\
    date\x20of\x20the\x20progress\x20of\x20a\x20vehicle\x20along\x20a\x20tri\
    p.\n\x20Depending\x20on\x20the\x20value\x20of\x20ScheduleRelationship,\
    \x20a\x20TripUpdate\x20can\x20specify:\n\x20-\x20A\x20trip\x20that\x20pr\
    oceeds\x20along\x20the\x20schedule.\n\x20-\x20A\x20trip\x20that\x20proce\
    eds\x20along\x20a\x20route\x20but\x20has\x20no\x20fixed\x20schedule.\n\
    \x20-\x20A\x20trip\x20that\x20have\x20been\x20added\x20or\x20removed\x20\
    with\x20regard\x20to\x20schedule.\n\n\x20The\x20updates\x20can\x20be\x20\
    for\x20future,\x20predicted\x20arrival/departure\x20events,\x20or\x20for\
    \n\x20past\x20events\x20that\x20already\x20occurred.\n\x20Normally,\x20u\
    pdates\x20should\x20get\x20more\x20precise\x20and\x20more\x20certain\x20\
    (see\n\x20uncertainty\x20below)\x20as\x20the\x20events\x20gets\x20closer\
    \x20to\x20current\x20time.\n\x20Even\x20if\x20that\x20is\x20not\x20possi\
    ble,\x20the\x20information\x20for\x20past\x20events\x20should\x20be\n\
    \x20precise\x20and\x20certain.\x20In\x20particular,\x20if\x20an\x20updat\
    e\x20points\x20to\x20time\x20in\x20the\x20past\n\x20but\x20its\x20update\
    's\x20uncertainty\x20is\x20not\x200,\x20the\x20client\x20should\x20concl\
    ude\x20that\x20the\n\x20update\x20is\x20a\x20(wrong)\x20prediction\x20an\
    d\x20that\x20the\x20trip\x20has\x20not\x20completed\x20yet.\n\n\x20Note\
    \x20that\x20the\x20update\x20can\x20describe\x20a\x20trip\x20that\x20is\
    \x20already\x20completed.\n\x20To\x20this\x20end,\x20it\x20is\x20enough\
    \x20to\x20provide\x20an\x20update\x20for\x20the\x20last\x20stop\x20of\
    \x20the\x20trip.\n\x20If\x20the\x20time\x20of\x20that\x20is\x20in\x20the\
    \x20past,\x20the\x20client\x20will\x20conclude\x20from\x20that\x20that\n\
    \x20the\x20whole\x20trip\x20is\x20in\x20the\x20past\x20(it\x20is\x20poss\
    ible,\x20although\x20inconsequential,\x20to\n\x20also\x20provide\x20upda\
    tes\x20for\x20preceding\x20stops).\n\x20This\x20option\x20is\x20most\x20\
    relevant\x20for\x20a\x20trip\x20that\x20has\x20completed\x20ahead\x20of\
    \x20schedule,\n\x20but\x20according\x20to\x20the\x20schedule,\x20the\x20\
    trip\x20is\x20still\x20proceeding\x20at\x20the\x20current\n\x20time.\x20\
    Removing\x20the\x20updates\x20for\x20this\x20trip\x20could\x20make\x20th\
    e\x20client\x20assume\n\x20that\x20the\x20trip\x20is\x20still\x20proceed\
    ing.\n\x20Note\x20that\x20the\x20feed\x20provider\x20is\x20allowed,\x20b\
    ut\x20not\x20required,\x20to\x20purge\x20past\n\x20updates\x20-\x20this\
    \x20is\x20one\x20case\x20where\x20this\x20would\x20be\x20practically\x20\
    useful.\n2\x1e\n\x20Entities\x20used\x20in\x20the\x20feed.\n\n\n\x0b\n\
    \x03\x04\x03\x01\x12\x04\x94\x01\x08\x12\n\x96\x02\n\x04\x04\x03\x02\0\
    \x12\x04\x99\x01\x02#\x1a\x87\x02\x20The\x20Trip\x20that\x20this\x20mess\
    age\x20applies\x20to.\x20There\x20can\x20be\x20at\x20most\x20one\n\x20Tr\
    ipUpdate\x20entity\x20for\x20each\x20actual\x20trip\x20instance.\n\x20If\
    \x20there\x20is\x20none,\x20that\x20means\x20there\x20is\x20no\x20predic\
    tion\x20information\x20available.\n\x20It\x20does\x20*not*\x20mean\x20th\
    at\x20the\x20trip\x20is\x20progressing\x20according\x20to\x20schedule.\n\
    \n\r\n\x05\x04\x03\x02\0\x04\x12\x04\x99\x01\x02\n\n\r\n\x05\x04\x03\x02\
    \0\x06\x12\x04\x99\x01\x0b\x19\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x99\
    \x01\x1a\x1e\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x99\x01!\"\nP\n\x04\x04\
    \x03\x02\x01\x12\x04\x9c\x01\x02)\x1aB\x20Additional\x20information\x20o\
    n\x20the\x20vehicle\x20that\x20is\x20serving\x20this\x20trip.\n\n\r\n\
    \x05\x04\x03\x02\x01\x04\x12\x04\x9c\x01\x02\n\n\r\n\x05\x04\x03\x02\x01\
    \x06\x12\x04\x9c\x01\x0b\x1c\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x9c\
    \x01\x1d$\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\x9c\x01'(\n\xb3\x06\n\
    \x04\x04\x03\x03\0\x12\x06\xad\x01\x02\xc5\x01\x03\x1a\xa2\x06\x20Timing\
    \x20information\x20for\x20a\x20single\x20predicted\x20event\x20(either\
    \x20arrival\x20or\n\x20departure).\n\x20Timing\x20consists\x20of\x20dela\
    y\x20and/or\x20estimated\x20time,\x20and\x20uncertainty.\n\x20-\x20delay\
    \x20should\x20be\x20used\x20when\x20the\x20prediction\x20is\x20given\x20\
    relative\x20to\x20some\n\x20\x20\x20existing\x20schedule\x20in\x20GTFS.\
    \n\x20-\x20time\x20should\x20be\x20given\x20whether\x20there\x20is\x20a\
    \x20predicted\x20schedule\x20or\x20not.\x20If\n\x20\x20\x20both\x20time\
    \x20and\x20delay\x20are\x20specified,\x20time\x20will\x20take\x20precede\
    nce\n\x20\x20\x20(although\x20normally,\x20time,\x20if\x20given\x20for\
    \x20a\x20scheduled\x20trip,\x20should\x20be\n\x20\x20\x20equal\x20to\x20\
    scheduled\x20time\x20in\x20GTFS\x20+\x20delay).\n\n\x20Uncertainty\x20ap\
    plies\x20equally\x20to\x20both\x20time\x20and\x20delay.\n\x20The\x20unce\
    rtainty\x20roughly\x20specifies\x20the\x20expected\x20error\x20in\x20tru\
    e\x20delay\x20(but\n\x20note,\x20we\x20don't\x20yet\x20define\x20its\x20\
    precise\x20statistical\x20meaning).\x20It's\x20possible\n\x20for\x20the\
    \x20uncertainty\x20to\x20be\x200,\x20for\x20example\x20for\x20trains\x20\
    that\x20are\x20driven\x20under\n\x20computer\x20timing\x20control.\n\n\r\
    \n\x05\x04\x03\x03\0\x01\x12\x04\xad\x01\n\x17\n\xcd\x01\n\x06\x04\x03\
    \x03\0\x02\0\x12\x04\xb1\x01\x04\x1d\x1a\xbc\x01\x20Delay\x20(in\x20seco\
    nds)\x20can\x20be\x20positive\x20(meaning\x20that\x20the\x20vehicle\x20i\
    s\x20late)\x20or\n\x20negative\x20(meaning\x20that\x20the\x20vehicle\x20\
    is\x20ahead\x20of\x20schedule).\x20Delay\x20of\x200\n\x20means\x20that\
    \x20the\x20vehicle\x20is\x20exactly\x20on\x20time.\n\n\x0f\n\x07\x04\x03\
    \x03\0\x02\0\x04\x12\x04\xb1\x01\x04\x0c\n\x0f\n\x07\x04\x03\x03\0\x02\0\
    \x05\x12\x04\xb1\x01\r\x12\n\x0f\n\x07\x04\x03\x03\0\x02\0\x01\x12\x04\
    \xb1\x01\x13\x18\n\x0f\n\x07\x04\x03\x03\0\x02\0\x03\x12\x04\xb1\x01\x1b\
    \x1c\nw\n\x06\x04\x03\x03\0\x02\x01\x12\x04\xb6\x01\x04\x1c\x1ag\x20Even\
    t\x20as\x20absolute\x20time.\n\x20In\x20Unix\x20time\x20(i.e.,\x20number\
    \x20of\x20seconds\x20since\x20January\x201st\x201970\x2000:00:00\n\x20UT\
    C).\n\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x04\x12\x04\xb6\x01\x04\x0c\n\
    \x0f\n\x07\x04\x03\x03\0\x02\x01\x05\x12\x04\xb6\x01\r\x12\n\x0f\n\x07\
    \x04\x03\x03\0\x02\x01\x01\x12\x04\xb6\x01\x13\x17\n\x0f\n\x07\x04\x03\
    \x03\0\x02\x01\x03\x12\x04\xb6\x01\x1a\x1b\n\x9e\x02\n\x06\x04\x03\x03\0\
    \x02\x02\x12\x04\xbc\x01\x04#\x1a\x8d\x02\x20If\x20uncertainty\x20is\x20\
    omitted,\x20it\x20is\x20interpreted\x20as\x20unknown.\n\x20If\x20the\x20\
    prediction\x20is\x20unknown\x20or\x20too\x20uncertain,\x20the\x20delay\
    \x20(or\x20time)\x20field\n\x20should\x20be\x20empty.\x20In\x20such\x20c\
    ase,\x20the\x20uncertainty\x20field\x20is\x20ignored.\n\x20To\x20specify\
    \x20a\x20completely\x20certain\x20prediction,\x20set\x20its\x20uncertain\
    ty\x20to\x200.\n\n\x0f\n\x07\x04\x03\x03\0\x02\x02\x04\x12\x04\xbc\x01\
    \x04\x0c\n\x0f\n\x07\x04\x03\x03\0\x02\x02\x05\x12\x04\xbc\x01\r\x12\n\
    \x0f\n\x07\x04\x03\x03\0\x02\x02\x01\x12\x04\xbc\x01\x13\x1e\n\x0f\n\x07\
    \x04\x03\x03\0\x02\x02\x03\x12\x04\xbc\x01!\"\n\xbb\x01\n\x05\x04\x03\
    \x03\0\x05\x12\x04\xc1\x01\x04\x1c\x1a\xab\x01\x20The\x20extensions\x20n\
    amespace\x20allows\x203rd-party\x20developers\x20to\x20extend\x20the\n\
    \x20GTFS\x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20and\
    \x20evaluate\x20new\x20features\n\x20and\x20modifications\x20to\x20the\
    \x20spec.\n\n\x0e\n\x06\x04\x03\x03\0\x05\0\x12\x04\xc1\x01\x0f\x1b\n\
    \x0f\n\x07\x04\x03\x03\0\x05\0\x01\x12\x04\xc1\x01\x0f\x13\n\x0f\n\x07\
    \x04\x03\x03\0\x05\0\x02\x12\x04\xc1\x01\x17\x1b\n^\n\x05\x04\x03\x03\0\
    \x05\x12\x04\xc4\x01\x04\x1c\x1aO\x20The\x20following\x20extension\x20ID\
    s\x20are\x20reserved\x20for\x20private\x20use\x20by\x20any\x20organizati\
    on.\n\n\x0e\n\x06\x04\x03\x03\0\x05\x01\x12\x04\xc4\x01\x0f\x1b\n\x0f\n\
    \x07\x04\x03\x03\0\x05\x01\x01\x12\x04\xc4\x01\x0f\x13\n\x0f\n\x07\x04\
    \x03\x03\0\x05\x01\x02\x12\x04\xc4\x01\x17\x1b\n\xab\x03\n\x04\x04\x03\
    \x03\x01\x12\x06\xca\x01\x02\xa4\x02\x03\x1a\xd1\x01\x20Realtime\x20upda\
    te\x20for\x20arrival\x20and/or\x20departure\x20events\x20for\x20a\x20giv\
    en\x20stop\x20on\x20a\n\x20trip.\x20Updates\x20can\x20be\x20supplied\x20\
    for\x20both\x20past\x20and\x20future\x20events.\n\x20The\x20producer\x20\
    is\x20allowed,\x20although\x20not\x20required,\x20to\x20drop\x20past\x20\
    events.\n\"\xc6\x01\x20The\x20update\x20is\x20linked\x20to\x20a\x20speci\
    fic\x20stop\x20either\x20through\x20stop_sequence\x20or\n\x20stop_id,\
    \x20so\x20one\x20of\x20the\x20fields\x20below\x20must\x20necessarily\x20\
    be\x20set.\n\x20See\x20the\x20documentation\x20in\x20TripDescriptor\x20f\
    or\x20more\x20information.\n\n\r\n\x05\x04\x03\x03\x01\x01\x12\x04\xca\
    \x01\n\x18\nW\n\x06\x04\x03\x03\x01\x02\0\x12\x04\xd0\x01\x04&\x1aG\x20M\
    ust\x20be\x20the\x20same\x20as\x20in\x20stop_times.txt\x20in\x20the\x20c\
    orresponding\x20GTFS\x20feed.\n\n\x0f\n\x07\x04\x03\x03\x01\x02\0\x04\
    \x12\x04\xd0\x01\x04\x0c\n\x0f\n\x07\x04\x03\x03\x01\x02\0\x05\x12\x04\
    \xd0\x01\r\x13\n\x0f\n\x07\x04\x03\x03\x01\x02\0\x01\x12\x04\xd0\x01\x14\
    !\n\x0f\n\x07\x04\x03\x03\x01\x02\0\x03\x12\x04\xd0\x01$%\nR\n\x06\x04\
    \x03\x03\x01\x02\x01\x12\x04\xd2\x01\x04\x20\x1aB\x20Must\x20be\x20the\
    \x20same\x20as\x20in\x20stops.txt\x20in\x20the\x20corresponding\x20GTFS\
    \x20feed.\n\n\x0f\n\x07\x04\x03\x03\x01\x02\x01\x04\x12\x04\xd2\x01\x04\
    \x0c\n\x0f\n\x07\x04\x03\x03\x01\x02\x01\x05\x12\x04\xd2\x01\r\x13\n\x0f\
    \n\x07\x04\x03\x03\x01\x02\x01\x01\x12\x04\xd2\x01\x14\x1b\n\x0f\n\x07\
    \x04\x03\x03\x01\x02\x01\x03\x12\x04\xd2\x01\x1e\x1f\n\x0e\n\x06\x04\x03\
    \x03\x01\x02\x02\x12\x04\xd4\x01\x04'\n\x0f\n\x07\x04\x03\x03\x01\x02\
    \x02\x04\x12\x04\xd4\x01\x04\x0c\n\x0f\n\x07\x04\x03\x03\x01\x02\x02\x06\
    \x12\x04\xd4\x01\r\x1a\n\x0f\n\x07\x04\x03\x03\x01\x02\x02\x01\x12\x04\
    \xd4\x01\x1b\"\n\x0f\n\x07\x04\x03\x03\x01\x02\x02\x03\x12\x04\xd4\x01%&\
    \n\x0e\n\x06\x04\x03\x03\x01\x02\x03\x12\x04\xd5\x01\x04)\n\x0f\n\x07\
    \x04\x03\x03\x01\x02\x03\x04\x12\x04\xd5\x01\x04\x0c\n\x0f\n\x07\x04\x03\
    \x03\x01\x02\x03\x06\x12\x04\xd5\x01\r\x1a\n\x0f\n\x07\x04\x03\x03\x01\
    \x02\x03\x01\x12\x04\xd5\x01\x1b$\n\x0f\n\x07\x04\x03\x03\x01\x02\x03\
    \x03\x12\x04\xd5\x01'(\n\x8a\x02\n\x06\x04\x03\x03\x01\x02\x04\x12\x04\
    \xdb\x01\x04L\x1a\xf9\x01\x20Expected\x20occupancy\x20after\x20departure\
    \x20from\x20the\x20given\x20stop.\n\x20Should\x20be\x20provided\x20only\
    \x20for\x20future\x20stops.\n\x20In\x20order\x20to\x20provide\x20departu\
    re_occupancy_status\x20without\x20either\x20arrival\x20or\n\x20departure\
    \x20StopTimeEvents,\x20ScheduleRelationship\x20should\x20be\x20set\x20to\
    \x20NO_DATA.\x20\n\n\x0f\n\x07\x04\x03\x03\x01\x02\x04\x04\x12\x04\xdb\
    \x01\x04\x0c\n\x0f\n\x07\x04\x03\x03\x01\x02\x04\x06\x12\x04\xdb\x01\r,\
    \n\x0f\n\x07\x04\x03\x03\x01\x02\x04\x01\x12\x04\xdb\x01-G\n\x0f\n\x07\
    \x04\x03\x03\x01\x02\x04\x03\x12\x04\xdb\x01JK\nT\n\x06\x04\x03\x03\x01\
    \x04\0\x12\x06\xde\x01\x04\xfa\x01\x05\x1aB\x20The\x20relation\x20betwee\
    n\x20the\x20StopTimeEvents\x20and\x20the\x20static\x20schedule.\n\n\x0f\
    \n\x07\x04\x03\x03\x01\x04\0\x01\x12\x04\xde\x01\t\x1d\n\xc7\x03\n\x08\
    \x04\x03\x03\x01\x04\0\x02\0\x12\x04\xe5\x01\x06\x14\x1a\xb4\x03\x20The\
    \x20vehicle\x20is\x20proceeding\x20in\x20accordance\x20with\x20its\x20st\
    atic\x20schedule\x20of\n\x20stops,\x20although\x20not\x20necessarily\x20\
    according\x20to\x20the\x20times\x20of\x20the\x20schedule.\n\x20At\x20lea\
    st\x20one\x20of\x20arrival\x20and\x20departure\x20must\x20be\x20provided\
    .\x20If\x20the\x20schedule\n\x20for\x20this\x20stop\x20contains\x20both\
    \x20arrival\x20and\x20departure\x20times\x20then\x20so\x20must\n\x20this\
    \x20update.\x20Frequency-based\x20trips\x20(GTFS\x20frequencies.txt\x20w\
    ith\x20exact_times\x20=\x200)\n\x20should\x20not\x20have\x20a\x20SCHEDUL\
    ED\x20value\x20and\x20should\x20use\x20UNSCHEDULED\x20instead.\n\n\x11\n\
    \t\x04\x03\x03\x01\x04\0\x02\0\x01\x12\x04\xe5\x01\x06\x0f\n\x11\n\t\x04\
    \x03\x03\x01\x04\0\x02\0\x02\x12\x04\xe5\x01\x12\x13\n{\n\x08\x04\x03\
    \x03\x01\x04\0\x02\x01\x12\x04\xe9\x01\x06\x12\x1ai\x20The\x20stop\x20is\
    \x20skipped,\x20i.e.,\x20the\x20vehicle\x20will\x20not\x20stop\x20at\x20\
    this\x20stop.\n\x20Arrival\x20and\x20departure\x20are\x20optional.\n\n\
    \x11\n\t\x04\x03\x03\x01\x04\0\x02\x01\x01\x12\x04\xe9\x01\x06\r\n\x11\n\
    \t\x04\x03\x03\x01\x04\0\x02\x01\x02\x12\x04\xe9\x01\x10\x11\n\xee\x02\n\
    \x08\x04\x03\x03\x01\x04\0\x02\x02\x12\x04\xf1\x01\x06\x12\x1a\xdb\x02\
    \x20No\x20StopTimeEvents\x20are\x20given\x20for\x20this\x20stop.\n\x20Th\
    e\x20main\x20intention\x20for\x20this\x20value\x20is\x20to\x20give\x20ti\
    me\x20predictions\x20only\x20for\n\x20part\x20of\x20a\x20trip,\x20i.e.,\
    \x20if\x20the\x20last\x20update\x20for\x20a\x20trip\x20has\x20a\x20NO_DA\
    TA\n\x20specifier,\x20then\x20StopTimeEvents\x20for\x20the\x20rest\x20of\
    \x20the\x20stops\x20in\x20the\x20trip\n\x20are\x20considered\x20to\x20be\
    \x20unspecified\x20as\x20well.\n\x20Neither\x20arrival\x20nor\x20departu\
    re\x20should\x20be\x20supplied.\n\n\x11\n\t\x04\x03\x03\x01\x04\0\x02\
    \x02\x01\x12\x04\xf1\x01\x06\r\n\x11\n\t\x04\x03\x03\x01\x04\0\x02\x02\
    \x02\x12\x04\xf1\x01\x10\x11\n\xeb\x03\n\x08\x04\x03\x03\x01\x04\0\x02\
    \x03\x12\x04\xf9\x01\x06\x16\x1a\xd8\x03\x20The\x20vehicle\x20is\x20oper\
    ating\x20a\x20trip\x20defined\x20in\x20GTFS\x20frequencies.txt\x20with\
    \x20exact_times\x20=\x200.\n\x20This\x20value\x20should\x20not\x20be\x20\
    used\x20for\x20trips\x20that\x20are\x20not\x20defined\x20in\x20GTFS\x20f\
    requencies.txt,\n\x20or\x20trips\x20in\x20GTFS\x20frequencies.txt\x20wit\
    h\x20exact_times\x20=\x201.\x20Trips\x20containing\x20StopTimeUpdates\n\
    \x20with\x20ScheduleRelationship=UNSCHEDULED\x20must\x20also\x20set\x20T\
    ripDescriptor.ScheduleRelationship=UNSCHEDULED.\n\x20NOTE:\x20This\x20fi\
    eld\x20is\x20still\x20experimental,\x20and\x20subject\x20to\x20change.\
    \x20It\x20may\x20be\n\x20formally\x20adopted\x20in\x20the\x20future.\n\n\
    \x11\n\t\x04\x03\x03\x01\x04\0\x02\x03\x01\x12\x04\xf9\x01\x06\x11\n\x11\
    \n\t\x04\x03\x03\x01\x04\0\x02\x03\x02\x12\x04\xf9\x01\x14\x15\n\x10\n\
    \x06\x04\x03\x03\x01\x02\x05\x12\x06\xfb\x01\x04\xfc\x01\x1e\n\x0f\n\x07\
    \x04\x03\x03\x01\x02\x05\x04\x12\x04\xfb\x01\x04\x0c\n\x0f\n\x07\x04\x03\
    \x03\x01\x02\x05\x06\x12\x04\xfb\x01\r!\n\x0f\n\x07\x04\x03\x03\x01\x02\
    \x05\x01\x12\x04\xfb\x01\"7\n\x0f\n\x07\x04\x03\x03\x01\x02\x05\x03\x12\
    \x04\xfb\x01:;\n\x0f\n\x07\x04\x03\x03\x01\x02\x05\x08\x12\x04\xfc\x01\
    \x08\x1d\n\x0f\n\x07\x04\x03\x03\x01\x02\x05\x07\x12\x04\xfc\x01\x13\x1c\
    \n\xaf\x01\n\x06\x04\x03\x03\x01\x03\0\x12\x06\x80\x02\x04\x97\x02\x05\
    \x1a\x9c\x01\x20Provides\x20the\x20updated\x20values\x20for\x20the\x20st\
    op\x20time.\n\x20NOTE:\x20This\x20message\x20is\x20still\x20experimental\
    ,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\x20formally\x20a\
    dopted\x20in\x20the\x20future.\n\n\x0f\n\x07\x04\x03\x03\x01\x03\0\x01\
    \x12\x04\x80\x02\x0c\x1e\n\xe7\t\n\x08\x04\x03\x03\x01\x03\0\x02\0\x12\
    \x04\x8e\x02\x06+\x1a\xd4\t\x20Supports\x20real-time\x20stop\x20assignme\
    nts.\x20Refers\x20to\x20a\x20stop_id\x20defined\x20in\x20the\x20GTFS\x20\
    stops.txt.\n\x20The\x20new\x20assigned_stop_id\x20should\x20not\x20resul\
    t\x20in\x20a\x20significantly\x20different\x20trip\x20experience\x20for\
    \x20the\x20end\x20user\x20than\n\x20the\x20stop_id\x20defined\x20in\x20G\
    TFS\x20stop_times.txt.\x20In\x20other\x20words,\x20the\x20end\x20user\
    \x20should\x20not\x20view\x20this\x20new\x20stop_id\x20as\x20an\n\x20\"u\
    nusual\x20change\"\x20if\x20the\x20new\x20stop\x20was\x20presented\x20wi\
    thin\x20an\x20app\x20without\x20any\x20additional\x20context.\n\x20For\
    \x20example,\x20this\x20field\x20is\x20intended\x20to\x20be\x20used\x20f\
    or\x20platform\x20assignments\x20by\x20using\x20a\x20stop_id\x20that\x20\
    belongs\x20to\x20the\n\x20same\x20station\x20as\x20the\x20stop\x20origin\
    ally\x20defined\x20in\x20GTFS\x20stop_times.txt.\n\x20To\x20assign\x20a\
    \x20stop\x20without\x20providing\x20any\x20real-time\x20arrival\x20or\
    \x20departure\x20predictions,\x20populate\x20this\x20field\x20and\x20set\
    \n\x20StopTimeUpdate.schedule_relationship\x20=\x20NO_DATA.\n\x20If\x20t\
    his\x20field\x20is\x20populated,\x20it\x20is\x20preferred\x20to\x20omit\
    \x20`StopTimeUpdate.stop_id`\x20and\x20use\x20only\x20`StopTimeUpdate.st\
    op_sequence`.\x20If\n\x20`StopTimeProperties.assigned_stop_id`\x20and\
    \x20`StopTimeUpdate.stop_id`\x20are\x20populated,\x20`StopTimeUpdate.sto\
    p_id`\x20must\x20match\x20`assigned_stop_id`.\n\x20Platform\x20assignmen\
    ts\x20should\x20be\x20reflected\x20in\x20other\x20GTFS-realtime\x20field\
    s\x20as\x20well\n\x20(e.g.,\x20`VehiclePosition.stop_id`).\n\x20NOTE:\
    \x20This\x20field\x20is\x20still\x20experimental,\x20and\x20subject\x20t\
    o\x20change.\x20It\x20may\x20be\x20formally\x20adopted\x20in\x20the\x20f\
    uture.\n\n\x11\n\t\x04\x03\x03\x01\x03\0\x02\0\x04\x12\x04\x8e\x02\x06\
    \x0e\n\x11\n\t\x04\x03\x03\x01\x03\0\x02\0\x05\x12\x04\x8e\x02\x0f\x15\n\
    \x11\n\t\x04\x03\x03\x01\x03\0\x02\0\x01\x12\x04\x8e\x02\x16&\n\x11\n\t\
    \x04\x03\x03\x01\x03\0\x02\0\x03\x12\x04\x8e\x02)*\n\xbd\x01\n\x07\x04\
    \x03\x03\x01\x03\0\x05\x12\x04\x93\x02\x06\x1e\x1a\xab\x01\x20The\x20ext\
    ensions\x20namespace\x20allows\x203rd-party\x20developers\x20to\x20exten\
    d\x20the\n\x20GTFS\x20Realtime\x20Specification\x20in\x20order\x20to\x20\
    add\x20and\x20evaluate\x20new\x20features\n\x20and\x20modifications\x20t\
    o\x20the\x20spec.\n\n\x10\n\x08\x04\x03\x03\x01\x03\0\x05\0\x12\x04\x93\
    \x02\x11\x1d\n\x11\n\t\x04\x03\x03\x01\x03\0\x05\0\x01\x12\x04\x93\x02\
    \x11\x15\n\x11\n\t\x04\x03\x03\x01\x03\0\x05\0\x02\x12\x04\x93\x02\x19\
    \x1d\n`\n\x07\x04\x03\x03\x01\x03\0\x05\x12\x04\x96\x02\x06\x1e\x1aO\x20\
    The\x20following\x20extension\x20IDs\x20are\x20reserved\x20for\x20privat\
    e\x20use\x20by\x20any\x20organization.\n\n\x10\n\x08\x04\x03\x03\x01\x03\
    \0\x05\x01\x12\x04\x96\x02\x11\x1d\n\x11\n\t\x04\x03\x03\x01\x03\0\x05\
    \x01\x01\x12\x04\x96\x02\x11\x15\n\x11\n\t\x04\x03\x03\x01\x03\0\x05\x01\
    \x02\x12\x04\x96\x02\x19\x1d\n\xc7\x01\n\x06\x04\x03\x03\x01\x02\x06\x12\
    \x04\x9b\x02\x049\x1a\xb6\x01\x20Realtime\x20updates\x20for\x20certain\
    \x20properties\x20defined\x20within\x20GTFS\x20stop_times.txt\n\x20NOTE:\
    \x20This\x20field\x20is\x20still\x20experimental,\x20and\x20subject\x20t\
    o\x20change.\x20It\x20may\x20be\x20formally\x20adopted\x20in\x20the\x20f\
    uture.\n\n\x0f\n\x07\x04\x03\x03\x01\x02\x06\x04\x12\x04\x9b\x02\x04\x0c\
    \n\x0f\n\x07\x04\x03\x03\x01\x02\x06\x06\x12\x04\x9b\x02\r\x1f\n\x0f\n\
    \x07\x04\x03\x03\x01\x02\x06\x01\x12\x04\x9b\x02\x204\n\x0f\n\x07\x04\
    \x03\x03\x01\x02\x06\x03\x12\x04\x9b\x0278\n\xbb\x01\n\x05\x04\x03\x03\
    \x01\x05\x12\x04\xa0\x02\x04\x1c\x1a\xab\x01\x20The\x20extensions\x20nam\
    espace\x20allows\x203rd-party\x20developers\x20to\x20extend\x20the\n\x20\
    GTFS\x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20and\x20\
    evaluate\x20new\x20features\n\x20and\x20modifications\x20to\x20the\x20sp\
    ec.\n\n\x0e\n\x06\x04\x03\x03\x01\x05\0\x12\x04\xa0\x02\x0f\x1b\n\x0f\n\
    \x07\x04\x03\x03\x01\x05\0\x01\x12\x04\xa0\x02\x0f\x13\n\x0f\n\x07\x04\
    \x03\x03\x01\x05\0\x02\x12\x04\xa0\x02\x17\x1b\n^\n\x05\x04\x03\x03\x01\
    \x05\x12\x04\xa3\x02\x04\x1c\x1aO\x20The\x20following\x20extension\x20ID\
    s\x20are\x20reserved\x20for\x20private\x20use\x20by\x20any\x20organizati\
    on.\n\n\x0e\n\x06\x04\x03\x03\x01\x05\x01\x12\x04\xa3\x02\x0f\x1b\n\x0f\
    \n\x07\x04\x03\x03\x01\x05\x01\x01\x12\x04\xa3\x02\x0f\x13\n\x0f\n\x07\
    \x04\x03\x03\x01\x05\x01\x02\x12\x04\xa3\x02\x17\x1b\n\xbd\x06\n\x04\x04\
    \x03\x02\x02\x12\x04\xb9\x02\x02/\x1a\xae\x06\x20Updates\x20to\x20StopTi\
    mes\x20for\x20the\x20trip\x20(both\x20future,\x20i.e.,\x20predictions,\
    \x20and\x20in\n\x20some\x20cases,\x20past\x20ones,\x20i.e.,\x20those\x20\
    that\x20already\x20happened).\n\x20The\x20updates\x20must\x20be\x20sorte\
    d\x20by\x20stop_sequence,\x20and\x20apply\x20for\x20all\x20the\n\x20foll\
    owing\x20stops\x20of\x20the\x20trip\x20up\x20to\x20the\x20next\x20specif\
    ied\x20one.\n\n\x20Example\x201:\n\x20For\x20a\x20trip\x20with\x2020\x20\
    stops,\x20a\x20StopTimeUpdate\x20with\x20arrival\x20delay\x20and\x20depa\
    rture\n\x20delay\x20of\x200\x20for\x20stop_sequence\x20of\x20the\x20curr\
    ent\x20stop\x20means\x20that\x20the\x20trip\x20is\n\x20exactly\x20on\x20\
    time.\n\n\x20Example\x202:\n\x20For\x20the\x20same\x20trip\x20instance,\
    \x203\x20StopTimeUpdates\x20are\x20provided:\n\x20-\x20delay\x20of\x205\
    \x20min\x20for\x20stop_sequence\x203\n\x20-\x20delay\x20of\x201\x20min\
    \x20for\x20stop_sequence\x208\n\x20-\x20delay\x20of\x20unspecified\x20du\
    ration\x20for\x20stop_sequence\x2010\n\x20This\x20will\x20be\x20interpre\
    ted\x20as:\n\x20-\x20stop_sequences\x203,4,5,6,7\x20have\x20delay\x20of\
    \x205\x20min.\n\x20-\x20stop_sequences\x208,9\x20have\x20delay\x20of\x20\
    1\x20min.\n\x20-\x20stop_sequences\x2010,...\x20have\x20unknown\x20delay\
    .\n\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04\xb9\x02\x02\n\n\r\n\x05\x04\
    \x03\x02\x02\x06\x12\x04\xb9\x02\x0b\x19\n\r\n\x05\x04\x03\x02\x02\x01\
    \x12\x04\xb9\x02\x1a*\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\xb9\x02-.\n\
    \xb8\x02\n\x04\x04\x03\x02\x03\x12\x04\xbf\x02\x02\x20\x1a\xa9\x02\x20Th\
    e\x20most\x20recent\x20moment\x20at\x20which\x20the\x20vehicle's\x20real\
    -time\x20progress\x20was\x20measured\n\x20to\x20estimate\x20StopTimes\
    \x20in\x20the\x20future.\x20When\x20StopTimes\x20in\x20the\x20past\x20ar\
    e\x20provided,\n\x20arrival/departure\x20times\x20may\x20be\x20earlier\
    \x20than\x20this\x20value.\x20In\x20POSIX\n\x20time\x20(i.e.,\x20the\x20\
    number\x20of\x20seconds\x20since\x20January\x201st\x201970\x2000:00:00\
    \x20UTC).\n\n\r\n\x05\x04\x03\x02\x03\x04\x12\x04\xbf\x02\x02\n\n\r\n\
    \x05\x04\x03\x02\x03\x05\x12\x04\xbf\x02\x0b\x11\n\r\n\x05\x04\x03\x02\
    \x03\x01\x12\x04\xbf\x02\x12\x1b\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\
    \xbf\x02\x1e\x1f\n\xdd\x06\n\x04\x04\x03\x02\x04\x12\x04\xd3\x02\x02\x1b\
    \x1a\xce\x06\x20The\x20current\x20schedule\x20deviation\x20for\x20the\
    \x20trip.\x20\x20Delay\x20should\x20only\x20be\n\x20specified\x20when\
    \x20the\x20prediction\x20is\x20given\x20relative\x20to\x20some\x20existi\
    ng\x20schedule\n\x20in\x20GTFS.\n\n\x20Delay\x20(in\x20seconds)\x20can\
    \x20be\x20positive\x20(meaning\x20that\x20the\x20vehicle\x20is\x20late)\
    \x20or\n\x20negative\x20(meaning\x20that\x20the\x20vehicle\x20is\x20ahea\
    d\x20of\x20schedule).\x20Delay\x20of\x200\n\x20means\x20that\x20the\x20v\
    ehicle\x20is\x20exactly\x20on\x20time.\n\n\x20Delay\x20information\x20in\
    \x20StopTimeUpdates\x20take\x20precedent\x20of\x20trip-level\x20delay\n\
    \x20information,\x20such\x20that\x20trip-level\x20delay\x20is\x20only\
    \x20propagated\x20until\x20the\x20next\n\x20stop\x20along\x20the\x20trip\
    \x20with\x20a\x20StopTimeUpdate\x20delay\x20value\x20specified.\n\n\x20F\
    eed\x20providers\x20are\x20strongly\x20encouraged\x20to\x20provide\x20a\
    \x20TripUpdate.timestamp\n\x20value\x20indicating\x20when\x20the\x20dela\
    y\x20value\x20was\x20last\x20updated,\x20in\x20order\x20to\n\x20evaluate\
    \x20the\x20freshness\x20of\x20the\x20data.\n\n\x20NOTE:\x20This\x20field\
    \x20is\x20still\x20experimental,\x20and\x20subject\x20to\x20change.\x20I\
    t\x20may\x20be\n\x20formally\x20adopted\x20in\x20the\x20future.\n\n\r\n\
    \x05\x04\x03\x02\x04\x04\x12\x04\xd3\x02\x02\n\n\r\n\x05\x04\x03\x02\x04\
    \x05\x12\x04\xd3\x02\x0b\x10\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xd3\
    \x02\x11\x16\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\xd3\x02\x19\x1a\n\xa0\
    \x02\n\x04\x04\x03\x03\x02\x12\x06\xd8\x02\x02\x82\x03\x03\x1a\x8f\x02\
    \x20Defines\x20updated\x20properties\x20of\x20the\x20trip,\x20such\x20as\
    \x20a\x20new\x20shape_id\x20when\x20there\x20is\x20a\x20detour.\x20Or\
    \x20defines\x20the\n\x20trip_id,\x20start_date,\x20and\x20start_time\x20\
    of\x20a\x20DUPLICATED\x20trip.\x20\n\x20NOTE:\x20This\x20message\x20is\
    \x20still\x20experimental,\x20and\x20subject\x20to\x20change.\x20It\x20m\
    ay\x20be\x20formally\x20adopted\x20in\x20the\x20future.\n\n\r\n\x05\x04\
    \x03\x03\x02\x01\x12\x04\xd8\x02\n\x18\n\xe4\x04\n\x06\x04\x03\x03\x02\
    \x02\0\x12\x04\xdf\x02\x04\x20\x1a\xd3\x04\x20Defines\x20the\x20identifi\
    er\x20of\x20a\x20new\x20trip\x20that\x20is\x20a\x20duplicate\x20of\x20an\
    \x20existing\x20trip\x20defined\x20in\x20(CSV)\x20GTFS\x20trips.txt\n\
    \x20but\x20will\x20start\x20at\x20a\x20different\x20service\x20date\x20a\
    nd/or\x20time\x20(defined\x20using\x20the\x20TripProperties.start_date\
    \x20and\n\x20TripProperties.start_time\x20fields).\x20See\x20definition\
    \x20of\x20trips.trip_id\x20in\x20(CSV)\x20GTFS.\x20Its\x20value\x20must\
    \x20be\x20different\n\x20than\x20the\x20ones\x20used\x20in\x20the\x20(CS\
    V)\x20GTFS.\x20Required\x20if\x20schedule_relationship=DUPLICATED,\x20ot\
    herwise\x20this\x20field\x20must\x20not\n\x20be\x20populated\x20and\x20w\
    ill\x20be\x20ignored\x20by\x20consumers.\n\x20NOTE:\x20This\x20field\x20\
    is\x20still\x20experimental,\x20and\x20subject\x20to\x20change.\x20It\
    \x20may\x20be\x20formally\x20adopted\x20in\x20the\x20future.\n\n\x0f\n\
    \x07\x04\x03\x03\x02\x02\0\x04\x12\x04\xdf\x02\x04\x0c\n\x0f\n\x07\x04\
    \x03\x03\x02\x02\0\x05\x12\x04\xdf\x02\r\x13\n\x0f\n\x07\x04\x03\x03\x02\
    \x02\0\x01\x12\x04\xdf\x02\x14\x1b\n\x0f\n\x07\x04\x03\x03\x02\x02\0\x03\
    \x12\x04\xdf\x02\x1e\x1f\n\xc3\x02\n\x06\x04\x03\x03\x02\x02\x01\x12\x04\
    \xe3\x02\x04#\x1a\xb2\x02\x20Service\x20date\x20on\x20which\x20the\x20DU\
    PLICATED\x20trip\x20will\x20be\x20run,\x20in\x20YYYYMMDD\x20format.\x20R\
    equired\x20if\n\x20schedule_relationship=DUPLICATED,\x20otherwise\x20thi\
    s\x20field\x20must\x20not\x20be\x20populated\x20and\x20will\x20be\x20ign\
    ored\x20by\x20consumers.\n\x20NOTE:\x20This\x20field\x20is\x20still\x20e\
    xperimental,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\x20fo\
    rmally\x20adopted\x20in\x20the\x20future.\n\n\x0f\n\x07\x04\x03\x03\x02\
    \x02\x01\x04\x12\x04\xe3\x02\x04\x0c\n\x0f\n\x07\x04\x03\x03\x02\x02\x01\
    \x05\x12\x04\xe3\x02\r\x13\n\x0f\n\x07\x04\x03\x03\x02\x02\x01\x01\x12\
    \x04\xe3\x02\x14\x1e\n\x0f\n\x07\x04\x03\x03\x02\x02\x01\x03\x12\x04\xe3\
    \x02!\"\n\xfb\t\n\x06\x04\x03\x03\x02\x02\x02\x12\x04\xf0\x02\x04#\x1a\
    \xea\t\x20Defines\x20the\x20departure\x20start\x20time\x20of\x20the\x20t\
    rip\x20when\x20it\xe2\x80\x99s\x20duplicated.\x20See\x20definition\x20of\
    \x20stop_times.departure_time\n\x20in\x20(CSV)\x20GTFS.\x20Scheduled\x20\
    arrival\x20and\x20departure\x20times\x20for\x20the\x20duplicated\x20trip\
    \x20are\x20calculated\x20based\x20on\x20the\x20offset\n\x20between\x20th\
    e\x20original\x20trip\x20departure_time\x20and\x20this\x20field.\x20For\
    \x20example,\x20if\x20a\x20GTFS\x20trip\x20has\x20stop\x20A\x20with\x20a\
    \n\x20departure_time\x20of\x2010:00:00\x20and\x20stop\x20B\x20with\x20de\
    parture_time\x20of\x2010:01:00,\x20and\x20this\x20field\x20is\x20populat\
    ed\x20with\x20the\x20value\n\x20of\x2010:30:00,\x20stop\x20B\x20on\x20th\
    e\x20duplicated\x20trip\x20will\x20have\x20a\x20scheduled\x20departure_t\
    ime\x20of\x2010:31:00.\x20Real-time\x20prediction\n\x20delay\x20values\
    \x20are\x20applied\x20to\x20this\x20calculated\x20schedule\x20time\x20to\
    \x20determine\x20the\x20predicted\x20time.\x20For\x20example,\x20if\x20a\
    \n\x20departure\x20delay\x20of\x2030\x20is\x20provided\x20for\x20stop\
    \x20B,\x20then\x20the\x20predicted\x20departure\x20time\x20is\x2010:31:3\
    0.\x20Real-time\n\x20prediction\x20time\x20values\x20do\x20not\x20have\
    \x20any\x20offset\x20applied\x20to\x20them\x20and\x20indicate\x20the\x20\
    predicted\x20time\x20as\x20provided.\n\x20For\x20example,\x20if\x20a\x20\
    departure\x20time\x20representing\x2010:31:30\x20is\x20provided\x20for\
    \x20stop\x20B,\x20then\x20the\x20predicted\x20departure\x20time\n\x20is\
    \x2010:31:30.\x20This\x20field\x20is\x20required\x20if\x20schedule_relat\
    ionship\x20is\x20DUPLICATED,\x20otherwise\x20this\x20field\x20must\x20no\
    t\x20be\n\x20populated\x20and\x20will\x20be\x20ignored\x20by\x20consumer\
    s.\n\x20NOTE:\x20This\x20field\x20is\x20still\x20experimental,\x20and\
    \x20subject\x20to\x20change.\x20It\x20may\x20be\x20formally\x20adopted\
    \x20in\x20the\x20future.\n\n\x0f\n\x07\x04\x03\x03\x02\x02\x02\x04\x12\
    \x04\xf0\x02\x04\x0c\n\x0f\n\x07\x04\x03\x03\x02\x02\x02\x05\x12\x04\xf0\
    \x02\r\x13\n\x0f\n\x07\x04\x03\x03\x02\x02\x02\x01\x12\x04\xf0\x02\x14\
    \x1e\n\x0f\n\x07\x04\x03\x03\x02\x02\x02\x03\x12\x04\xf0\x02!\"\n\xef\
    \x06\n\x06\x04\x03\x03\x02\x02\x03\x12\x04\xf9\x02\x04!\x1a\xde\x06\x20S\
    pecifies\x20the\x20shape\x20of\x20the\x20vehicle\x20travel\x20path\x20wh\
    en\x20the\x20trip\x20shape\x20differs\x20from\x20the\x20shape\x20specifi\
    ed\x20in\n\x20(CSV)\x20GTFS\x20or\x20to\x20specify\x20it\x20in\x20real-t\
    ime\x20when\x20it's\x20not\x20provided\x20by\x20(CSV)\x20GTFS,\x20such\
    \x20as\x20a\x20vehicle\x20that\x20takes\x20differing\n\x20paths\x20based\
    \x20on\x20rider\x20demand.\x20See\x20definition\x20of\x20trips.shape_id\
    \x20in\x20(CSV)\x20GTFS.\x20If\x20a\x20shape\x20is\x20neither\x20defined\
    \x20in\x20(CSV)\x20GTFS\n\x20nor\x20in\x20real-time,\x20the\x20shape\x20\
    is\x20considered\x20unknown.\x20This\x20field\x20can\x20refer\x20to\x20a\
    \x20shape\x20defined\x20in\x20the\x20(CSV)\x20GTFS\x20in\x20shapes.txt\n\
    \x20or\x20a\x20Shape\x20in\x20the\x20(protobuf)\x20real-time\x20feed.\
    \x20The\x20order\x20of\x20stops\x20(stop\x20sequences)\x20for\x20this\
    \x20trip\x20must\x20remain\x20the\x20same\x20as\n\x20(CSV)\x20GTFS.\x20S\
    tops\x20that\x20are\x20a\x20part\x20of\x20the\x20original\x20trip\x20but\
    \x20will\x20no\x20longer\x20be\x20made,\x20such\x20as\x20when\x20a\x20de\
    tour\x20occurs,\x20should\n\x20be\x20marked\x20as\x20schedule_relationsh\
    ip=SKIPPED.\n\x20NOTE:\x20This\x20field\x20is\x20still\x20experimental,\
    \x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\x20formally\x20ad\
    opted\x20in\x20the\x20future.\x20\n\n\x0f\n\x07\x04\x03\x03\x02\x02\x03\
    \x04\x12\x04\xf9\x02\x04\x0c\n\x0f\n\x07\x04\x03\x03\x02\x02\x03\x05\x12\
    \x04\xf9\x02\r\x13\n\x0f\n\x07\x04\x03\x03\x02\x02\x03\x01\x12\x04\xf9\
    \x02\x14\x1c\n\x0f\n\x07\x04\x03\x03\x02\x02\x03\x03\x12\x04\xf9\x02\x1f\
    \x20\n\xbb\x01\n\x05\x04\x03\x03\x02\x05\x12\x04\xfe\x02\x04\x1c\x1a\xab\
    \x01\x20The\x20extensions\x20namespace\x20allows\x203rd-party\x20develop\
    ers\x20to\x20extend\x20the\n\x20GTFS\x20Realtime\x20Specification\x20in\
    \x20order\x20to\x20add\x20and\x20evaluate\x20new\x20features\n\x20and\
    \x20modifications\x20to\x20the\x20spec.\n\n\x0e\n\x06\x04\x03\x03\x02\
    \x05\0\x12\x04\xfe\x02\x0f\x1b\n\x0f\n\x07\x04\x03\x03\x02\x05\0\x01\x12\
    \x04\xfe\x02\x0f\x13\n\x0f\n\x07\x04\x03\x03\x02\x05\0\x02\x12\x04\xfe\
    \x02\x17\x1b\n^\n\x05\x04\x03\x03\x02\x05\x12\x04\x81\x03\x04\x1c\x1aO\
    \x20The\x20following\x20extension\x20IDs\x20are\x20reserved\x20for\x20pr\
    ivate\x20use\x20by\x20any\x20organization.\n\n\x0e\n\x06\x04\x03\x03\x02\
    \x05\x01\x12\x04\x81\x03\x0f\x1b\n\x0f\n\x07\x04\x03\x03\x02\x05\x01\x01\
    \x12\x04\x81\x03\x0f\x13\n\x0f\n\x07\x04\x03\x03\x02\x05\x01\x02\x12\x04\
    \x81\x03\x17\x1b\n\x0c\n\x04\x04\x03\x02\x05\x12\x04\x83\x03\x02.\n\r\n\
    \x05\x04\x03\x02\x05\x04\x12\x04\x83\x03\x02\n\n\r\n\x05\x04\x03\x02\x05\
    \x06\x12\x04\x83\x03\x0b\x19\n\r\n\x05\x04\x03\x02\x05\x01\x12\x04\x83\
    \x03\x1a)\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\x83\x03,-\n\xb9\x01\n\
    \x03\x04\x03\x05\x12\x04\x88\x03\x02\x1a\x1a\xab\x01\x20The\x20extension\
    s\x20namespace\x20allows\x203rd-party\x20developers\x20to\x20extend\x20t\
    he\n\x20GTFS\x20Realtime\x20Specification\x20in\x20order\x20to\x20add\
    \x20and\x20evaluate\x20new\x20features\x20and\n\x20modifications\x20to\
    \x20the\x20spec.\n\n\x0c\n\x04\x04\x03\x05\0\x12\x04\x88\x03\r\x19\n\r\n\
    \x05\x04\x03\x05\0\x01\x12\x04\x88\x03\r\x11\n\r\n\x05\x04\x03\x05\0\x02\
    \x12\x04\x88\x03\x15\x19\n\\\n\x03\x04\x03\x05\x12\x04\x8b\x03\x02\x1a\
    \x1aO\x20The\x20following\x20extension\x20IDs\x20are\x20reserved\x20for\
    \x20private\x20use\x20by\x20any\x20organization.\n\n\x0c\n\x04\x04\x03\
    \x05\x01\x12\x04\x8b\x03\r\x19\n\r\n\x05\x04\x03\x05\x01\x01\x12\x04\x8b\
    \x03\r\x11\n\r\n\x05\x04\x03\x05\x01\x02\x12\x04\x8b\x03\x15\x19\nE\n\
    \x02\x04\x04\x12\x06\x8f\x03\0\xbd\x04\x01\x1a7\x20Realtime\x20positioni\
    ng\x20information\x20for\x20a\x20given\x20vehicle.\n\n\x0b\n\x03\x04\x04\
    \x01\x12\x04\x8f\x03\x08\x17\n\x92\x01\n\x04\x04\x04\x02\0\x12\x04\x93\
    \x03\x02#\x1a\x83\x01\x20The\x20Trip\x20that\x20this\x20vehicle\x20is\
    \x20serving.\n\x20Can\x20be\x20empty\x20or\x20partial\x20if\x20the\x20ve\
    hicle\x20can\x20not\x20be\x20identified\x20with\x20a\x20given\n\x20trip\
    \x20instance.\n\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\x93\x03\x02\n\n\r\n\
    \x05\x04\x04\x02\0\x06\x12\x04\x93\x03\x0b\x19\n\r\n\x05\x04\x04\x02\0\
    \x01\x12\x04\x93\x03\x1a\x1e\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x93\x03\
    !\"\nP\n\x04\x04\x04\x02\x01\x12\x04\x96\x03\x02)\x1aB\x20Additional\x20\
    information\x20on\x20the\x20vehicle\x20that\x20is\x20serving\x20this\x20\
    trip.\n\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\x96\x03\x02\n\n\r\n\x05\
    \x04\x04\x02\x01\x06\x12\x04\x96\x03\x0b\x1c\n\r\n\x05\x04\x04\x02\x01\
    \x01\x12\x04\x96\x03\x1d$\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x96\x03'\
    (\n1\n\x04\x04\x04\x02\x02\x12\x04\x99\x03\x02!\x1a#\x20Current\x20posit\
    ion\x20of\x20this\x20vehicle.\n\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\
    \x99\x03\x02\n\n\r\n\x05\x04\x04\x02\x02\x06\x12\x04\x99\x03\x0b\x13\n\r\
    \n\x05\x04\x04\x02\x02\x01\x12\x04\x99\x03\x14\x1c\n\r\n\x05\x04\x04\x02\
    \x02\x03\x12\x04\x99\x03\x1f\x20\n\xe0\x01\n\x04\x04\x04\x02\x03\x12\x04\
    \x9f\x03\x02,\x1a\xd1\x01\x20The\x20stop\x20sequence\x20index\x20of\x20t\
    he\x20current\x20stop.\x20The\x20meaning\x20of\n\x20current_stop_sequenc\
    e\x20(i.e.,\x20the\x20stop\x20that\x20it\x20refers\x20to)\x20is\x20deter\
    mined\x20by\n\x20current_status.\n\x20If\x20current_status\x20is\x20miss\
    ing\x20IN_TRANSIT_TO\x20is\x20assumed.\n\n\r\n\x05\x04\x04\x02\x03\x04\
    \x12\x04\x9f\x03\x02\n\n\r\n\x05\x04\x04\x02\x03\x05\x12\x04\x9f\x03\x0b\
    \x11\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\x9f\x03\x12'\n\r\n\x05\x04\
    \x04\x02\x03\x03\x12\x04\x9f\x03*+\nx\n\x04\x04\x04\x02\x04\x12\x04\xa2\
    \x03\x02\x1e\x1aj\x20Identifies\x20the\x20current\x20stop.\x20The\x20val\
    ue\x20must\x20be\x20the\x20same\x20as\x20in\x20stops.txt\x20in\n\x20the\
    \x20corresponding\x20GTFS\x20feed.\n\n\r\n\x05\x04\x04\x02\x04\x04\x12\
    \x04\xa2\x03\x02\n\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\xa2\x03\x0b\x11\
    \n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\xa2\x03\x12\x19\n\r\n\x05\x04\x04\
    \x02\x04\x03\x12\x04\xa2\x03\x1c\x1d\n\x0e\n\x04\x04\x04\x04\0\x12\x06\
    \xa4\x03\x02\xae\x03\x03\n\r\n\x05\x04\x04\x04\0\x01\x12\x04\xa4\x03\x07\
    \x18\n}\n\x06\x04\x04\x04\0\x02\0\x12\x04\xa7\x03\x04\x14\x1am\x20The\
    \x20vehicle\x20is\x20just\x20about\x20to\x20arrive\x20at\x20the\x20stop\
    \x20(on\x20a\x20stop\n\x20display,\x20the\x20vehicle\x20symbol\x20typica\
    lly\x20flashes).\n\n\x0f\n\x07\x04\x04\x04\0\x02\0\x01\x12\x04\xa7\x03\
    \x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\0\x02\x12\x04\xa7\x03\x12\x13\n6\
    \n\x06\x04\x04\x04\0\x02\x01\x12\x04\xaa\x03\x04\x13\x1a&\x20The\x20vehi\
    cle\x20is\x20standing\x20at\x20the\x20stop.\n\n\x0f\n\x07\x04\x04\x04\0\
    \x02\x01\x01\x12\x04\xaa\x03\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\x01\
    \x02\x12\x04\xaa\x03\x11\x12\nN\n\x06\x04\x04\x04\0\x02\x02\x12\x04\xad\
    \x03\x04\x16\x1a>\x20The\x20vehicle\x20has\x20departed\x20and\x20is\x20i\
    n\x20transit\x20to\x20the\x20next\x20stop.\n\n\x0f\n\x07\x04\x04\x04\0\
    \x02\x02\x01\x12\x04\xad\x03\x04\x11\n\x0f\n\x07\x04\x04\x04\0\x02\x02\
    \x02\x12\x04\xad\x03\x14\x15\n\x7f\n\x04\x04\x04\x02\x05\x12\x04\xb1\x03\
    \x02J\x1aq\x20The\x20exact\x20status\x20of\x20the\x20vehicle\x20with\x20\
    respect\x20to\x20the\x20current\x20stop.\n\x20Ignored\x20if\x20current_s\
    top_sequence\x20is\x20missing.\n\n\r\n\x05\x04\x04\x02\x05\x04\x12\x04\
    \xb1\x03\x02\n\n\r\n\x05\x04\x04\x02\x05\x06\x12\x04\xb1\x03\x0b\x1c\n\r\
    \n\x05\x04\x04\x02\x05\x01\x12\x04\xb1\x03\x1d+\n\r\n\x05\x04\x04\x02\
    \x05\x03\x12\x04\xb1\x03./\n\r\n\x05\x04\x04\x02\x05\x08\x12\x04\xb1\x03\
    0I\n\r\n\x05\x04\x04\x02\x05\x07\x12\x04\xb1\x03;H\n\x93\x01\n\x04\x04\
    \x04\x02\x06\x12\x04\xb5\x03\x02\x20\x1a\x84\x01\x20Moment\x20at\x20whic\
    h\x20the\x20vehicle's\x20position\x20was\x20measured.\x20In\x20POSIX\x20\
    time\n\x20(i.e.,\x20number\x20of\x20seconds\x20since\x20January\x201st\
    \x201970\x2000:00:00\x20UTC).\n\n\r\n\x05\x04\x04\x02\x06\x04\x12\x04\
    \xb5\x03\x02\n\n\r\n\x05\x04\x04\x02\x06\x05\x12\x04\xb5\x03\x0b\x11\n\r\
    \n\x05\x04\x04\x02\x06\x01\x12\x04\xb5\x03\x12\x1b\n\r\n\x05\x04\x04\x02\
    \x06\x03\x12\x04\xb5\x03\x1e\x1f\nB\n\x04\x04\x04\x04\x01\x12\x06\xb8\
    \x03\x02\xbe\x03\x03\x1a2\x20Congestion\x20level\x20that\x20is\x20affect\
    ing\x20this\x20vehicle.\n\n\r\n\x05\x04\x04\x04\x01\x01\x12\x04\xb8\x03\
    \x07\x16\n\x0e\n\x06\x04\x04\x04\x01\x02\0\x12\x04\xb9\x03\x04!\n\x0f\n\
    \x07\x04\x04\x04\x01\x02\0\x01\x12\x04\xb9\x03\x04\x1c\n\x0f\n\x07\x04\
    \x04\x04\x01\x02\0\x02\x12\x04\xb9\x03\x1f\x20\n\x0e\n\x06\x04\x04\x04\
    \x01\x02\x01\x12\x04\xba\x03\x04\x19\n\x0f\n\x07\x04\x04\x04\x01\x02\x01\
    \x01\x12\x04\xba\x03\x04\x14\n\x0f\n\x07\x04\x04\x04\x01\x02\x01\x02\x12\
    \x04\xba\x03\x17\x18\n\x0e\n\x06\x04\x04\x04\x01\x02\x02\x12\x04\xbb\x03\
    \x04\x14\n\x0f\n\x07\x04\x04\x04\x01\x02\x02\x01\x12\x04\xbb\x03\x04\x0f\
    \n\x0f\n\x07\x04\x04\x04\x01\x02\x02\x02\x12\x04\xbb\x03\x12\x13\n\x0e\n\
    \x06\x04\x04\x04\x01\x02\x03\x12\x04\xbc\x03\x04\x13\n\x0f\n\x07\x04\x04\
    \x04\x01\x02\x03\x01\x12\x04\xbc\x03\x04\x0e\n\x0f\n\x07\x04\x04\x04\x01\
    \x02\x03\x02\x12\x04\xbc\x03\x11\x12\n,\n\x06\x04\x04\x04\x01\x02\x04\
    \x12\x04\xbd\x03\x04\x1a\"\x1c\x20People\x20leaving\x20their\x20cars.\n\
    \n\x0f\n\x07\x04\x04\x04\x01\x02\x04\x01\x12\x04\xbd\x03\x04\x15\n\x0f\n\
    \x07\x04\x04\x04\x01\x02\x04\x02\x12\x04\xbd\x03\x18\x19\n\x0c\n\x04\x04\
    \x04\x02\x07\x12\x04\xbf\x03\x020\n\r\n\x05\x04\x04\x02\x07\x04\x12\x04\
    \xbf\x03\x02\n\n\r\n\x05\x04\x04\x02\x07\x06\x12\x04\xbf\x03\x0b\x1a\n\r\
    \n\x05\x04\x04\x02\x07\x01\x12\x04\xbf\x03\x1b+\n\r\n\x05\x04\x04\x02\
    \x07\x03\x12\x04\xbf\x03./\n\x80\x05\n\x04\x04\x04\x04\x02\x12\x06\xc9\
    \x03\x02\xef\x03\x03\x1a\xef\x04\x20The\x20state\x20of\x20passenger\x20o\
    ccupancy\x20for\x20the\x20vehicle\x20or\x20carriage.\n\x20Individual\x20\
    producers\x20may\x20not\x20publish\x20all\x20OccupancyStatus\x20values.\
    \x20Therefore,\x20consumers\n\x20must\x20not\x20assume\x20that\x20the\
    \x20OccupancyStatus\x20values\x20follow\x20a\x20linear\x20scale.\n\x20Co\
    nsumers\x20should\x20represent\x20OccupancyStatus\x20values\x20as\x20the\
    \x20state\x20indicated\x20\n\x20and\x20intended\x20by\x20the\x20producer\
    .\x20Likewise,\x20producers\x20must\x20use\x20OccupancyStatus\x20values\
    \x20that\n\x20correspond\x20to\x20actual\x20vehicle\x20occupancy\x20stat\
    es.\n\x20For\x20describing\x20passenger\x20occupancy\x20levels\x20on\x20\
    a\x20linear\x20scale,\x20see\x20`occupancy_percentage`.\n\x20This\x20fie\
    ld\x20is\x20still\x20experimental,\x20and\x20subject\x20to\x20change.\
    \x20It\x20may\x20be\x20formally\x20adopted\x20in\x20the\x20future.\n\n\r\
    \n\x05\x04\x04\x04\x02\x01\x12\x04\xc9\x03\x07\x16\n\x9a\x01\n\x06\x04\
    \x04\x04\x02\x02\0\x12\x04\xcc\x03\x04\x0e\x1a\x89\x01\x20The\x20vehicle\
    \x20or\x20carriage\x20is\x20considered\x20empty\x20by\x20most\x20measure\
    s,\x20and\x20has\x20few\x20or\x20no\n\x20passengers\x20onboard,\x20but\
    \x20is\x20still\x20accepting\x20passengers.\n\n\x0f\n\x07\x04\x04\x04\
    \x02\x02\0\x01\x12\x04\xcc\x03\x04\t\n\x0f\n\x07\x04\x04\x04\x02\x02\0\
    \x02\x12\x04\xcc\x03\x0c\r\n\xf8\x01\n\x06\x04\x04\x04\x02\x02\x01\x12\
    \x04\xd2\x03\x04\x1d\x1a\xe7\x01\x20The\x20vehicle\x20or\x20carriage\x20\
    has\x20a\x20large\x20number\x20of\x20seats\x20available.\n\x20The\x20amo\
    unt\x20of\x20free\x20seats\x20out\x20of\x20the\x20total\x20seats\x20avai\
    lable\x20to\x20be\n\x20considered\x20large\x20enough\x20to\x20fall\x20in\
    to\x20this\x20category\x20is\x20determined\x20at\x20the\n\x20discretion\
    \x20of\x20the\x20producer.\n\n\x0f\n\x07\x04\x04\x04\x02\x02\x01\x01\x12\
    \x04\xd2\x03\x04\x18\n\x0f\n\x07\x04\x04\x04\x02\x02\x01\x02\x12\x04\xd2\
    \x03\x1b\x1c\n\x88\x02\n\x06\x04\x04\x04\x02\x02\x02\x12\x04\xd8\x03\x04\
    \x1c\x1a\xf7\x01\x20The\x20vehicle\x20or\x20carriage\x20has\x20a\x20rela\
    tively\x20small\x20number\x20of\x20seats\x20available.\n\x20The\x20amoun\
    t\x20of\x20free\x20seats\x20out\x20of\x20the\x20total\x20seats\x20availa\
    ble\x20to\x20be\n\x20considered\x20small\x20enough\x20to\x20fall\x20into\
    \x20this\x20category\x20is\x20determined\x20at\x20the\n\x20discretion\
    \x20of\x20the\x20feed\x20producer.\n\n\x0f\n\x07\x04\x04\x04\x02\x02\x02\
    \x01\x12\x04\xd8\x03\x04\x17\n\x0f\n\x07\x04\x04\x04\x02\x02\x02\x02\x12\
    \x04\xd8\x03\x1a\x1b\n]\n\x06\x04\x04\x04\x02\x02\x03\x12\x04\xdb\x03\
    \x04\x1b\x1aM\x20The\x20vehicle\x20or\x20carriage\x20can\x20currently\
    \x20accommodate\x20only\x20standing\x20passengers.\n\n\x0f\n\x07\x04\x04\
    \x04\x02\x02\x03\x01\x12\x04\xdb\x03\x04\x16\n\x0f\n\x07\x04\x04\x04\x02\
    \x02\x03\x02\x12\x04\xdb\x03\x19\x1a\n}\n\x06\x04\x04\x04\x02\x02\x04\
    \x12\x04\xdf\x03\x04#\x1am\x20The\x20vehicle\x20or\x20carriage\x20can\
    \x20currently\x20accommodate\x20only\x20standing\x20passengers\n\x20and\
    \x20has\x20limited\x20space\x20for\x20them.\n\n\x0f\n\x07\x04\x04\x04\
    \x02\x02\x04\x01\x12\x04\xdf\x03\x04\x1e\n\x0f\n\x07\x04\x04\x04\x02\x02\
    \x04\x02\x12\x04\xdf\x03!\"\n~\n\x06\x04\x04\x04\x02\x02\x05\x12\x04\xe3\
    \x03\x04\r\x1an\x20The\x20vehicle\x20or\x20carriage\x20is\x20considered\
    \x20full\x20by\x20most\x20measures,\x20but\x20may\x20still\x20be\n\x20al\
    lowing\x20passengers\x20to\x20board.\n\n\x0f\n\x07\x04\x04\x04\x02\x02\
    \x05\x01\x12\x04\xe3\x03\x04\x08\n\x0f\n\x07\x04\x04\x04\x02\x02\x05\x02\
    \x12\x04\xe3\x03\x0b\x0c\ns\n\x06\x04\x04\x04\x02\x02\x06\x12\x04\xe6\
    \x03\x04!\x1ac\x20The\x20vehicle\x20or\x20carriage\x20is\x20not\x20accep\
    ting\x20passengers,\x20but\x20usually\x20accepts\x20passengers\x20for\
    \x20boarding.\n\n\x0f\n\x07\x04\x04\x04\x02\x02\x06\x01\x12\x04\xe6\x03\
    \x04\x1c\n\x0f\n\x07\x04\x04\x04\x02\x02\x06\x02\x12\x04\xe6\x03\x1f\x20\
    \na\n\x06\x04\x04\x04\x02\x02\x07\x12\x04\xe9\x03\x04\x1a\x1aQ\x20The\
    \x20vehicle\x20or\x20carriage\x20doesn't\x20have\x20any\x20occupancy\x20\
    data\x20available\x20at\x20that\x20time.\n\n\x0f\n\x07\x04\x04\x04\x02\
    \x02\x07\x01\x12\x04\xe9\x03\x04\x15\n\x0f\n\x07\x04\x04\x04\x02\x02\x07\
    \x02\x12\x04\xe9\x03\x18\x19\n\xab\x01\n\x06\x04\x04\x04\x02\x02\x08\x12\
    \x04\xed\x03\x04\x16\x1a\x9a\x01\x20The\x20vehicle\x20or\x20carriage\x20\
    is\x20not\x20boardable\x20and\x20never\x20accepts\x20passengers.\n\x20Us\
    eful\x20for\x20special\x20vehicles\x20or\x20carriages\x20(engine,\x20mai\
    ntenance\x20carriage,\x20etc\xe2\x80\xa6).\n\n\x0f\n\x07\x04\x04\x04\x02\
    \x02\x08\x01\x12\x04\xed\x03\x04\x11\n\x0f\n\x07\x04\x04\x04\x02\x02\x08\
    \x02\x12\x04\xed\x03\x14\x15\n\xc1\x01\n\x04\x04\x04\x02\x08\x12\x04\xf2\
    \x03\x020\x1a\xb2\x01\x20If\x20multi_carriage_status\x20is\x20populated\
    \x20with\x20per-carriage\x20OccupancyStatus,\n\x20then\x20this\x20field\
    \x20should\x20describe\x20the\x20entire\x20vehicle\x20with\x20all\x20car\
    riages\x20accepting\x20passengers\x20considered.\n\n\r\n\x05\x04\x04\x02\
    \x08\x04\x12\x04\xf2\x03\x02\n\n\r\n\x05\x04\x04\x02\x08\x06\x12\x04\xf2\
    \x03\x0b\x1a\n\r\n\x05\x04\x04\x02\x08\x01\x12\x04\xf2\x03\x1b+\n\r\n\
    \x05\x04\x04\x02\x08\x03\x12\x04\xf2\x03./\n\xef\x06\n\x04\x04\x04\x02\t\
    \x12\x04\xfd\x03\x02,\x1a\xe0\x06\x20A\x20percentage\x20value\x20indicat\
    ing\x20the\x20degree\x20of\x20passenger\x20occupancy\x20in\x20the\x20veh\
    icle.\n\x20The\x20values\x20are\x20represented\x20as\x20an\x20integer\
    \x20without\x20decimals.\x200\x20means\x200%\x20and\x20100\x20means\x201\
    00%.\n\x20The\x20value\x20100\x20should\x20represent\x20the\x20total\x20\
    maximum\x20occupancy\x20the\x20vehicle\x20was\x20designed\x20for,\n\x20i\
    ncluding\x20both\x20seated\x20and\x20standing\x20capacity,\x20and\x20cur\
    rent\x20operating\x20regulations\x20allow.\n\x20The\x20value\x20may\x20e\
    xceed\x20100\x20if\x20there\x20are\x20more\x20passengers\x20than\x20the\
    \x20maximum\x20designed\x20capacity.\n\x20The\x20precision\x20of\x20occu\
    pancy_percentage\x20should\x20be\x20low\x20enough\x20that\x20individual\
    \x20passengers\x20cannot\x20be\x20tracked\x20boarding\x20or\x20alighting\
    \x20the\x20vehicle.\n\x20If\x20multi_carriage_status\x20is\x20populated\
    \x20with\x20per-carriage\x20occupancy_percentage,\x20\n\x20then\x20this\
    \x20field\x20should\x20describe\x20the\x20entire\x20vehicle\x20with\x20a\
    ll\x20carriages\x20accepting\x20passengers\x20considered.\n\x20This\x20f\
    ield\x20is\x20still\x20experimental,\x20and\x20subject\x20to\x20change.\
    \x20It\x20may\x20be\x20formally\x20adopted\x20in\x20the\x20future.\n\n\r\
    \n\x05\x04\x04\x02\t\x04\x12\x04\xfd\x03\x02\n\n\r\n\x05\x04\x04\x02\t\
    \x05\x12\x04\xfd\x03\x0b\x11\n\r\n\x05\x04\x04\x02\t\x01\x12\x04\xfd\x03\
    \x12&\n\r\n\x05\x04\x04\x02\t\x03\x12\x04\xfd\x03)+\n\xc9\x01\n\x04\x04\
    \x04\x03\0\x12\x06\x81\x04\x02\xa9\x04\x03\x1a\xb8\x01\x20Carriage\x20sp\
    ecific\x20details,\x20used\x20for\x20vehicles\x20composed\x20of\x20sever\
    al\x20carriages\n\x20This\x20message/field\x20is\x20still\x20experimenta\
    l,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\x20formally\x20\
    adopted\x20in\x20the\x20future.\n\n\r\n\x05\x04\x04\x03\0\x01\x12\x04\
    \x81\x04\n\x19\nO\n\x06\x04\x04\x03\0\x02\0\x12\x04\x84\x04\x04\x1b\x1a?\
    \x20Identification\x20of\x20the\x20carriage.\x20Should\x20be\x20unique\
    \x20per\x20vehicle.\n\n\x0f\n\x07\x04\x04\x03\0\x02\0\x04\x12\x04\x84\
    \x04\x04\x0c\n\x0f\n\x07\x04\x04\x03\0\x02\0\x05\x12\x04\x84\x04\r\x13\n\
    \x0f\n\x07\x04\x04\x03\0\x02\0\x01\x12\x04\x84\x04\x14\x16\n\x0f\n\x07\
    \x04\x04\x03\0\x02\0\x03\x12\x04\x84\x04\x19\x1a\n\xfa\x01\n\x06\x04\x04\
    \x03\0\x02\x01\x12\x04\x89\x04\x04\x1e\x1a\xe9\x01\x20User\x20visible\
    \x20label\x20that\x20may\x20be\x20shown\x20to\x20the\x20passenger\x20to\
    \x20help\x20identify\n\x20the\x20carriage.\x20Example:\x20\"7712\",\x20\
    \"Car\x20ABC-32\",\x20etc...\n\x20This\x20message/field\x20is\x20still\
    \x20experimental,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\
    \x20formally\x20adopted\x20in\x20the\x20future.\n\n\x0f\n\x07\x04\x04\
    \x03\0\x02\x01\x04\x12\x04\x89\x04\x04\x0c\n\x0f\n\x07\x04\x04\x03\0\x02\
    \x01\x05\x12\x04\x89\x04\r\x13\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x01\x12\
    \x04\x89\x04\x14\x19\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x03\x12\x04\x89\
    \x04\x1c\x1d\n\xb8\x01\n\x06\x04\x04\x03\0\x02\x02\x12\x04\x8d\x04\x04P\
    \x1a\xa7\x01\x20Occupancy\x20status\x20for\x20this\x20given\x20carriage,\
    \x20in\x20this\x20vehicle\n\x20This\x20message/field\x20is\x20still\x20e\
    xperimental,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\x20fo\
    rmally\x20adopted\x20in\x20the\x20future.\n\n\x0f\n\x07\x04\x04\x03\0\
    \x02\x02\x04\x12\x04\x8d\x04\x04\x0c\n\x0f\n\x07\x04\x04\x03\0\x02\x02\
    \x06\x12\x04\x8d\x04\r\x1c\n\x0f\n\x07\x04\x04\x03\0\x02\x02\x01\x12\x04\
    \x8d\x04\x1d-\n\x0f\n\x07\x04\x04\x03\0\x02\x02\x03\x12\x04\x8d\x0401\n\
    \x0f\n\x07\x04\x04\x03\0\x02\x02\x08\x12\x04\x8d\x042O\n\x0f\n\x07\x04\
    \x04\x03\0\x02\x02\x07\x12\x04\x8d\x04=N\n\xdf\x02\n\x06\x04\x04\x03\0\
    \x02\x03\x12\x04\x93\x04\x04;\x1a\xce\x02\x20Occupancy\x20percentage\x20\
    for\x20this\x20given\x20carriage,\x20in\x20this\x20vehicle.\n\x20Follows\
    \x20the\x20same\x20rules\x20as\x20\"VehiclePosition.occupancy_percentage\
    \"\n\x20-1\x20in\x20case\x20data\x20is\x20not\x20available\x20for\x20thi\
    s\x20given\x20carriage\x20(as\x20protobuf\x20defaults\x20to\x200\x20othe\
    rwise)\n\x20This\x20message/field\x20is\x20still\x20experimental,\x20and\
    \x20subject\x20to\x20change.\x20It\x20may\x20be\x20formally\x20adopted\
    \x20in\x20the\x20future.\n\n\x0f\n\x07\x04\x04\x03\0\x02\x03\x04\x12\x04\
    \x93\x04\x04\x0c\n\x0f\n\x07\x04\x04\x03\0\x02\x03\x05\x12\x04\x93\x04\r\
    \x12\n\x0f\n\x07\x04\x04\x03\0\x02\x03\x01\x12\x04\x93\x04\x13'\n\x0f\n\
    \x07\x04\x04\x03\0\x02\x03\x03\x12\x04\x93\x04*+\n\x0f\n\x07\x04\x04\x03\
    \0\x02\x03\x08\x12\x04\x93\x04,:\n\x0f\n\x07\x04\x04\x03\0\x02\x03\x07\
    \x12\x04\x93\x0479\n\xf7\x06\n\x06\x04\x04\x03\0\x02\x04\x12\x04\xa0\x04\
    \x04*\x1a\xe6\x06\x20Identifies\x20the\x20order\x20of\x20this\x20carriag\
    e\x20with\x20respect\x20to\x20the\x20other\n\x20carriages\x20in\x20the\
    \x20vehicle's\x20list\x20of\x20CarriageDetails.\n\x20The\x20first\x20car\
    riage\x20in\x20the\x20direction\x20of\x20travel\x20must\x20have\x20a\x20\
    value\x20of\x201.\n\x20The\x20second\x20value\x20corresponds\x20to\x20th\
    e\x20second\x20carriage\x20in\x20the\x20direction\n\x20of\x20travel\x20a\
    nd\x20must\x20have\x20a\x20value\x20of\x202,\x20and\x20so\x20forth.\n\
    \x20For\x20example,\x20the\x20first\x20carriage\x20in\x20the\x20directio\
    n\x20of\x20travel\x20has\x20a\x20value\x20of\x201.\n\x20If\x20the\x20sec\
    ond\x20carriage\x20in\x20the\x20direction\x20of\x20travel\x20has\x20a\
    \x20value\x20of\x203,\n\x20consumers\x20will\x20discard\x20data\x20for\
    \x20all\x20carriages\x20(i.e.,\x20the\x20multi_carriage_details\x20field\
    ).\n\x20Carriages\x20without\x20data\x20must\x20be\x20represented\x20wit\
    h\x20a\x20valid\x20carriage_sequence\x20number\x20and\x20the\x20fields\
    \x20\n\x20without\x20data\x20should\x20be\x20omitted\x20(alternately,\
    \x20those\x20fields\x20could\x20also\x20be\x20included\x20and\x20set\x20\
    to\x20the\x20\"no\x20data\"\x20values).\n\x20This\x20message/field\x20is\
    \x20still\x20experimental,\x20and\x20subject\x20to\x20change.\x20It\x20m\
    ay\x20be\x20formally\x20adopted\x20in\x20the\x20future.\n\n\x0f\n\x07\
    \x04\x04\x03\0\x02\x04\x04\x12\x04\xa0\x04\x04\x0c\n\x0f\n\x07\x04\x04\
    \x03\0\x02\x04\x05\x12\x04\xa0\x04\r\x13\n\x0f\n\x07\x04\x04\x03\0\x02\
    \x04\x01\x12\x04\xa0\x04\x14%\n\x0f\n\x07\x04\x04\x03\0\x02\x04\x03\x12\
    \x04\xa0\x04()\n\xbb\x01\n\x05\x04\x04\x03\0\x05\x12\x04\xa5\x04\x04\x1c\
    \x1a\xab\x01\x20The\x20extensions\x20namespace\x20allows\x203rd-party\
    \x20developers\x20to\x20extend\x20the\n\x20GTFS\x20Realtime\x20Specifica\
    tion\x20in\x20order\x20to\x20add\x20and\x20evaluate\x20new\x20features\
    \x20and\n\x20modifications\x20to\x20the\x20spec.\n\n\x0e\n\x06\x04\x04\
    \x03\0\x05\0\x12\x04\xa5\x04\x0f\x1b\n\x0f\n\x07\x04\x04\x03\0\x05\0\x01\
    \x12\x04\xa5\x04\x0f\x13\n\x0f\n\x07\x04\x04\x03\0\x05\0\x02\x12\x04\xa5\
    \x04\x17\x1b\n^\n\x05\x04\x04\x03\0\x05\x12\x04\xa8\x04\x04\x1c\x1aO\x20\
    The\x20following\x20extension\x20IDs\x20are\x20reserved\x20for\x20privat\
    e\x20use\x20by\x20any\x20organization.\n\n\x0e\n\x06\x04\x04\x03\0\x05\
    \x01\x12\x04\xa8\x04\x0f\x1b\n\x0f\n\x07\x04\x04\x03\0\x05\x01\x01\x12\
    \x04\xa8\x04\x0f\x13\n\x0f\n\x07\x04\x04\x03\0\x05\x01\x02\x12\x04\xa8\
    \x04\x17\x1b\n\xc9\x04\n\x04\x04\x04\x02\n\x12\x04\xb4\x04\x027\x1a\xba\
    \x04\x20Details\x20of\x20the\x20multiple\x20carriages\x20of\x20this\x20g\
    iven\x20vehicle.\n\x20The\x20first\x20occurrence\x20represents\x20the\
    \x20first\x20carriage\x20of\x20the\x20vehicle,\x20\n\x20given\x20the\x20\
    current\x20direction\x20of\x20travel.\x20\n\x20The\x20number\x20of\x20oc\
    currences\x20of\x20the\x20multi_carriage_details\x20\n\x20field\x20repre\
    sents\x20the\x20number\x20of\x20carriages\x20of\x20the\x20vehicle.\n\x20\
    It\x20also\x20includes\x20non\x20boardable\x20carriages,\x20\n\x20like\
    \x20engines,\x20maintenance\x20carriages,\x20etc\xe2\x80\xa6\x20as\x20th\
    ey\x20provide\x20valuable\x20\n\x20information\x20to\x20passengers\x20ab\
    out\x20where\x20to\x20stand\x20on\x20a\x20platform.\n\x20This\x20message\
    /field\x20is\x20still\x20experimental,\x20and\x20subject\x20to\x20change\
    .\x20It\x20may\x20be\x20formally\x20adopted\x20in\x20the\x20future.\n\n\
    \r\n\x05\x04\x04\x02\n\x04\x12\x04\xb4\x04\x02\n\n\r\n\x05\x04\x04\x02\n\
    \x06\x12\x04\xb4\x04\x0b\x1a\n\r\n\x05\x04\x04\x02\n\x01\x12\x04\xb4\x04\
    \x1b1\n\r\n\x05\x04\x04\x02\n\x03\x12\x04\xb4\x0446\n\xb9\x01\n\x03\x04\
    \x04\x05\x12\x04\xb9\x04\x02\x1a\x1a\xab\x01\x20The\x20extensions\x20nam\
    espace\x20allows\x203rd-party\x20developers\x20to\x20extend\x20the\n\x20\
    GTFS\x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20and\x20\
    evaluate\x20new\x20features\x20and\n\x20modifications\x20to\x20the\x20sp\
    ec.\n\n\x0c\n\x04\x04\x04\x05\0\x12\x04\xb9\x04\r\x19\n\r\n\x05\x04\x04\
    \x05\0\x01\x12\x04\xb9\x04\r\x11\n\r\n\x05\x04\x04\x05\0\x02\x12\x04\xb9\
    \x04\x15\x19\n\\\n\x03\x04\x04\x05\x12\x04\xbc\x04\x02\x1a\x1aO\x20The\
    \x20following\x20extension\x20IDs\x20are\x20reserved\x20for\x20private\
    \x20use\x20by\x20any\x20organization.\n\n\x0c\n\x04\x04\x04\x05\x01\x12\
    \x04\xbc\x04\r\x19\n\r\n\x05\x04\x04\x05\x01\x01\x12\x04\xbc\x04\r\x11\n\
    \r\n\x05\x04\x04\x05\x01\x02\x12\x04\xbc\x04\x15\x19\nY\n\x02\x04\x05\
    \x12\x06\xc0\x04\0\xa3\x05\x01\x1aK\x20An\x20alert,\x20indicating\x20som\
    e\x20sort\x20of\x20incident\x20in\x20the\x20public\x20transit\x20network\
    .\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xc0\x04\x08\r\n\xd4\x01\n\x04\x04\
    \x05\x02\0\x12\x04\xc4\x04\x02'\x1a\xc5\x01\x20Time\x20when\x20the\x20al\
    ert\x20should\x20be\x20shown\x20to\x20the\x20user.\x20If\x20missing,\x20\
    the\n\x20alert\x20will\x20be\x20shown\x20as\x20long\x20as\x20it\x20appea\
    rs\x20in\x20the\x20feed.\n\x20If\x20multiple\x20ranges\x20are\x20given,\
    \x20the\x20alert\x20will\x20be\x20shown\x20during\x20all\x20of\x20them.\
    \n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xc4\x04\x02\n\n\r\n\x05\x04\x05\
    \x02\0\x06\x12\x04\xc4\x04\x0b\x14\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\
    \xc4\x04\x15\"\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xc4\x04%&\nD\n\x04\
    \x04\x05\x02\x01\x12\x04\xc7\x04\x02.\x1a6\x20Entities\x20whose\x20users\
    \x20we\x20should\x20notify\x20of\x20this\x20alert.\n\n\r\n\x05\x04\x05\
    \x02\x01\x04\x12\x04\xc7\x04\x02\n\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\
    \xc7\x04\x0b\x19\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xc7\x04\x1a)\n\r\
    \n\x05\x04\x05\x02\x01\x03\x12\x04\xc7\x04,-\ne\n\x04\x04\x05\x04\0\x12\
    \x06\xca\x04\x02\xd7\x04\x03\x1aU\x20Cause\x20of\x20this\x20alert.\x20If\
    \x20cause_detail\x20is\x20included,\x20then\x20Cause\x20must\x20also\x20\
    be\x20included.\n\n\r\n\x05\x04\x05\x04\0\x01\x12\x04\xca\x04\x07\x0c\n\
    \x0e\n\x06\x04\x05\x04\0\x02\0\x12\x04\xcb\x04\x04\x16\n\x0f\n\x07\x04\
    \x05\x04\0\x02\0\x01\x12\x04\xcb\x04\x04\x11\n\x0f\n\x07\x04\x05\x04\0\
    \x02\0\x02\x12\x04\xcb\x04\x14\x15\n,\n\x06\x04\x05\x04\0\x02\x01\x12\
    \x04\xcc\x04\x04\x14\"\x1c\x20Not\x20machine-representable.\n\n\x0f\n\
    \x07\x04\x05\x04\0\x02\x01\x01\x12\x04\xcc\x04\x04\x0f\n\x0f\n\x07\x04\
    \x05\x04\0\x02\x01\x02\x12\x04\xcc\x04\x12\x13\n\x0e\n\x06\x04\x05\x04\0\
    \x02\x02\x12\x04\xcd\x04\x04\x1a\n\x0f\n\x07\x04\x05\x04\0\x02\x02\x01\
    \x12\x04\xcd\x04\x04\x15\n\x0f\n\x07\x04\x05\x04\0\x02\x02\x02\x12\x04\
    \xcd\x04\x18\x19\nB\n\x06\x04\x05\x04\0\x02\x03\x12\x04\xce\x04\x04\x0f\
    \"2\x20Public\x20transit\x20agency\x20employees\x20stopped\x20working.\n\
    \n\x0f\n\x07\x04\x05\x04\0\x02\x03\x01\x12\x04\xce\x04\x04\n\n\x0f\n\x07\
    \x04\x05\x04\0\x02\x03\x02\x12\x04\xce\x04\r\x0e\n2\n\x06\x04\x05\x04\0\
    \x02\x04\x12\x04\xcf\x04\x04\x16\"\"\x20People\x20are\x20blocking\x20the\
    \x20streets.\n\n\x0f\n\x07\x04\x05\x04\0\x02\x04\x01\x12\x04\xcf\x04\x04\
    \x11\n\x0f\n\x07\x04\x05\x04\0\x02\x04\x02\x12\x04\xcf\x04\x14\x15\n\x0e\
    \n\x06\x04\x05\x04\0\x02\x05\x12\x04\xd0\x04\x04\x11\n\x0f\n\x07\x04\x05\
    \x04\0\x02\x05\x01\x12\x04\xd0\x04\x04\x0c\n\x0f\n\x07\x04\x05\x04\0\x02\
    \x05\x02\x12\x04\xd0\x04\x0f\x10\n\x0e\n\x06\x04\x05\x04\0\x02\x06\x12\
    \x04\xd1\x04\x04\x10\n\x0f\n\x07\x04\x05\x04\0\x02\x06\x01\x12\x04\xd1\
    \x04\x04\x0b\n\x0f\n\x07\x04\x05\x04\0\x02\x06\x02\x12\x04\xd1\x04\x0e\
    \x0f\n\x0e\n\x06\x04\x05\x04\0\x02\x07\x12\x04\xd2\x04\x04\x10\n\x0f\n\
    \x07\x04\x05\x04\0\x02\x07\x01\x12\x04\xd2\x04\x04\x0b\n\x0f\n\x07\x04\
    \x05\x04\0\x02\x07\x02\x12\x04\xd2\x04\x0e\x0f\n\x0e\n\x06\x04\x05\x04\0\
    \x02\x08\x12\x04\xd3\x04\x04\x14\n\x0f\n\x07\x04\x05\x04\0\x02\x08\x01\
    \x12\x04\xd3\x04\x04\x0f\n\x0f\n\x07\x04\x05\x04\0\x02\x08\x02\x12\x04\
    \xd3\x04\x12\x13\n\x0e\n\x06\x04\x05\x04\0\x02\t\x12\x04\xd4\x04\x04\x16\
    \n\x0f\n\x07\x04\x05\x04\0\x02\t\x01\x12\x04\xd4\x04\x04\x10\n\x0f\n\x07\
    \x04\x05\x04\0\x02\t\x02\x12\x04\xd4\x04\x13\x15\n\x0e\n\x06\x04\x05\x04\
    \0\x02\n\x12\x04\xd5\x04\x04\x19\n\x0f\n\x07\x04\x05\x04\0\x02\n\x01\x12\
    \x04\xd5\x04\x04\x13\n\x0f\n\x07\x04\x05\x04\0\x02\n\x02\x12\x04\xd5\x04\
    \x16\x18\n\x0e\n\x06\x04\x05\x04\0\x02\x0b\x12\x04\xd6\x04\x04\x1b\n\x0f\
    \n\x07\x04\x05\x04\0\x02\x0b\x01\x12\x04\xd6\x04\x04\x15\n\x0f\n\x07\x04\
    \x05\x04\0\x02\x0b\x02\x12\x04\xd6\x04\x18\x1a\n\x0c\n\x04\x04\x05\x02\
    \x02\x12\x04\xd8\x04\x025\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\xd8\x04\
    \x02\n\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\xd8\x04\x0b\x10\n\r\n\x05\
    \x04\x05\x02\x02\x01\x12\x04\xd8\x04\x11\x16\n\r\n\x05\x04\x05\x02\x02\
    \x03\x12\x04\xd8\x04\x19\x1a\n\r\n\x05\x04\x05\x02\x02\x08\x12\x04\xd8\
    \x04\x1b4\n\r\n\x05\x04\x05\x02\x02\x07\x12\x04\xd8\x04&3\n\x8d\x01\n\
    \x04\x04\x05\x04\x01\x12\x06\xdb\x04\x02\xec\x04\x03\x1a}\x20What\x20is\
    \x20the\x20effect\x20of\x20this\x20problem\x20on\x20the\x20affected\x20e\
    ntity.\x20If\x20effect_detail\x20is\x20included,\x20then\x20Effect\x20mu\
    st\x20also\x20be\x20included.\n\n\r\n\x05\x04\x05\x04\x01\x01\x12\x04\
    \xdb\x04\x07\r\n\x0e\n\x06\x04\x05\x04\x01\x02\0\x12\x04\xdc\x04\x04\x13\
    \n\x0f\n\x07\x04\x05\x04\x01\x02\0\x01\x12\x04\xdc\x04\x04\x0e\n\x0f\n\
    \x07\x04\x05\x04\x01\x02\0\x02\x12\x04\xdc\x04\x11\x12\n\x0e\n\x06\x04\
    \x05\x04\x01\x02\x01\x12\x04\xdd\x04\x04\x18\n\x0f\n\x07\x04\x05\x04\x01\
    \x02\x01\x01\x12\x04\xdd\x04\x04\x13\n\x0f\n\x07\x04\x05\x04\x01\x02\x01\
    \x02\x12\x04\xdd\x04\x16\x17\n\xaf\x01\n\x06\x04\x05\x04\x01\x02\x02\x12\
    \x04\xe2\x04\x04\x1b\x1a\x9e\x01\x20We\x20don't\x20care\x20about\x20INsi\
    gnificant\x20delays:\x20they\x20are\x20hard\x20to\x20detect,\x20have\n\
    \x20little\x20impact\x20on\x20the\x20user,\x20and\x20would\x20clutter\
    \x20the\x20results\x20as\x20they\x20are\x20too\n\x20frequent.\n\n\x0f\n\
    \x07\x04\x05\x04\x01\x02\x02\x01\x12\x04\xe2\x04\x04\x16\n\x0f\n\x07\x04\
    \x05\x04\x01\x02\x02\x02\x12\x04\xe2\x04\x19\x1a\n\x0e\n\x06\x04\x05\x04\
    \x01\x02\x03\x12\x04\xe4\x04\x04\x0f\n\x0f\n\x07\x04\x05\x04\x01\x02\x03\
    \x01\x12\x04\xe4\x04\x04\n\n\x0f\n\x07\x04\x05\x04\x01\x02\x03\x02\x12\
    \x04\xe4\x04\r\x0e\n\x0e\n\x06\x04\x05\x04\x01\x02\x04\x12\x04\xe5\x04\
    \x04\x1b\n\x0f\n\x07\x04\x05\x04\x01\x02\x04\x01\x12\x04\xe5\x04\x04\x16\
    \n\x0f\n\x07\x04\x05\x04\x01\x02\x04\x02\x12\x04\xe5\x04\x19\x1a\n\x0e\n\
    \x06\x04\x05\x04\x01\x02\x05\x12\x04\xe6\x04\x04\x19\n\x0f\n\x07\x04\x05\
    \x04\x01\x02\x05\x01\x12\x04\xe6\x04\x04\x14\n\x0f\n\x07\x04\x05\x04\x01\
    \x02\x05\x02\x12\x04\xe6\x04\x17\x18\n\x0e\n\x06\x04\x05\x04\x01\x02\x06\
    \x12\x04\xe7\x04\x04\x15\n\x0f\n\x07\x04\x05\x04\x01\x02\x06\x01\x12\x04\
    \xe7\x04\x04\x10\n\x0f\n\x07\x04\x05\x04\x01\x02\x06\x02\x12\x04\xe7\x04\
    \x13\x14\n\x0e\n\x06\x04\x05\x04\x01\x02\x07\x12\x04\xe8\x04\x04\x17\n\
    \x0f\n\x07\x04\x05\x04\x01\x02\x07\x01\x12\x04\xe8\x04\x04\x12\n\x0f\n\
    \x07\x04\x05\x04\x01\x02\x07\x02\x12\x04\xe8\x04\x15\x16\n\x0e\n\x06\x04\
    \x05\x04\x01\x02\x08\x12\x04\xe9\x04\x04\x13\n\x0f\n\x07\x04\x05\x04\x01\
    \x02\x08\x01\x12\x04\xe9\x04\x04\x0e\n\x0f\n\x07\x04\x05\x04\x01\x02\x08\
    \x02\x12\x04\xe9\x04\x11\x12\n\x0e\n\x06\x04\x05\x04\x01\x02\t\x12\x04\
    \xea\x04\x04\x13\n\x0f\n\x07\x04\x05\x04\x01\x02\t\x01\x12\x04\xea\x04\
    \x04\r\n\x0f\n\x07\x04\x05\x04\x01\x02\t\x02\x12\x04\xea\x04\x10\x12\n\
    \x0e\n\x06\x04\x05\x04\x01\x02\n\x12\x04\xeb\x04\x04\x1d\n\x0f\n\x07\x04\
    \x05\x04\x01\x02\n\x01\x12\x04\xeb\x04\x04\x17\n\x0f\n\x07\x04\x05\x04\
    \x01\x02\n\x02\x12\x04\xeb\x04\x1a\x1c\n\x0c\n\x04\x04\x05\x02\x03\x12\
    \x04\xed\x04\x028\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04\xed\x04\x02\n\n\
    \r\n\x05\x04\x05\x02\x03\x06\x12\x04\xed\x04\x0b\x11\n\r\n\x05\x04\x05\
    \x02\x03\x01\x12\x04\xed\x04\x12\x18\n\r\n\x05\x04\x05\x02\x03\x03\x12\
    \x04\xed\x04\x1b\x1c\n\r\n\x05\x04\x05\x02\x03\x08\x12\x04\xed\x04\x1d7\
    \n\r\n\x05\x04\x05\x02\x03\x07\x12\x04\xed\x04(6\nN\n\x04\x04\x05\x02\
    \x04\x12\x04\xf0\x04\x02$\x1a@\x20The\x20URL\x20which\x20provides\x20add\
    itional\x20information\x20about\x20the\x20alert.\n\n\r\n\x05\x04\x05\x02\
    \x04\x04\x12\x04\xf0\x04\x02\n\n\r\n\x05\x04\x05\x02\x04\x06\x12\x04\xf0\
    \x04\x0b\x1b\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\xf0\x04\x1c\x1f\n\r\n\
    \x05\x04\x05\x02\x04\x03\x12\x04\xf0\x04\"#\nW\n\x04\x04\x05\x02\x05\x12\
    \x04\xf3\x04\x02-\x1aI\x20Alert\x20header.\x20Contains\x20a\x20short\x20\
    summary\x20of\x20the\x20alert\x20text\x20as\x20plain-text.\n\n\r\n\x05\
    \x04\x05\x02\x05\x04\x12\x04\xf3\x04\x02\n\n\r\n\x05\x04\x05\x02\x05\x06\
    \x12\x04\xf3\x04\x0b\x1b\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\xf3\x04\
    \x1c'\n\r\n\x05\x04\x05\x02\x05\x03\x12\x04\xf3\x04*,\n\x8f\x01\n\x04\
    \x04\x05\x02\x06\x12\x04\xf7\x04\x022\x1a\x80\x01\x20Full\x20description\
    \x20for\x20the\x20alert\x20as\x20plain-text.\x20The\x20information\x20in\
    \x20the\n\x20description\x20should\x20add\x20to\x20the\x20information\
    \x20of\x20the\x20header.\n\n\r\n\x05\x04\x05\x02\x06\x04\x12\x04\xf7\x04\
    \x02\n\n\r\n\x05\x04\x05\x02\x06\x06\x12\x04\xf7\x04\x0b\x1b\n\r\n\x05\
    \x04\x05\x02\x06\x01\x12\x04\xf7\x04\x1c,\n\r\n\x05\x04\x05\x02\x06\x03\
    \x12\x04\xf7\x04/1\n\x8c\x01\n\x04\x04\x05\x02\x07\x12\x04\xfa\x04\x021\
    \x1a~\x20Text\x20for\x20alert\x20header\x20to\x20be\x20used\x20in\x20tex\
    t-to-speech\x20implementations.\x20This\x20field\x20is\x20the\x20text-to\
    -speech\x20version\x20of\x20header_text.\n\n\r\n\x05\x04\x05\x02\x07\x04\
    \x12\x04\xfa\x04\x02\n\n\r\n\x05\x04\x05\x02\x07\x06\x12\x04\xfa\x04\x0b\
    \x1b\n\r\n\x05\x04\x05\x02\x07\x01\x12\x04\xfa\x04\x1c+\n\r\n\x05\x04\
    \x05\x02\x07\x03\x12\x04\xfa\x04.0\n\xa4\x01\n\x04\x04\x05\x02\x08\x12\
    \x04\xfd\x04\x026\x1a\x95\x01\x20Text\x20for\x20full\x20description\x20f\
    or\x20the\x20alert\x20to\x20be\x20used\x20in\x20text-to-speech\x20implem\
    entations.\x20This\x20field\x20is\x20the\x20text-to-speech\x20version\
    \x20of\x20description_text.\n\n\r\n\x05\x04\x05\x02\x08\x04\x12\x04\xfd\
    \x04\x02\n\n\r\n\x05\x04\x05\x02\x08\x06\x12\x04\xfd\x04\x0b\x1b\n\r\n\
    \x05\x04\x05\x02\x08\x01\x12\x04\xfd\x04\x1c0\n\r\n\x05\x04\x05\x02\x08\
    \x03\x12\x04\xfd\x0435\n)\n\x04\x04\x05\x04\x02\x12\x06\x80\x05\x02\x85\
    \x05\x03\x1a\x19\x20Severity\x20of\x20this\x20alert.\n\n\r\n\x05\x04\x05\
    \x04\x02\x01\x12\x04\x80\x05\x07\x14\n\x0e\n\x06\x04\x05\x04\x02\x02\0\
    \x12\x04\x81\x05\x08\x1d\n\x0f\n\x07\x04\x05\x04\x02\x02\0\x01\x12\x04\
    \x81\x05\x08\x18\n\x0f\n\x07\x04\x05\x04\x02\x02\0\x02\x12\x04\x81\x05\
    \x1b\x1c\n\x0e\n\x06\x04\x05\x04\x02\x02\x01\x12\x04\x82\x05\x08\x11\n\
    \x0f\n\x07\x04\x05\x04\x02\x02\x01\x01\x12\x04\x82\x05\x08\x0c\n\x0f\n\
    \x07\x04\x05\x04\x02\x02\x01\x02\x12\x04\x82\x05\x0f\x10\n\x0e\n\x06\x04\
    \x05\x04\x02\x02\x02\x12\x04\x83\x05\x08\x14\n\x0f\n\x07\x04\x05\x04\x02\
    \x02\x02\x01\x12\x04\x83\x05\x08\x0f\n\x0f\n\x07\x04\x05\x04\x02\x02\x02\
    \x02\x12\x04\x83\x05\x12\x13\n\x0e\n\x06\x04\x05\x04\x02\x02\x03\x12\x04\
    \x84\x05\x08\x13\n\x0f\n\x07\x04\x05\x04\x02\x02\x03\x01\x12\x04\x84\x05\
    \x08\x0e\n\x0f\n\x07\x04\x05\x04\x02\x02\x03\x02\x12\x04\x84\x05\x11\x12\
    \n\x0c\n\x04\x04\x05\x02\t\x12\x04\x87\x05\x02J\n\r\n\x05\x04\x05\x02\t\
    \x04\x12\x04\x87\x05\x02\n\n\r\n\x05\x04\x05\x02\t\x06\x12\x04\x87\x05\
    \x0b\x18\n\r\n\x05\x04\x05\x02\t\x01\x12\x04\x87\x05\x19'\n\r\n\x05\x04\
    \x05\x02\t\x03\x12\x04\x87\x05*,\n\r\n\x05\x04\x05\x02\t\x08\x12\x04\x87\
    \x05-I\n\r\n\x05\x04\x05\x02\t\x07\x12\x04\x87\x058H\n\xa6\x04\n\x04\x04\
    \x05\x02\n\x12\x04\x8c\x05\x02&\x1a\x97\x04\x20TranslatedImage\x20to\x20\
    be\x20displayed\x20along\x20the\x20alert\x20text.\x20Used\x20to\x20expla\
    in\x20visually\x20the\x20alert\x20effect\x20of\x20a\x20detour,\x20statio\
    n\x20closure,\x20etc.\x20The\x20image\x20must\x20enhance\x20the\x20under\
    standing\x20of\x20the\x20alert.\x20Any\x20essential\x20information\x20co\
    mmunicated\x20within\x20the\x20image\x20must\x20also\x20be\x20contained\
    \x20in\x20the\x20alert\x20text.\n\x20The\x20following\x20types\x20of\x20\
    images\x20are\x20discouraged\x20:\x20image\x20containing\x20mainly\x20te\
    xt,\x20marketing\x20or\x20branded\x20images\x20that\x20add\x20no\x20addi\
    tional\x20information.\x20\n\x20NOTE:\x20This\x20field\x20is\x20still\
    \x20experimental,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\
    \x20formally\x20adopted\x20in\x20the\x20future.\n\n\r\n\x05\x04\x05\x02\
    \n\x04\x12\x04\x8c\x05\x02\n\n\r\n\x05\x04\x05\x02\n\x06\x12\x04\x8c\x05\
    \x0b\x1a\n\r\n\x05\x04\x05\x02\n\x01\x12\x04\x8c\x05\x1b\x20\n\r\n\x05\
    \x04\x05\x02\n\x03\x12\x04\x8c\x05#%\n\xf5\x02\n\x04\x04\x05\x02\x0b\x12\
    \x04\x91\x05\x028\x1a\xe6\x02\x20Text\x20describing\x20the\x20appearance\
    \x20of\x20the\x20linked\x20image\x20in\x20the\x20`image`\x20field\x20(e.\
    g.,\x20in\x20case\x20the\x20image\x20can't\x20be\x20displayed\n\x20or\
    \x20the\x20user\x20can't\x20see\x20the\x20image\x20for\x20accessibility\
    \x20reasons).\x20See\x20the\x20HTML\x20spec\x20for\x20alt\x20image\x20te\
    xt\x20-\x20https://html.spec.whatwg.org/#alt.\n\x20NOTE:\x20This\x20fiel\
    d\x20is\x20still\x20experimental,\x20and\x20subject\x20to\x20change.\x20\
    It\x20may\x20be\x20formally\x20adopted\x20in\x20the\x20future.\n\n\r\n\
    \x05\x04\x05\x02\x0b\x04\x12\x04\x91\x05\x02\n\n\r\n\x05\x04\x05\x02\x0b\
    \x06\x12\x04\x91\x05\x0b\x1b\n\r\n\x05\x04\x05\x02\x0b\x01\x12\x04\x91\
    \x05\x1c2\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\x91\x0557\n\xa7\x02\n\
    \x04\x04\x05\x02\x0c\x12\x04\x96\x05\x02.\x1a\x98\x02\x20Description\x20\
    of\x20the\x20cause\x20of\x20the\x20alert\x20that\x20allows\x20for\x20age\
    ncy-specific\x20language;\x20more\x20specific\x20than\x20the\x20Cause.\
    \x20If\x20cause_detail\x20is\x20included,\x20then\x20Cause\x20must\x20al\
    so\x20be\x20included.\n\x20NOTE:\x20This\x20field\x20is\x20still\x20expe\
    rimental,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\x20forma\
    lly\x20adopted\x20in\x20the\x20future.\n\n\r\n\x05\x04\x05\x02\x0c\x04\
    \x12\x04\x96\x05\x02\n\n\r\n\x05\x04\x05\x02\x0c\x06\x12\x04\x96\x05\x0b\
    \x1b\n\r\n\x05\x04\x05\x02\x0c\x01\x12\x04\x96\x05\x1c(\n\r\n\x05\x04\
    \x05\x02\x0c\x03\x12\x04\x96\x05+-\n\xab\x02\n\x04\x04\x05\x02\r\x12\x04\
    \x9a\x05\x02/\x1a\x9c\x02\x20Description\x20of\x20the\x20effect\x20of\
    \x20the\x20alert\x20that\x20allows\x20for\x20agency-specific\x20language\
    ;\x20more\x20specific\x20than\x20the\x20Effect.\x20If\x20effect_detail\
    \x20is\x20included,\x20then\x20Effect\x20must\x20also\x20be\x20included.\
    \n\x20NOTE:\x20This\x20field\x20is\x20still\x20experimental,\x20and\x20s\
    ubject\x20to\x20change.\x20It\x20may\x20be\x20formally\x20adopted\x20in\
    \x20the\x20future.\n\n\r\n\x05\x04\x05\x02\r\x04\x12\x04\x9a\x05\x02\n\n\
    \r\n\x05\x04\x05\x02\r\x06\x12\x04\x9a\x05\x0b\x1b\n\r\n\x05\x04\x05\x02\
    \r\x01\x12\x04\x9a\x05\x1c)\n\r\n\x05\x04\x05\x02\r\x03\x12\x04\x9a\x05,\
    .\n\xb9\x01\n\x03\x04\x05\x05\x12\x04\x9f\x05\x02\x1a\x1a\xab\x01\x20The\
    \x20extensions\x20namespace\x20allows\x203rd-party\x20developers\x20to\
    \x20extend\x20the\n\x20GTFS\x20Realtime\x20Specification\x20in\x20order\
    \x20to\x20add\x20and\x20evaluate\x20new\x20features\n\x20and\x20modifica\
    tions\x20to\x20the\x20spec.\n\n\x0c\n\x04\x04\x05\x05\0\x12\x04\x9f\x05\
    \r\x19\n\r\n\x05\x04\x05\x05\0\x01\x12\x04\x9f\x05\r\x11\n\r\n\x05\x04\
    \x05\x05\0\x02\x12\x04\x9f\x05\x15\x19\n\\\n\x03\x04\x05\x05\x12\x04\xa2\
    \x05\x02\x1a\x1aO\x20The\x20following\x20extension\x20IDs\x20are\x20rese\
    rved\x20for\x20private\x20use\x20by\x20any\x20organization.\n\n\x0c\n\
    \x04\x04\x05\x05\x01\x12\x04\xa2\x05\r\x19\n\r\n\x05\x04\x05\x05\x01\x01\
    \x12\x04\xa2\x05\r\x11\n\r\n\x05\x04\x05\x05\x01\x02\x12\x04\xa2\x05\x15\
    \x19\n\xc9\x01\n\x02\x04\x06\x12\x06\xab\x05\0\xbd\x05\x01\x1a\x8f\x01\
    \x20A\x20time\x20interval.\x20The\x20interval\x20is\x20considered\x20act\
    ive\x20at\x20time\x20't'\x20if\x20't'\x20is\n\x20greater\x20than\x20or\
    \x20equal\x20to\x20the\x20start\x20time\x20and\x20less\x20than\x20the\
    \x20end\x20time.\n2)\n\x20Low\x20level\x20data\x20structures\x20used\x20\
    above.\n\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xab\x05\x08\x11\n\x9e\x01\n\
    \x04\x04\x06\x02\0\x12\x04\xaf\x05\x02\x1c\x1a\x8f\x01\x20Start\x20time,\
    \x20in\x20POSIX\x20time\x20(i.e.,\x20number\x20of\x20seconds\x20since\
    \x20January\x201st\x201970\n\x2000:00:00\x20UTC).\n\x20If\x20missing,\
    \x20the\x20interval\x20starts\x20at\x20minus\x20infinity.\n\n\r\n\x05\
    \x04\x06\x02\0\x04\x12\x04\xaf\x05\x02\n\n\r\n\x05\x04\x06\x02\0\x05\x12\
    \x04\xaf\x05\x0b\x11\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xaf\x05\x12\x17\
    \n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xaf\x05\x1a\x1b\n\x99\x01\n\x04\x04\
    \x06\x02\x01\x12\x04\xb4\x05\x02\x1a\x1a\x8a\x01\x20End\x20time,\x20in\
    \x20POSIX\x20time\x20(i.e.,\x20number\x20of\x20seconds\x20since\x20Janua\
    ry\x201st\x201970\n\x2000:00:00\x20UTC).\n\x20If\x20missing,\x20the\x20i\
    nterval\x20ends\x20at\x20plus\x20infinity.\n\n\r\n\x05\x04\x06\x02\x01\
    \x04\x12\x04\xb4\x05\x02\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xb4\x05\
    \x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xb4\x05\x12\x15\n\r\n\x05\
    \x04\x06\x02\x01\x03\x12\x04\xb4\x05\x18\x19\n\xb9\x01\n\x03\x04\x06\x05\
    \x12\x04\xb9\x05\x02\x1a\x1a\xab\x01\x20The\x20extensions\x20namespace\
    \x20allows\x203rd-party\x20developers\x20to\x20extend\x20the\n\x20GTFS\
    \x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20and\x20eval\
    uate\x20new\x20features\x20and\n\x20modifications\x20to\x20the\x20spec.\
    \n\n\x0c\n\x04\x04\x06\x05\0\x12\x04\xb9\x05\r\x19\n\r\n\x05\x04\x06\x05\
    \0\x01\x12\x04\xb9\x05\r\x11\n\r\n\x05\x04\x06\x05\0\x02\x12\x04\xb9\x05\
    \x15\x19\n\\\n\x03\x04\x06\x05\x12\x04\xbc\x05\x02\x1a\x1aO\x20The\x20fo\
    llowing\x20extension\x20IDs\x20are\x20reserved\x20for\x20private\x20use\
    \x20by\x20any\x20organization.\n\n\x0c\n\x04\x04\x06\x05\x01\x12\x04\xbc\
    \x05\r\x19\n\r\n\x05\x04\x06\x05\x01\x01\x12\x04\xbc\x05\r\x11\n\r\n\x05\
    \x04\x06\x05\x01\x02\x12\x04\xbc\x05\x15\x19\n\x1b\n\x02\x04\x07\x12\x06\
    \xc0\x05\0\xda\x05\x01\x1a\r\x20A\x20position.\n\n\x0b\n\x03\x04\x07\x01\
    \x12\x04\xc0\x05\x08\x10\n?\n\x04\x04\x07\x02\0\x12\x04\xc2\x05\x02\x1e\
    \x1a1\x20Degrees\x20North,\x20in\x20the\x20WGS-84\x20coordinate\x20syste\
    m.\n\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xc2\x05\x02\n\n\r\n\x05\x04\x07\
    \x02\0\x05\x12\x04\xc2\x05\x0b\x10\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\
    \xc2\x05\x11\x19\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xc2\x05\x1c\x1d\n>\
    \n\x04\x04\x07\x02\x01\x12\x04\xc5\x05\x02\x1f\x1a0\x20Degrees\x20East,\
    \x20in\x20the\x20WGS-84\x20coordinate\x20system.\n\n\r\n\x05\x04\x07\x02\
    \x01\x04\x12\x04\xc5\x05\x02\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xc5\
    \x05\x0b\x10\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xc5\x05\x11\x1a\n\r\n\
    \x05\x04\x07\x02\x01\x03\x12\x04\xc5\x05\x1d\x1e\n\xba\x02\n\x04\x04\x07\
    \x02\x02\x12\x04\xcc\x05\x02\x1d\x1a\xab\x02\x20Bearing,\x20in\x20degree\
    s,\x20clockwise\x20from\x20North,\x20i.e.,\x200\x20is\x20North\x20and\
    \x2090\x20is\x20East.\n\x20This\x20can\x20be\x20the\x20compass\x20bearin\
    g,\x20or\x20the\x20direction\x20towards\x20the\x20next\x20stop\n\x20or\
    \x20intermediate\x20location.\n\x20This\x20should\x20not\x20be\x20direct\
    ion\x20deduced\x20from\x20the\x20sequence\x20of\x20previous\n\x20positio\
    ns,\x20which\x20can\x20be\x20computed\x20from\x20previous\x20data.\n\n\r\
    \n\x05\x04\x07\x02\x02\x04\x12\x04\xcc\x05\x02\n\n\r\n\x05\x04\x07\x02\
    \x02\x05\x12\x04\xcc\x05\x0b\x10\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\
    \xcc\x05\x11\x18\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xcc\x05\x1b\x1c\n\
    *\n\x04\x04\x07\x02\x03\x12\x04\xcf\x05\x02\x1f\x1a\x1c\x20Odometer\x20v\
    alue,\x20in\x20meters.\n\n\r\n\x05\x04\x07\x02\x03\x04\x12\x04\xcf\x05\
    \x02\n\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\xcf\x05\x0b\x11\n\r\n\x05\
    \x04\x07\x02\x03\x01\x12\x04\xcf\x05\x12\x1a\n\r\n\x05\x04\x07\x02\x03\
    \x03\x12\x04\xcf\x05\x1d\x1e\nN\n\x04\x04\x07\x02\x04\x12\x04\xd1\x05\
    \x02\x1b\x1a@\x20Momentary\x20speed\x20measured\x20by\x20the\x20vehicle,\
    \x20in\x20meters\x20per\x20second.\n\n\r\n\x05\x04\x07\x02\x04\x04\x12\
    \x04\xd1\x05\x02\n\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\xd1\x05\x0b\x10\
    \n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xd1\x05\x11\x16\n\r\n\x05\x04\x07\
    \x02\x04\x03\x12\x04\xd1\x05\x19\x1a\n\xb9\x01\n\x03\x04\x07\x05\x12\x04\
    \xd6\x05\x02\x1a\x1a\xab\x01\x20The\x20extensions\x20namespace\x20allows\
    \x203rd-party\x20developers\x20to\x20extend\x20the\n\x20GTFS\x20Realtime\
    \x20Specification\x20in\x20order\x20to\x20add\x20and\x20evaluate\x20new\
    \x20features\x20and\n\x20modifications\x20to\x20the\x20spec.\n\n\x0c\n\
    \x04\x04\x07\x05\0\x12\x04\xd6\x05\r\x19\n\r\n\x05\x04\x07\x05\0\x01\x12\
    \x04\xd6\x05\r\x11\n\r\n\x05\x04\x07\x05\0\x02\x12\x04\xd6\x05\x15\x19\n\
    \\\n\x03\x04\x07\x05\x12\x04\xd9\x05\x02\x1a\x1aO\x20The\x20following\
    \x20extension\x20IDs\x20are\x20reserved\x20for\x20private\x20use\x20by\
    \x20any\x20organization.\n\n\x0c\n\x04\x04\x07\x05\x01\x12\x04\xd9\x05\r\
    \x19\n\r\n\x05\x04\x07\x05\x01\x01\x12\x04\xd9\x05\r\x11\n\r\n\x05\x04\
    \x07\x05\x01\x02\x12\x04\xd9\x05\x15\x19\n\xd0\x04\n\x02\x04\x08\x12\x06\
    \xe5\x05\0\xd1\x06\x01\x1a\xc1\x04\x20A\x20descriptor\x20that\x20identif\
    ies\x20an\x20instance\x20of\x20a\x20GTFS\x20trip,\x20or\x20all\x20instan\
    ces\x20of\n\x20a\x20trip\x20along\x20a\x20route.\n\x20-\x20To\x20specify\
    \x20a\x20single\x20trip\x20instance,\x20the\x20trip_id\x20(and\x20if\x20\
    necessary,\n\x20\x20\x20start_time)\x20is\x20set.\x20If\x20route_id\x20i\
    s\x20also\x20set,\x20then\x20it\x20should\x20be\x20same\x20as\x20one\n\
    \x20\x20\x20that\x20the\x20given\x20trip\x20corresponds\x20to.\n\x20-\
    \x20To\x20specify\x20all\x20the\x20trips\x20along\x20a\x20given\x20route\
    ,\x20only\x20the\x20route_id\x20should\x20be\n\x20\x20\x20set.\x20Note\
    \x20that\x20if\x20the\x20trip_id\x20is\x20not\x20known,\x20then\x20stop\
    \x20sequence\x20ids\x20in\n\x20\x20\x20TripUpdate\x20are\x20not\x20suffi\
    cient,\x20and\x20stop_ids\x20must\x20be\x20provided\x20as\x20well.\x20In\
    \n\x20\x20\x20addition,\x20absolute\x20arrival/departure\x20times\x20mus\
    t\x20be\x20provided.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xe5\x05\x08\x16\n\
    \xb8\x04\n\x04\x04\x08\x02\0\x12\x04\xec\x05\x02\x1e\x1a\xa9\x04\x20The\
    \x20trip_id\x20from\x20the\x20GTFS\x20feed\x20that\x20this\x20selector\
    \x20refers\x20to.\n\x20For\x20non\x20frequency-based\x20trips,\x20this\
    \x20field\x20is\x20enough\x20to\x20uniquely\x20identify\n\x20the\x20trip\
    .\x20For\x20frequency-based\x20trip,\x20start_time\x20and\x20start_date\
    \x20might\x20also\x20be\n\x20necessary.\x20When\x20schedule_relationship\
    \x20is\x20DUPLICATED\x20within\x20a\x20TripUpdate,\x20the\x20trip_id\x20\
    identifies\x20the\x20trip\x20from\n\x20static\x20GTFS\x20to\x20be\x20dup\
    licated.\x20When\x20schedule_relationship\x20is\x20DUPLICATED\x20within\
    \x20a\x20VehiclePosition,\x20the\x20trip_id\n\x20identifies\x20the\x20ne\
    w\x20duplicate\x20trip\x20and\x20must\x20contain\x20the\x20value\x20for\
    \x20the\x20corresponding\x20TripUpdate.TripProperties.trip_id.\n\n\r\n\
    \x05\x04\x08\x02\0\x04\x12\x04\xec\x05\x02\n\n\r\n\x05\x04\x08\x02\0\x05\
    \x12\x04\xec\x05\x0b\x11\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xec\x05\x12\
    \x19\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xec\x05\x1c\x1d\nH\n\x04\x04\
    \x08\x02\x01\x12\x04\xef\x05\x02\x1f\x1a:\x20The\x20route_id\x20from\x20\
    the\x20GTFS\x20that\x20this\x20selector\x20refers\x20to.\n\n\r\n\x05\x04\
    \x08\x02\x01\x04\x12\x04\xef\x05\x02\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\
    \x04\xef\x05\x0b\x11\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xef\x05\x12\
    \x1a\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xef\x05\x1d\x1e\n\x8a\x01\n\
    \x04\x04\x08\x02\x02\x12\x04\xf3\x05\x02#\x1a|\x20The\x20direction_id\
    \x20from\x20the\x20GTFS\x20feed\x20trips.txt\x20file,\x20indicating\x20t\
    he\n\x20direction\x20of\x20travel\x20for\x20trips\x20this\x20selector\
    \x20refers\x20to.\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xf3\x05\x02\n\
    \n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xf3\x05\x0b\x11\n\r\n\x05\x04\x08\
    \x02\x02\x01\x12\x04\xf3\x05\x12\x1e\n\r\n\x05\x04\x08\x02\x02\x03\x12\
    \x04\xf3\x05!\"\n\xf5\x07\n\x04\x04\x08\x02\x03\x12\x04\x84\x06\x02!\x1a\
    \xe6\x07\x20The\x20initially\x20scheduled\x20start\x20time\x20of\x20this\
    \x20trip\x20instance.\n\x20When\x20the\x20trip_id\x20corresponds\x20to\
    \x20a\x20non-frequency-based\x20trip,\x20this\x20field\n\x20should\x20ei\
    ther\x20be\x20omitted\x20or\x20be\x20equal\x20to\x20the\x20value\x20in\
    \x20the\x20GTFS\x20feed.\x20When\n\x20the\x20trip_id\x20correponds\x20to\
    \x20a\x20frequency-based\x20trip,\x20the\x20start_time\x20must\x20be\n\
    \x20specified\x20for\x20trip\x20updates\x20and\x20vehicle\x20positions.\
    \x20If\x20the\x20trip\x20corresponds\n\x20to\x20exact_times=1\x20GTFS\
    \x20record,\x20then\x20start_time\x20must\x20be\x20some\x20multiple\n\
    \x20(including\x20zero)\x20of\x20headway_secs\x20later\x20than\x20freque\
    ncies.txt\x20start_time\x20for\n\x20the\x20corresponding\x20time\x20peri\
    od.\x20If\x20the\x20trip\x20corresponds\x20to\x20exact_times=0,\n\x20the\
    n\x20its\x20start_time\x20may\x20be\x20arbitrary,\x20and\x20is\x20initia\
    lly\x20expected\x20to\x20be\x20the\n\x20first\x20departure\x20of\x20the\
    \x20trip.\x20Once\x20established,\x20the\x20start_time\x20of\x20this\n\
    \x20frequency-based\x20trip\x20should\x20be\x20considered\x20immutable,\
    \x20even\x20if\x20the\x20first\n\x20departure\x20time\x20changes\x20--\
    \x20that\x20time\x20change\x20may\x20instead\x20be\x20reflected\x20in\
    \x20a\n\x20StopTimeUpdate.\n\x20Format\x20and\x20semantics\x20of\x20the\
    \x20field\x20is\x20same\x20as\x20that\x20of\n\x20GTFS/frequencies.txt/st\
    art_time,\x20e.g.,\x2011:15:35\x20or\x2025:15:35.\n\n\r\n\x05\x04\x08\
    \x02\x03\x04\x12\x04\x84\x06\x02\n\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\
    \x84\x06\x0b\x11\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\x84\x06\x12\x1c\n\
    \r\n\x05\x04\x08\x02\x03\x03\x12\x04\x84\x06\x1f\x20\n\xc7\x04\n\x04\x04\
    \x08\x02\x04\x12\x04\x8f\x06\x02!\x1a\xb8\x04\x20The\x20scheduled\x20sta\
    rt\x20date\x20of\x20this\x20trip\x20instance.\n\x20Must\x20be\x20provide\
    d\x20to\x20disambiguate\x20trips\x20that\x20are\x20so\x20late\x20as\x20t\
    o\x20collide\x20with\n\x20a\x20scheduled\x20trip\x20on\x20a\x20next\x20d\
    ay.\x20For\x20example,\x20for\x20a\x20train\x20that\x20departs\x208:00\n\
    \x20and\x2020:00\x20every\x20day,\x20and\x20is\x2012\x20hours\x20late,\
    \x20there\x20would\x20be\x20two\x20distinct\n\x20trips\x20on\x20the\x20s\
    ame\x20time.\n\x20This\x20field\x20can\x20be\x20provided\x20but\x20is\
    \x20not\x20mandatory\x20for\x20schedules\x20in\x20which\x20such\n\x20col\
    lisions\x20are\x20impossible\x20-\x20for\x20example,\x20a\x20service\x20\
    running\x20on\x20hourly\n\x20schedule\x20where\x20a\x20vehicle\x20that\
    \x20is\x20one\x20hour\x20late\x20is\x20not\x20considered\x20to\x20be\n\
    \x20related\x20to\x20schedule\x20anymore.\n\x20In\x20YYYYMMDD\x20format.\
    \n\n\r\n\x05\x04\x08\x02\x04\x04\x12\x04\x8f\x06\x02\n\n\r\n\x05\x04\x08\
    \x02\x04\x05\x12\x04\x8f\x06\x0b\x11\n\r\n\x05\x04\x08\x02\x04\x01\x12\
    \x04\x8f\x06\x12\x1c\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\x8f\x06\x1f\
    \x20\n\xdb\x01\n\x04\x04\x08\x04\0\x12\x06\x94\x06\x02\xc7\x06\x03\x1a\
    \xca\x01\x20The\x20relation\x20between\x20this\x20trip\x20and\x20the\x20\
    static\x20schedule.\x20If\x20a\x20trip\x20is\x20done\n\x20in\x20accordan\
    ce\x20with\x20temporary\x20schedule,\x20not\x20reflected\x20in\x20GTFS,\
    \x20then\x20it\n\x20shouldn't\x20be\x20marked\x20as\x20SCHEDULED,\x20but\
    \x20likely\x20as\x20ADDED.\n\n\r\n\x05\x04\x08\x04\0\x01\x12\x04\x94\x06\
    \x07\x1b\n\x91\x01\n\x06\x04\x08\x04\0\x02\0\x12\x04\x97\x06\x04\x12\x1a\
    \x80\x01\x20Trip\x20that\x20is\x20running\x20in\x20accordance\x20with\
    \x20its\x20GTFS\x20schedule,\x20or\x20is\x20close\n\x20enough\x20to\x20t\
    he\x20scheduled\x20trip\x20to\x20be\x20associated\x20with\x20it.\n\n\x0f\
    \n\x07\x04\x08\x04\0\x02\0\x01\x12\x04\x97\x06\x04\r\n\x0f\n\x07\x04\x08\
    \x04\0\x02\0\x02\x12\x04\x97\x06\x10\x11\n\xb0\x04\n\x06\x04\x08\x04\0\
    \x02\x01\x12\x04\xa0\x06\x04\x0e\x1a\x9f\x04\x20An\x20extra\x20trip\x20t\
    hat\x20was\x20added\x20in\x20addition\x20to\x20a\x20running\x20schedule,\
    \x20for\n\x20example,\x20to\x20replace\x20a\x20broken\x20vehicle\x20or\
    \x20to\x20respond\x20to\x20sudden\x20passenger\n\x20load.\n\x20NOTE:\x20\
    Currently,\x20behavior\x20is\x20unspecified\x20for\x20feeds\x20that\x20u\
    se\x20this\x20mode.\x20There\x20are\x20discussions\x20on\x20the\x20GTFS\
    \x20GitHub\n\x20[(1)](https://github.com/google/transit/issues/106)\x20[\
    (2)](https://github.com/google/transit/pull/221)\n\x20[(3)](https://gith\
    ub.com/google/transit/pull/219)\x20around\x20fully\x20specifying\x20or\
    \x20deprecating\x20ADDED\x20trips\x20and\x20the\n\x20documentation\x20wi\
    ll\x20be\x20updated\x20when\x20those\x20discussions\x20are\x20finalized.\
    \n\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x01\x12\x04\xa0\x06\x04\t\n\x0f\n\
    \x07\x04\x08\x04\0\x02\x01\x02\x12\x04\xa0\x06\x0c\r\n\xe2\x01\n\x06\x04\
    \x08\x04\0\x02\x02\x12\x04\xa4\x06\x04\x14\x1a\xd1\x01\x20A\x20trip\x20t\
    hat\x20is\x20running\x20with\x20no\x20schedule\x20associated\x20to\x20it\
    \x20(GTFS\x20frequencies.txt\x20exact_times=0).\n\x20Trips\x20with\x20Sc\
    heduleRelationship=UNSCHEDULED\x20must\x20also\x20set\x20all\x20StopTime\
    Updates.ScheduleRelationship=UNSCHEDULED.\n\n\x0f\n\x07\x04\x08\x04\0\
    \x02\x02\x01\x12\x04\xa4\x06\x04\x0f\n\x0f\n\x07\x04\x08\x04\0\x02\x02\
    \x02\x12\x04\xa4\x06\x12\x13\nF\n\x06\x04\x08\x04\0\x02\x03\x12\x04\xa7\
    \x06\x04\x11\x1a6\x20A\x20trip\x20that\x20existed\x20in\x20the\x20schedu\
    le\x20but\x20was\x20removed.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x01\x12\
    \x04\xa7\x06\x04\x0c\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x02\x12\x04\xa7\
    \x06\x0f\x10\nH\n\x06\x04\x08\x04\0\x02\x04\x12\x04\xaa\x06\x04&\x1a8\
    \x20Should\x20not\x20be\x20used\x20-\x20for\x20backwards-compatibility\
    \x20only.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x04\x01\x12\x04\xaa\x06\x04\
    \x0f\n\x0f\n\x07\x04\x08\x04\0\x02\x04\x02\x12\x04\xaa\x06\x12\x13\n\x0f\
    \n\x07\x04\x08\x04\0\x02\x04\x03\x12\x04\xaa\x06\x14%\n\x10\n\x08\x04\
    \x08\x04\0\x02\x04\x03\x01\x12\x04\xaa\x06\x15$\n\xa8\x0c\n\x06\x04\x08\
    \x04\0\x02\x05\x12\x04\xbb\x06\x04\x13\x1a\x97\x0c\x20An\x20extra\x20tri\
    p\x20that\x20was\x20added\x20in\x20addition\x20to\x20a\x20running\x20sch\
    edule,\x20for\x20example,\x20to\x20replace\x20a\x20broken\x20vehicle\x20\
    or\x20to\n\x20respond\x20to\x20sudden\x20passenger\x20load.\x20Used\x20w\
    ith\x20TripUpdate.TripProperties.trip_id,\x20TripUpdate.TripProperties.s\
    tart_date,\n\x20and\x20TripUpdate.TripProperties.start_time\x20to\x20cop\
    y\x20an\x20existing\x20trip\x20from\x20static\x20GTFS\x20but\x20start\
    \x20at\x20a\x20different\x20service\n\x20date\x20and/or\x20time.\x20Dupl\
    icating\x20a\x20trip\x20is\x20allowed\x20if\x20the\x20service\x20related\
    \x20to\x20the\x20original\x20trip\x20in\x20(CSV)\x20GTFS\n\x20(in\x20cal\
    endar.txt\x20or\x20calendar_dates.txt)\x20is\x20operating\x20within\x20t\
    he\x20next\x2030\x20days.\x20The\x20trip\x20to\x20be\x20duplicated\x20is\
    \n\x20identified\x20via\x20TripUpdate.TripDescriptor.trip_id.\x20This\
    \x20enumeration\x20does\x20not\x20modify\x20the\x20existing\x20trip\x20r\
    eferenced\x20by\n\x20TripUpdate.TripDescriptor.trip_id\x20-\x20if\x20a\
    \x20producer\x20wants\x20to\x20cancel\x20the\x20original\x20trip,\x20it\
    \x20must\x20publish\x20a\x20separate\n\x20TripUpdate\x20with\x20the\x20v\
    alue\x20of\x20CANCELED\x20or\x20DELETED.\x20Trips\x20defined\x20in\x20GT\
    FS\x20frequencies.txt\x20with\x20exact_times\x20that\x20is\n\x20empty\
    \x20or\x20equal\x20to\x200\x20cannot\x20be\x20duplicated.\x20The\x20Vehi\
    clePosition.TripDescriptor.trip_id\x20for\x20the\x20new\x20trip\x20must\
    \x20contain\n\x20the\x20matching\x20value\x20from\x20TripUpdate.TripProp\
    erties.trip_id\x20and\x20VehiclePosition.TripDescriptor.ScheduleRelation\
    ship\n\x20must\x20also\x20be\x20set\x20to\x20DUPLICATED.\n\x20Existing\
    \x20producers\x20and\x20consumers\x20that\x20were\x20using\x20the\x20ADD\
    ED\x20enumeration\x20to\x20represent\x20duplicated\x20trips\x20must\x20f\
    ollow\n\x20the\x20migration\x20guide\x20(https://github.com/google/trans\
    it/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)\n\
    \x20to\x20transition\x20to\x20the\x20DUPLICATED\x20enumeration.\n\x20NOT\
    E:\x20This\x20field\x20is\x20still\x20experimental,\x20and\x20subject\
    \x20to\x20change.\x20It\x20may\x20be\x20formally\x20adopted\x20in\x20the\
    \x20future.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x05\x01\x12\x04\xbb\x06\x04\
    \x0e\n\x0f\n\x07\x04\x08\x04\0\x02\x05\x02\x12\x04\xbb\x06\x11\x12\n\xf4\
    \x05\n\x06\x04\x08\x04\0\x02\x06\x12\x04\xc6\x06\x04\x10\x1a\xe3\x05\x20\
    A\x20trip\x20that\x20existed\x20in\x20the\x20schedule\x20but\x20was\x20r\
    emoved\x20and\x20must\x20not\x20be\x20shown\x20to\x20users.\n\x20DELETED\
    \x20should\x20be\x20used\x20instead\x20of\x20CANCELED\x20to\x20indicate\
    \x20that\x20a\x20transit\x20provider\x20would\x20like\x20to\x20entirely\
    \x20remove\n\x20information\x20about\x20the\x20corresponding\x20trip\x20\
    from\x20consuming\x20applications,\x20so\x20the\x20trip\x20is\x20not\x20\
    shown\x20as\x20cancelled\x20to\n\x20riders,\x20e.g.\x20a\x20trip\x20that\
    \x20is\x20entirely\x20being\x20replaced\x20by\x20another\x20trip.\n\x20T\
    his\x20designation\x20becomes\x20particularly\x20important\x20if\x20seve\
    ral\x20trips\x20are\x20cancelled\x20and\x20replaced\x20with\x20substitut\
    e\x20service.\n\x20If\x20consumers\x20were\x20to\x20show\x20explicit\x20\
    information\x20about\x20the\x20cancellations\x20it\x20would\x20distract\
    \x20from\x20the\x20more\x20important\n\x20real-time\x20predictions.\n\
    \x20NOTE:\x20This\x20field\x20is\x20still\x20experimental,\x20and\x20sub\
    ject\x20to\x20change.\x20It\x20may\x20be\x20formally\x20adopted\x20in\
    \x20the\x20future.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x06\x01\x12\x04\xc6\
    \x06\x04\x0b\n\x0f\n\x07\x04\x08\x04\0\x02\x06\x02\x12\x04\xc6\x06\x0e\
    \x0f\n\x0c\n\x04\x04\x08\x02\x05\x12\x04\xc8\x06\x02:\n\r\n\x05\x04\x08\
    \x02\x05\x04\x12\x04\xc8\x06\x02\n\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\
    \xc8\x06\x0b\x1f\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\xc8\x06\x205\n\r\
    \n\x05\x04\x08\x02\x05\x03\x12\x04\xc8\x0689\n\xb9\x01\n\x03\x04\x08\x05\
    \x12\x04\xcd\x06\x02\x1a\x1a\xab\x01\x20The\x20extensions\x20namespace\
    \x20allows\x203rd-party\x20developers\x20to\x20extend\x20the\n\x20GTFS\
    \x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20and\x20eval\
    uate\x20new\x20features\x20and\n\x20modifications\x20to\x20the\x20spec.\
    \n\n\x0c\n\x04\x04\x08\x05\0\x12\x04\xcd\x06\r\x19\n\r\n\x05\x04\x08\x05\
    \0\x01\x12\x04\xcd\x06\r\x11\n\r\n\x05\x04\x08\x05\0\x02\x12\x04\xcd\x06\
    \x15\x19\n\\\n\x03\x04\x08\x05\x12\x04\xd0\x06\x02\x1a\x1aO\x20The\x20fo\
    llowing\x20extension\x20IDs\x20are\x20reserved\x20for\x20private\x20use\
    \x20by\x20any\x20organization.\n\n\x0c\n\x04\x04\x08\x05\x01\x12\x04\xd0\
    \x06\r\x19\n\r\n\x05\x04\x08\x05\x01\x01\x12\x04\xd0\x06\r\x11\n\r\n\x05\
    \x04\x08\x05\x01\x02\x12\x04\xd0\x06\x15\x19\nO\n\x02\x04\t\x12\x06\xd4\
    \x06\0\xfc\x06\x01\x1aA\x20Identification\x20information\x20for\x20the\
    \x20vehicle\x20performing\x20the\x20trip.\n\n\x0b\n\x03\x04\t\x01\x12\
    \x04\xd4\x06\x08\x19\n\xab\x01\n\x04\x04\t\x02\0\x12\x04\xd8\x06\x02\x19\
    \x1a\x9c\x01\x20Internal\x20system\x20identification\x20of\x20the\x20veh\
    icle.\x20Should\x20be\x20unique\x20per\n\x20vehicle,\x20and\x20can\x20be\
    \x20used\x20for\x20tracking\x20the\x20vehicle\x20as\x20it\x20proceeds\
    \x20through\n\x20the\x20system.\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xd8\
    \x06\x02\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xd8\x06\x0b\x11\n\r\n\x05\
    \x04\t\x02\0\x01\x12\x04\xd8\x06\x12\x14\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\xd8\x06\x17\x18\n~\n\x04\x04\t\x02\x01\x12\x04\xdc\x06\x02\x1c\x1ap\
    \x20User\x20visible\x20label,\x20i.e.,\x20something\x20that\x20must\x20b\
    e\x20shown\x20to\x20the\x20passenger\x20to\n\x20help\x20identify\x20the\
    \x20correct\x20vehicle.\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xdc\x06\
    \x02\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xdc\x06\x0b\x11\n\r\n\x05\x04\
    \t\x02\x01\x01\x12\x04\xdc\x06\x12\x17\n\r\n\x05\x04\t\x02\x01\x03\x12\
    \x04\xdc\x06\x1a\x1b\n1\n\x04\x04\t\x02\x02\x12\x04\xdf\x06\x02$\x1a#\
    \x20The\x20license\x20plate\x20of\x20the\x20vehicle.\n\n\r\n\x05\x04\t\
    \x02\x02\x04\x12\x04\xdf\x06\x02\n\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\
    \xdf\x06\x0b\x11\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xdf\x06\x12\x1f\n\r\
    \n\x05\x04\t\x02\x02\x03\x12\x04\xdf\x06\"#\n\x0e\n\x04\x04\t\x04\0\x12\
    \x06\xe1\x06\x02\xf2\x06\x03\n\r\n\x05\x04\t\x04\0\x01\x12\x04\xe1\x06\
    \x07\x1b\n\xce\x01\n\x06\x04\t\x04\0\x02\0\x12\x04\xe5\x06\x04\x11\x1a\
    \xbd\x01\x20The\x20trip\x20doesn't\x20have\x20information\x20about\x20wh\
    eelchair\x20accessibility.\n\x20This\x20is\x20the\x20**default**\x20beha\
    vior.\x20If\x20the\x20static\x20GTFS\x20contains\x20a\n\x20_wheelchair_a\
    ccessible_\x20value,\x20it\x20won't\x20be\x20overwritten.\n\n\x0f\n\x07\
    \x04\t\x04\0\x02\0\x01\x12\x04\xe5\x06\x04\x0c\n\x0f\n\x07\x04\t\x04\0\
    \x02\0\x02\x12\x04\xe5\x06\x0f\x10\nr\n\x06\x04\t\x04\0\x02\x01\x12\x04\
    \xe9\x06\x04\x10\x1ab\x20The\x20trip\x20has\x20no\x20accessibility\x20va\
    lue\x20present.\n\x20This\x20value\x20will\x20overwrite\x20the\x20value\
    \x20from\x20the\x20GTFS.\n\n\x0f\n\x07\x04\t\x04\0\x02\x01\x01\x12\x04\
    \xe9\x06\x04\x0b\n\x0f\n\x07\x04\t\x04\0\x02\x01\x02\x12\x04\xe9\x06\x0e\
    \x0f\nh\n\x06\x04\t\x04\0\x02\x02\x12\x04\xed\x06\x04\x1e\x1aX\x20The\
    \x20trip\x20is\x20wheelchair\x20accessible.\n\x20This\x20value\x20will\
    \x20overwrite\x20the\x20value\x20from\x20the\x20GTFS.\n\n\x0f\n\x07\x04\
    \t\x04\0\x02\x02\x01\x12\x04\xed\x06\x04\x19\n\x0f\n\x07\x04\t\x04\0\x02\
    \x02\x02\x12\x04\xed\x06\x1c\x1d\np\n\x06\x04\t\x04\0\x02\x03\x12\x04\
    \xf1\x06\x04\x20\x1a`\x20The\x20trip\x20is\x20**not**\x20wheelchair\x20a\
    ccessible.\n\x20This\x20value\x20will\x20overwrite\x20the\x20value\x20fr\
    om\x20the\x20GTFS.\n\n\x0f\n\x07\x04\t\x04\0\x02\x03\x01\x12\x04\xf1\x06\
    \x04\x1b\n\x0f\n\x07\x04\t\x04\0\x02\x03\x02\x12\x04\xf1\x06\x1e\x1f\n\
    \x0c\n\x04\x04\t\x02\x03\x12\x04\xf3\x06\x02O\n\r\n\x05\x04\t\x02\x03\
    \x04\x12\x04\xf3\x06\x02\n\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xf3\x06\
    \x0b\x1f\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xf3\x06\x205\n\r\n\x05\x04\
    \t\x02\x03\x03\x12\x04\xf3\x0689\n\r\n\x05\x04\t\x02\x03\x08\x12\x04\xf3\
    \x06:N\n\r\n\x05\x04\t\x02\x03\x07\x12\x04\xf3\x06EM\n\xb9\x01\n\x03\x04\
    \t\x05\x12\x04\xf8\x06\x02\x1a\x1a\xab\x01\x20The\x20extensions\x20names\
    pace\x20allows\x203rd-party\x20developers\x20to\x20extend\x20the\n\x20GT\
    FS\x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20and\x20ev\
    aluate\x20new\x20features\x20and\n\x20modifications\x20to\x20the\x20spec\
    .\n\n\x0c\n\x04\x04\t\x05\0\x12\x04\xf8\x06\r\x19\n\r\n\x05\x04\t\x05\0\
    \x01\x12\x04\xf8\x06\r\x11\n\r\n\x05\x04\t\x05\0\x02\x12\x04\xf8\x06\x15\
    \x19\n\\\n\x03\x04\t\x05\x12\x04\xfb\x06\x02\x1a\x1aO\x20The\x20followin\
    g\x20extension\x20IDs\x20are\x20reserved\x20for\x20private\x20use\x20by\
    \x20any\x20organization.\n\n\x0c\n\x04\x04\t\x05\x01\x12\x04\xfb\x06\r\
    \x19\n\r\n\x05\x04\t\x05\x01\x01\x12\x04\xfb\x06\r\x11\n\r\n\x05\x04\t\
    \x05\x01\x02\x12\x04\xfb\x06\x15\x19\n8\n\x02\x04\n\x12\x06\xff\x06\0\
    \x95\x07\x01\x1a*\x20A\x20selector\x20for\x20an\x20entity\x20in\x20a\x20\
    GTFS\x20feed.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xff\x06\x08\x16\n\xe2\x01\
    \n\x04\x04\n\x02\0\x12\x04\x84\x07\x02\x20\x1a\xd3\x01\x20The\x20values\
    \x20of\x20the\x20fields\x20should\x20correspond\x20to\x20the\x20appropri\
    ate\x20fields\x20in\x20the\n\x20GTFS\x20feed.\n\x20At\x20least\x20one\
    \x20specifier\x20must\x20be\x20given.\x20If\x20several\x20are\x20given,\
    \x20then\x20the\n\x20matching\x20has\x20to\x20apply\x20to\x20all\x20the\
    \x20given\x20specifiers.\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x84\x07\x02\
    \n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x84\x07\x0b\x11\n\r\n\x05\x04\n\x02\
    \0\x01\x12\x04\x84\x07\x12\x1b\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x84\x07\
    \x1e\x1f\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x85\x07\x02\x1f\n\r\n\x05\x04\
    \n\x02\x01\x04\x12\x04\x85\x07\x02\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\
    \x85\x07\x0b\x11\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x85\x07\x12\x1a\n\r\
    \n\x05\x04\n\x02\x01\x03\x12\x04\x85\x07\x1d\x1e\n2\n\x04\x04\n\x02\x02\
    \x12\x04\x87\x07\x02\x20\x1a$\x20corresponds\x20to\x20route_type\x20in\
    \x20GTFS.\n\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\x87\x07\x02\n\n\r\n\x05\
    \x04\n\x02\x02\x05\x12\x04\x87\x07\x0b\x10\n\r\n\x05\x04\n\x02\x02\x01\
    \x12\x04\x87\x07\x11\x1b\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x87\x07\x1e\
    \x1f\n\x0c\n\x04\x04\n\x02\x03\x12\x04\x88\x07\x02#\n\r\n\x05\x04\n\x02\
    \x03\x04\x12\x04\x88\x07\x02\n\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\x88\
    \x07\x0b\x19\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\x88\x07\x1a\x1e\n\r\n\
    \x05\x04\n\x02\x03\x03\x12\x04\x88\x07!\"\n\x0c\n\x04\x04\n\x02\x04\x12\
    \x04\x89\x07\x02\x1e\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\x89\x07\x02\n\n\
    \r\n\x05\x04\n\x02\x04\x05\x12\x04\x89\x07\x0b\x11\n\r\n\x05\x04\n\x02\
    \x04\x01\x12\x04\x89\x07\x12\x19\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\x89\
    \x07\x1c\x1d\nt\n\x04\x04\n\x02\x05\x12\x04\x8c\x07\x02#\x1af\x20Corresp\
    onds\x20to\x20trip\x20direction_id\x20in\x20GTFS\x20trips.txt.\x20If\x20\
    provided\x20the\n\x20route_id\x20must\x20also\x20be\x20provided.\n\n\r\n\
    \x05\x04\n\x02\x05\x04\x12\x04\x8c\x07\x02\n\n\r\n\x05\x04\n\x02\x05\x05\
    \x12\x04\x8c\x07\x0b\x11\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\x8c\x07\x12\
    \x1e\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\x8c\x07!\"\n\xb9\x01\n\x03\x04\
    \n\x05\x12\x04\x91\x07\x02\x1a\x1a\xab\x01\x20The\x20extensions\x20names\
    pace\x20allows\x203rd-party\x20developers\x20to\x20extend\x20the\n\x20GT\
    FS\x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20and\x20ev\
    aluate\x20new\x20features\x20and\n\x20modifications\x20to\x20the\x20spec\
    .\n\n\x0c\n\x04\x04\n\x05\0\x12\x04\x91\x07\r\x19\n\r\n\x05\x04\n\x05\0\
    \x01\x12\x04\x91\x07\r\x11\n\r\n\x05\x04\n\x05\0\x02\x12\x04\x91\x07\x15\
    \x19\n\\\n\x03\x04\n\x05\x12\x04\x94\x07\x02\x1a\x1aO\x20The\x20followin\
    g\x20extension\x20IDs\x20are\x20reserved\x20for\x20private\x20use\x20by\
    \x20any\x20organization.\n\n\x0c\n\x04\x04\n\x05\x01\x12\x04\x94\x07\r\
    \x19\n\r\n\x05\x04\n\x05\x01\x01\x12\x04\x94\x07\r\x11\n\r\n\x05\x04\n\
    \x05\x01\x02\x12\x04\x94\x07\x15\x19\n\x9b\x04\n\x02\x04\x0b\x12\x06\xa1\
    \x07\0\xbc\x07\x01\x1a\x8c\x04\x20An\x20internationalized\x20message\x20\
    containing\x20per-language\x20versions\x20of\x20a\x20snippet\x20of\n\x20\
    text\x20or\x20a\x20URL.\n\x20One\x20of\x20the\x20strings\x20from\x20a\
    \x20message\x20will\x20be\x20picked\x20up.\x20The\x20resolution\x20proce\
    eds\n\x20as\x20follows:\n\x201.\x20If\x20the\x20UI\x20language\x20matche\
    s\x20the\x20language\x20code\x20of\x20a\x20translation,\n\x20\x20\x20\
    \x20the\x20first\x20matching\x20translation\x20is\x20picked.\n\x202.\x20\
    If\x20a\x20default\x20UI\x20language\x20(e.g.,\x20English)\x20matches\
    \x20the\x20language\x20code\x20of\x20a\n\x20\x20\x20\x20translation,\x20\
    the\x20first\x20matching\x20translation\x20is\x20picked.\n\x203.\x20If\
    \x20some\x20translation\x20has\x20an\x20unspecified\x20language\x20code,\
    \x20that\x20translation\x20is\n\x20\x20\x20\x20picked.\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xa1\x07\x08\x18\n\x0e\n\x04\x04\x0b\x03\0\x12\x06\xa2\
    \x07\x02\xb1\x07\x03\n\r\n\x05\x04\x0b\x03\0\x01\x12\x04\xa2\x07\n\x15\n\
    8\n\x06\x04\x0b\x03\0\x02\0\x12\x04\xa4\x07\x04\x1d\x1a(\x20A\x20UTF-8\
    \x20string\x20containing\x20the\x20message.\n\n\x0f\n\x07\x04\x0b\x03\0\
    \x02\0\x04\x12\x04\xa4\x07\x04\x0c\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x05\
    \x12\x04\xa4\x07\r\x13\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x01\x12\x04\xa4\
    \x07\x14\x18\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x03\x12\x04\xa4\x07\x1b\x1c\
    \n\xc7\x01\n\x06\x04\x0b\x03\0\x02\x01\x12\x04\xa8\x07\x04!\x1a\xb6\x01\
    \x20BCP-47\x20language\x20code.\x20Can\x20be\x20omitted\x20if\x20the\x20\
    language\x20is\x20unknown\x20or\x20if\n\x20no\x20i18n\x20is\x20done\x20a\
    t\x20all\x20for\x20the\x20feed.\x20At\x20most\x20one\x20translation\x20i\
    s\n\x20allowed\x20to\x20have\x20an\x20unspecified\x20language\x20tag.\n\
    \n\x0f\n\x07\x04\x0b\x03\0\x02\x01\x04\x12\x04\xa8\x07\x04\x0c\n\x0f\n\
    \x07\x04\x0b\x03\0\x02\x01\x05\x12\x04\xa8\x07\r\x13\n\x0f\n\x07\x04\x0b\
    \x03\0\x02\x01\x01\x12\x04\xa8\x07\x14\x1c\n\x0f\n\x07\x04\x0b\x03\0\x02\
    \x01\x03\x12\x04\xa8\x07\x1f\x20\n\xbb\x01\n\x05\x04\x0b\x03\0\x05\x12\
    \x04\xad\x07\x04\x1c\x1a\xab\x01\x20The\x20extensions\x20namespace\x20al\
    lows\x203rd-party\x20developers\x20to\x20extend\x20the\n\x20GTFS\x20Real\
    time\x20Specification\x20in\x20order\x20to\x20add\x20and\x20evaluate\x20\
    new\x20features\x20and\n\x20modifications\x20to\x20the\x20spec.\n\n\x0e\
    \n\x06\x04\x0b\x03\0\x05\0\x12\x04\xad\x07\x0f\x1b\n\x0f\n\x07\x04\x0b\
    \x03\0\x05\0\x01\x12\x04\xad\x07\x0f\x13\n\x0f\n\x07\x04\x0b\x03\0\x05\0\
    \x02\x12\x04\xad\x07\x17\x1b\n^\n\x05\x04\x0b\x03\0\x05\x12\x04\xb0\x07\
    \x04\x1c\x1aO\x20The\x20following\x20extension\x20IDs\x20are\x20reserved\
    \x20for\x20private\x20use\x20by\x20any\x20organization.\n\n\x0e\n\x06\
    \x04\x0b\x03\0\x05\x01\x12\x04\xb0\x07\x0f\x1b\n\x0f\n\x07\x04\x0b\x03\0\
    \x05\x01\x01\x12\x04\xb0\x07\x0f\x13\n\x0f\n\x07\x04\x0b\x03\0\x05\x01\
    \x02\x12\x04\xb0\x07\x17\x1b\n:\n\x04\x04\x0b\x02\0\x12\x04\xb3\x07\x02'\
    \x1a,\x20At\x20least\x20one\x20translation\x20must\x20be\x20provided.\n\
    \n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xb3\x07\x02\n\n\r\n\x05\x04\x0b\x02\
    \0\x06\x12\x04\xb3\x07\x0b\x16\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xb3\
    \x07\x17\"\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xb3\x07%&\n\xb9\x01\n\x03\
    \x04\x0b\x05\x12\x04\xb8\x07\x02\x1a\x1a\xab\x01\x20The\x20extensions\
    \x20namespace\x20allows\x203rd-party\x20developers\x20to\x20extend\x20th\
    e\n\x20GTFS\x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20\
    and\x20evaluate\x20new\x20features\x20and\n\x20modifications\x20to\x20th\
    e\x20spec.\n\n\x0c\n\x04\x04\x0b\x05\0\x12\x04\xb8\x07\r\x19\n\r\n\x05\
    \x04\x0b\x05\0\x01\x12\x04\xb8\x07\r\x11\n\r\n\x05\x04\x0b\x05\0\x02\x12\
    \x04\xb8\x07\x15\x19\n\\\n\x03\x04\x0b\x05\x12\x04\xbb\x07\x02\x1a\x1aO\
    \x20The\x20following\x20extension\x20IDs\x20are\x20reserved\x20for\x20pr\
    ivate\x20use\x20by\x20any\x20organization.\n\n\x0c\n\x04\x04\x0b\x05\x01\
    \x12\x04\xbb\x07\r\x19\n\r\n\x05\x04\x0b\x05\x01\x01\x12\x04\xbb\x07\r\
    \x11\n\r\n\x05\x04\x0b\x05\x01\x02\x12\x04\xbb\x07\x15\x19\n\xad\x05\n\
    \x02\x04\x0c\x12\x06\xc9\x07\0\xed\x07\x01\x1a\x9e\x05\x20An\x20internat\
    ionalized\x20image\x20containing\x20per-language\x20versions\x20of\x20a\
    \x20URL\x20linking\x20to\x20an\x20image\n\x20along\x20with\x20meta\x20in\
    formation\n\x20Only\x20one\x20of\x20the\x20images\x20from\x20a\x20messag\
    e\x20will\x20be\x20retained\x20by\x20consumers.\x20The\x20resolution\x20\
    proceeds\n\x20as\x20follows:\n\x201.\x20If\x20the\x20UI\x20language\x20m\
    atches\x20the\x20language\x20code\x20of\x20a\x20translation,\n\x20\x20\
    \x20\x20the\x20first\x20matching\x20translation\x20is\x20picked.\n\x202.\
    \x20If\x20a\x20default\x20UI\x20language\x20(e.g.,\x20English)\x20matche\
    s\x20the\x20language\x20code\x20of\x20a\n\x20\x20\x20\x20translation,\
    \x20the\x20first\x20matching\x20translation\x20is\x20picked.\n\x203.\x20\
    If\x20some\x20translation\x20has\x20an\x20unspecified\x20language\x20cod\
    e,\x20that\x20translation\x20is\n\x20\x20\x20\x20picked.\n\x20NOTE:\x20T\
    his\x20field\x20is\x20still\x20experimental,\x20and\x20subject\x20to\x20\
    change.\x20It\x20may\x20be\x20formally\x20adopted\x20in\x20the\x20future\
    .\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xc9\x07\x08\x17\n\x0e\n\x04\x04\x0c\
    \x03\0\x12\x06\xca\x07\x02\xe2\x07\x03\n\r\n\x05\x04\x0c\x03\0\x01\x12\
    \x04\xca\x07\n\x18\n\x96\x04\n\x06\x04\x0c\x03\0\x02\0\x12\x04\xcf\x07\
    \x04\x1c\x1a\x85\x04\x20String\x20containing\x20an\x20URL\x20linking\x20\
    to\x20an\x20image\n\x20The\x20image\x20linked\x20must\x20be\x20less\x20t\
    han\x202MB.\x20\n\x20If\x20an\x20image\x20changes\x20in\x20a\x20signific\
    ant\x20enough\x20way\x20that\x20an\x20update\x20is\x20required\x20on\x20\
    the\x20consumer\x20side,\x20the\x20producer\x20must\x20update\x20the\x20\
    URL\x20to\x20a\x20new\x20one.\n\x20The\x20URL\x20should\x20be\x20a\x20fu\
    lly\x20qualified\x20URL\x20that\x20includes\x20http://\x20or\x20https://\
    ,\x20and\x20any\x20special\x20characters\x20in\x20the\x20URL\x20must\x20\
    be\x20correctly\x20escaped.\x20See\x20the\x20following\xc2\xa0http://www\
    .w3.org/Addressing/URL/4_URI_Recommentations.html\xc2\xa0for\x20a\x20des\
    cription\x20of\x20how\x20to\x20create\x20fully\x20qualified\x20URL\x20va\
    lues.\n\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x04\x12\x04\xcf\x07\x04\x0c\n\
    \x0f\n\x07\x04\x0c\x03\0\x02\0\x05\x12\x04\xcf\x07\r\x13\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\0\x01\x12\x04\xcf\x07\x14\x17\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\0\x03\x12\x04\xcf\x07\x1a\x1b\nv\n\x06\x04\x0c\x03\0\x02\x01\x12\
    \x04\xd3\x07\x04#\x1af\x20IANA\x20media\x20type\x20as\x20to\x20specify\
    \x20the\x20type\x20of\x20image\x20to\x20be\x20displayed.\x20\n\x20The\
    \x20type\x20must\x20start\x20with\x20\"image/\"\n\n\x0f\n\x07\x04\x0c\
    \x03\0\x02\x01\x04\x12\x04\xd3\x07\x04\x0c\n\x0f\n\x07\x04\x0c\x03\0\x02\
    \x01\x05\x12\x04\xd3\x07\r\x13\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x01\x12\
    \x04\xd3\x07\x14\x1e\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x03\x12\x04\xd3\
    \x07!\"\n\xc7\x01\n\x06\x04\x0c\x03\0\x02\x02\x12\x04\xd8\x07\x04!\x1a\
    \xb6\x01\x20BCP-47\x20language\x20code.\x20Can\x20be\x20omitted\x20if\
    \x20the\x20language\x20is\x20unknown\x20or\x20if\n\x20no\x20i18n\x20is\
    \x20done\x20at\x20all\x20for\x20the\x20feed.\x20At\x20most\x20one\x20tra\
    nslation\x20is\n\x20allowed\x20to\x20have\x20an\x20unspecified\x20langua\
    ge\x20tag.\n\n\x0f\n\x07\x04\x0c\x03\0\x02\x02\x04\x12\x04\xd8\x07\x04\
    \x0c\n\x0f\n\x07\x04\x0c\x03\0\x02\x02\x05\x12\x04\xd8\x07\r\x13\n\x0f\n\
    \x07\x04\x0c\x03\0\x02\x02\x01\x12\x04\xd8\x07\x14\x1c\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\x02\x03\x12\x04\xd8\x07\x1f\x20\n\xbb\x01\n\x05\x04\x0c\
    \x03\0\x05\x12\x04\xde\x07\x04\x1c\x1a\xab\x01\x20The\x20extensions\x20n\
    amespace\x20allows\x203rd-party\x20developers\x20to\x20extend\x20the\n\
    \x20GTFS\x20Realtime\x20Specification\x20in\x20order\x20to\x20add\x20and\
    \x20evaluate\x20new\x20features\x20and\n\x20modifications\x20to\x20the\
    \x20spec.\n\n\x0e\n\x06\x04\x0c\x03\0\x05\0\x12\x04\xde\x07\x0f\x1b\n\
    \x0f\n\x07\x04\x0c\x03\0\x05\0\x01\x12\x04\xde\x07\x0f\x13\n\x0f\n\x07\
    \x04\x0c\x03\0\x05\0\x02\x12\x04\xde\x07\x17\x1b\n^\n\x05\x04\x0c\x03\0\
    \x05\x12\x04\xe1\x07\x04\x1c\x1aO\x20The\x20following\x20extension\x20ID\
    s\x20are\x20reserved\x20for\x20private\x20use\x20by\x20any\x20organizati\
    on.\n\n\x0e\n\x06\x04\x0c\x03\0\x05\x01\x12\x04\xe1\x07\x0f\x1b\n\x0f\n\
    \x07\x04\x0c\x03\0\x05\x01\x01\x12\x04\xe1\x07\x0f\x13\n\x0f\n\x07\x04\
    \x0c\x03\0\x05\x01\x02\x12\x04\xe1\x07\x17\x1b\n>\n\x04\x04\x0c\x02\0\
    \x12\x04\xe4\x07\x02.\x1a0\x20At\x20least\x20one\x20localized\x20image\
    \x20must\x20be\x20provided.\n\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xe4\
    \x07\x02\n\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\xe4\x07\x0b\x19\n\r\n\x05\
    \x04\x0c\x02\0\x01\x12\x04\xe4\x07\x1a)\n\r\n\x05\x04\x0c\x02\0\x03\x12\
    \x04\xe4\x07,-\n\xb9\x01\n\x03\x04\x0c\x05\x12\x04\xe9\x07\x02\x1a\x1a\
    \xab\x01\x20The\x20extensions\x20namespace\x20allows\x203rd-party\x20dev\
    elopers\x20to\x20extend\x20the\n\x20GTFS\x20Realtime\x20Specification\
    \x20in\x20order\x20to\x20add\x20and\x20evaluate\x20new\x20features\x20an\
    d\n\x20modifications\x20to\x20the\x20spec.\n\n\x0c\n\x04\x04\x0c\x05\0\
    \x12\x04\xe9\x07\r\x19\n\r\n\x05\x04\x0c\x05\0\x01\x12\x04\xe9\x07\r\x11\
    \n\r\n\x05\x04\x0c\x05\0\x02\x12\x04\xe9\x07\x15\x19\n\\\n\x03\x04\x0c\
    \x05\x12\x04\xec\x07\x02\x1a\x1aO\x20The\x20following\x20extension\x20ID\
    s\x20are\x20reserved\x20for\x20private\x20use\x20by\x20any\x20organizati\
    on.\n\n\x0c\n\x04\x04\x0c\x05\x01\x12\x04\xec\x07\r\x19\n\r\n\x05\x04\
    \x0c\x05\x01\x01\x12\x04\xec\x07\r\x11\n\r\n\x05\x04\x0c\x05\x01\x02\x12\
    \x04\xec\x07\x15\x19\n\xc6\x04\n\x02\x04\r\x12\x06\xf5\x07\0\x8a\x08\x01\
    \x1a\xb7\x04\x20Describes\x20the\x20physical\x20path\x20that\x20a\x20veh\
    icle\x20takes\x20when\x20it's\x20not\x20part\x20of\x20the\x20(CSV)\x20GT\
    FS,\n\x20such\x20as\x20for\x20a\x20detour.\x20Shapes\x20belong\x20to\x20\
    Trips,\x20and\x20consist\x20of\x20a\x20sequence\x20of\x20shape\x20points\
    .\n\x20Tracing\x20the\x20points\x20in\x20order\x20provides\x20the\x20pat\
    h\x20of\x20the\x20vehicle.\x20\x20Shapes\x20do\x20not\x20need\x20to\x20i\
    ntercept\n\x20the\x20location\x20of\x20Stops\x20exactly,\x20but\x20all\
    \x20Stops\x20on\x20a\x20trip\x20should\x20lie\x20within\x20a\x20small\
    \x20distance\x20of\n\x20the\x20shape\x20for\x20that\x20trip,\x20i.e.\x20\
    close\x20to\x20straight\x20line\x20segments\x20connecting\x20the\x20shap\
    e\x20points\n\x20NOTE:\x20This\x20message\x20is\x20still\x20experimental\
    ,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\x20formally\x20a\
    dopted\x20in\x20the\x20future.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xf5\x07\
    \x08\r\n\x9b\x03\n\x04\x04\r\x02\0\x12\x04\xfa\x07\x02\x1f\x1a\x8c\x03\
    \x20Identifier\x20of\x20the\x20shape.\x20Must\x20be\x20different\x20than\
    \x20any\x20shape_id\x20defined\x20in\x20the\x20(CSV)\x20GTFS.\n\x20This\
    \x20field\x20is\x20required\x20as\x20per\x20reference.md,\x20but\x20need\
    s\x20to\x20be\x20specified\x20here\x20optional\x20because\x20\"Required\
    \x20is\x20Forever\"\n\x20See\x20https://developers.google.com/protocol-b\
    uffers/docs/proto#specifying_field_rules\n\x20NOTE:\x20This\x20field\x20\
    is\x20still\x20experimental,\x20and\x20subject\x20to\x20change.\x20It\
    \x20may\x20be\x20formally\x20adopted\x20in\x20the\x20future.\n\n\r\n\x05\
    \x04\r\x02\0\x04\x12\x04\xfa\x07\x02\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \xfa\x07\x0b\x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xfa\x07\x12\x1a\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\xfa\x07\x1d\x1e\n\xa1\x04\n\x04\x04\r\x02\
    \x01\x12\x04\x81\x08\x02'\x1a\x92\x04\x20Encoded\x20polyline\x20represen\
    tation\x20of\x20the\x20shape.\x20This\x20polyline\x20must\x20contain\x20\
    at\x20least\x20two\x20points.\n\x20For\x20more\x20information\x20about\
    \x20encoded\x20polylines,\x20see\x20https://developers.google.com/maps/d\
    ocumentation/utilities/polylinealgorithm\n\x20This\x20field\x20is\x20req\
    uired\x20as\x20per\x20reference.md,\x20but\x20needs\x20to\x20be\x20speci\
    fied\x20here\x20optional\x20because\x20\"Required\x20is\x20Forever\"\n\
    \x20See\x20https://developers.google.com/protocol-buffers/docs/proto#spe\
    cifying_field_rules\n\x20NOTE:\x20This\x20field\x20is\x20still\x20experi\
    mental,\x20and\x20subject\x20to\x20change.\x20It\x20may\x20be\x20formall\
    y\x20adopted\x20in\x20the\x20future.\n\n\r\n\x05\x04\r\x02\x01\x04\x12\
    \x04\x81\x08\x02\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x81\x08\x0b\x11\n\
    \r\n\x05\x04\r\x02\x01\x01\x12\x04\x81\x08\x12\"\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\x81\x08%&\n\xb9\x01\n\x03\x04\r\x05\x12\x04\x86\x08\x02\x1a\
    \x1a\xab\x01\x20The\x20extensions\x20namespace\x20allows\x203rd-party\
    \x20developers\x20to\x20extend\x20the\n\x20GTFS\x20Realtime\x20Specifica\
    tion\x20in\x20order\x20to\x20add\x20and\x20evaluate\x20new\x20features\
    \x20and\n\x20modifications\x20to\x20the\x20spec.\n\n\x0c\n\x04\x04\r\x05\
    \0\x12\x04\x86\x08\r\x19\n\r\n\x05\x04\r\x05\0\x01\x12\x04\x86\x08\r\x11\
    \n\r\n\x05\x04\r\x05\0\x02\x12\x04\x86\x08\x15\x19\n\\\n\x03\x04\r\x05\
    \x12\x04\x89\x08\x02\x1a\x1aO\x20The\x20following\x20extension\x20IDs\
    \x20are\x20reserved\x20for\x20private\x20use\x20by\x20any\x20organizatio\
    n.\n\n\x0c\n\x04\x04\r\x05\x01\x12\x04\x89\x08\r\x19\n\r\n\x05\x04\r\x05\
    \x01\x01\x12\x04\x89\x08\r\x11\n\r\n\x05\x04\r\x05\x01\x02\x12\x04\x89\
    \x08\x15\x19\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(FeedMessage::generated_message_descriptor_data());
            messages.push(FeedHeader::generated_message_descriptor_data());
            messages.push(FeedEntity::generated_message_descriptor_data());
            messages.push(TripUpdate::generated_message_descriptor_data());
            messages.push(VehiclePosition::generated_message_descriptor_data());
            messages.push(Alert::generated_message_descriptor_data());
            messages.push(TimeRange::generated_message_descriptor_data());
            messages.push(Position::generated_message_descriptor_data());
            messages.push(TripDescriptor::generated_message_descriptor_data());
            messages.push(VehicleDescriptor::generated_message_descriptor_data());
            messages.push(EntitySelector::generated_message_descriptor_data());
            messages.push(TranslatedString::generated_message_descriptor_data());
            messages.push(TranslatedImage::generated_message_descriptor_data());
            messages.push(Shape::generated_message_descriptor_data());
            messages.push(trip_update::StopTimeEvent::generated_message_descriptor_data());
            messages.push(trip_update::StopTimeUpdate::generated_message_descriptor_data());
            messages.push(trip_update::TripProperties::generated_message_descriptor_data());
            messages.push(trip_update::stop_time_update::StopTimeProperties::generated_message_descriptor_data());
            messages.push(vehicle_position::CarriageDetails::generated_message_descriptor_data());
            messages.push(translated_string::Translation::generated_message_descriptor_data());
            messages.push(translated_image::LocalizedImage::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(10);
            enums.push(feed_header::Incrementality::generated_enum_descriptor_data());
            enums.push(trip_update::stop_time_update::ScheduleRelationship::generated_enum_descriptor_data());
            enums.push(vehicle_position::VehicleStopStatus::generated_enum_descriptor_data());
            enums.push(vehicle_position::CongestionLevel::generated_enum_descriptor_data());
            enums.push(vehicle_position::OccupancyStatus::generated_enum_descriptor_data());
            enums.push(alert::Cause::generated_enum_descriptor_data());
            enums.push(alert::Effect::generated_enum_descriptor_data());
            enums.push(alert::SeverityLevel::generated_enum_descriptor_data());
            enums.push(trip_descriptor::ScheduleRelationship::generated_enum_descriptor_data());
            enums.push(vehicle_descriptor::WheelchairAccessible::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
